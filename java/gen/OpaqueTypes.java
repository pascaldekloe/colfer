package gen;

// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf.


/**
 * OpaqueTypes mixes fixed and variable-sized values.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class OpaqueTypes
implements java.io.Serializable {

	/** The lower boundary on output bytes. */
	public static int MARSHAL_MIN = 52;
	/** The upper boundary on output bytes. */
	public static int MARSHAL_MAX = 4096;
	/** The lower boundary on input bytes. */
	public static int UNMARSHAL_MIN = 4;
	/** The upper boundary on input bytes. */
	public static int UNMARSHAL_MAX = 4096;
	/** The lower boundary for byte capacity on in and output buffers. */
	public static int BUF_MIN = (52 + 32 + 7) & ~7;

	/**
	 * Test 8-bit values.
	 */
	public byte a8;

	/**
	 * Test 8-bit arrays.
	 */
	public final byte[] a8n2 = new byte[2];

	/**
	 * Test 8-bit lists.
	 */
	public byte[] a8l = zero_a8l;

	/**
	 * Test 16-bit values.
	 */
	public short a16;

	/**
	 * Test 16-bit arrays.
	 */
	public final short[] a16n2 = new short[2];

	/**
	 * Test 16-bit lists.
	 */
	public short[] a16l = zero_a16l;

	/**
	 * Test 32-bit values.
	 */
	public int a32;

	/**
	 * Test 32-bit arrays.
	 */
	public final int[] a32n2 = new int[2];

	/**
	 * Test 32-bit lists.
	 */
	public int[] a32l = zero_a32l;

	/**
	 * Test 64-bit values.
	 */
	public long a64;

	/**
	 * Test 64-bit arrays.
	 */
	public final long[] a64n2 = new long[2];

	/**
	 * Test 64-bit lists.
	 */
	public long[] a64l = zero_a64l;
	private static final byte[] zero_a8l = new byte[0];
	private static final short[] zero_a16l = new short[0];
	private static final int[] zero_a32l = new int[0];
	private static final long[] zero_a64l = new long[0];

	private static final long[] COLFER_MASKS = {
		0,
		0xffL,
		0xffffL,
		0xffffffL,
		0xffffffffL,
		0xffffffffffL,
		0xffffffffffffL,
		0xffffffffffffffL,
		0xffffffffffffffffL,
	};

	private static final sun.misc.Unsafe java_unsafe;

	static {
		try {
			java.lang.reflect.Field f = Class.class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
			f.setAccessible(true);
			java_unsafe = (sun.misc.Unsafe) f.get(null);
		} catch (Exception e) {
			throw new Error("Java unsafe API required", e);
		}
	}

	/** Default constructor. */
	public OpaqueTypes() { }

	/** {@link java.io.InputStream} reader. */
	public static class Unmarshaller {

		/** The data source. */
		private final java.io.InputStream in;

		/** The read buffer. */
		private final byte[] buf;

		/** The start index in {@link #buf}. */
		private int off;

		/** The number of bytes in {@link #buf} (since {@link #off}). */
		private int len;


		/**
		 * Deserializes the following object.
		 * @param in the data source.
		 * @param bufn the buffer size in bytes.
		 */
		public Unmarshaller(java.io.InputStream in, int bufn) {
			this.in = in;
			this.buf = new byte[bufn < UNMARSHAL_MAX ? UNMARSHAL_MAX : bufn];
		}

		/**
		 * Unmarshals next in line.
		 * @return the result or {@code null} when EOF.
		 * @throws java.io.IOException from the {@code java.io.InputStream}.
		 * @throws java.io.EOFException on a partial record.
		 * @throws java.io.StreamCorruptedException when the data does not match this object's schema.
		 */
		public OpaqueTypes nextOrNull() throws java.io.IOException {
			if (len == 0) {
				off = 0;
				if (!read()) return null; // EOF
			} else if (buf.length - off < BUF_MIN) {
				System.arraycopy(buf, off, buf, 0, len);
				off = 0;
			}

			OpaqueTypes o = new OpaqueTypes();
			while (true) {
				int size = o.unmarshal(buf, off, len);
				if (size > 3) {
					off += size;
					len -= size;
					return o;
				}
				if (size != 0)
					throw new java.io.StreamCorruptedException("illegal Colfer encoding");
				if (off != 0) {
					System.arraycopy(buf, off, buf, 0, len);
					off = 0;
				}
				if (!read())
					throw new java.io.EOFException("partial Colfer encoding");
			}
		}

		/** Buffer more data. The return is {@code false} on EOF. */
		private boolean read() throws java.io.IOException {
			int pos = this.off + this.len;
			int n = in.read(buf, pos, buf.length - pos);
			if (n < 0) return false;
			this.len += n;
			return true;
		}

	}

	/**
	 * Writes a Colfer encoding to the buffer. The serial size is guaranteed
	 * with {@link #MARSHAL_MIN} and {@link #MARSHAL_MAX}. Marshal may write
	 * anywhere beyond the offset—not limited to the serial size.
	 *
	 * @param buf the output buffer.
	 * @param off the start index [offset] in the buffer.
	 * @return the encoding size.
	 * @throws IllegalArgumentException when the buffer capacity since the
	 *         offset is less than {@link BUF_MIN}.
	 * @throws java.nio.BufferOverflowException when the data exceeds the
	 *         buffer capacity or {@link #MARSHAL_MAX}.
	 */
	public int marshalWithBounds(byte[] buf, int off) {
		if (off < 0 || buf.length - off < BUF_MIN)
			throw new IllegalArgumentException("output buffer space less than BUF_MIN");

		int w = off + 52; // write index
		long word0 = 52 << 12;

		// pack .a8 opaque8
		word0 |= Byte.toUnsignedLong(this.a8) << 24;

		// pack .a8n2 opaque8
		word0 |= Byte.toUnsignedLong(this.a8n2[0]) << 32;
		word0 |= Byte.toUnsignedLong(this.a8n2[1]) << 40;

		// pack .a8l []opaque8
		if (this.a8l.length > 0xff)
			throw new java.nio.BufferOverflowException();
		word0 |= (long)this.a8l.length << 48;

		// pack .a16 opaque16
		long v4 = Short.toUnsignedLong(this.a16);
		word0 |= v4 << 56;
		long word1 = v4 >> 8;

		// pack .a16n2 opaque16
		long v5 = Short.toUnsignedLong(this.a16n2[0]);
		word1 |= v5 << 8;
		long v6 = Short.toUnsignedLong(this.a16n2[1]);
		word1 |= v6 << 24;

		// pack .a16l []opaque16
		if (this.a16l.length > 0xff)
			throw new java.nio.BufferOverflowException();
		word1 |= (long)this.a16l.length << 40;

		// pack .a32 opaque32
		long v8 = Integer.toUnsignedLong(this.a32);
		word1 |= v8 << 48;
		long word2 = v8 >> (64-48);

		// pack .a32n2 opaque32
		long v9 = Integer.toUnsignedLong(this.a32n2[0]);
		word2 |= v9 << 16;
		long v10 = Integer.toUnsignedLong(this.a32n2[1]);
		word2 |= v10 << 48;
		long word3 = v10 >> (64-48);

		// pack .a32l []opaque32
		if (this.a32l.length > 0xff)
			throw new java.nio.BufferOverflowException();
		word3 |= (long)this.a32l.length << 16;

		// pack .a64 opaque64
		long v12 = this.a64;
		word3 |= v12 << 24;
		long word4 = v12 >> (64-24);

		// pack .a64n2 opaque64
		long v13 = this.a64n2[0];
		word4 |= v13 << 24;
		long word5 = v13 >> (64-24);
		long v14 = this.a64n2[1];
		word5 |= v14 << 24;
		long word6 = v14 >> (64-24);

		// pack .a64l []opaque64
		if (this.a64l.length > 0xff)
			throw new java.nio.BufferOverflowException();
		word6 |= (long)this.a64l.length << 24;

		// write payloads
		if (buf.length - w < this.a64l.length << 3)
			throw new java.nio.BufferOverflowException();
		for (long b : this.a64l) {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 8;
		}
		if (buf.length - w < this.a32l.length << 2)
			throw new java.nio.BufferOverflowException();
		for (int b : this.a32l) {
			java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 4;
		}
		if (buf.length - w < this.a16l.length << 1)
			throw new java.nio.BufferOverflowException();
		for (short b : this.a16l) {
			java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 2;
		}
		if (buf.length - w < this.a8l.length)
			throw new java.nio.BufferOverflowException();
		java_unsafe.copyMemory(this.a8l, java_unsafe.ARRAY_BYTE_BASE_OFFSET,
			buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, this.a8l.length);
		w += this.a8l.length;

		// write fixed positions
		int size = w - off;
		if (size > MARSHAL_MAX)
			throw new java.nio.BufferOverflowException();
		word0 |= size;
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (0 * 8), word0);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (1 * 8), word1);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (2 * 8), word2);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (3 * 8), word3);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (4 * 8), word4);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (5 * 8), word5);
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (6 * 8) + 0,
			(byte)(word6 >>> (0 * 8)));
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (6 * 8) + 1,
			(byte)(word6 >>> (1 * 8)));
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (6 * 8) + 2,
			(byte)(word6 >>> (2 * 8)));
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (6 * 8) + 3,
			(byte)(word6 >>> (3 * 8)));
		return size;
	}

	/**
	 * Reads a Colfer encoding from the buffer. Objects can be reused. All
	 * fields are initialized regardless of their value beforehand.
	 *
	 * The number of bytes read is guaranteed to lie within in the range of
	 * [{@link #UNMARSHAL_MIN}..{@link #UNMARSHAL_MAX}]. Return {@code 1}
	 * signals malformed data. Return {@code 0} signals incomplete data,
	 * a.k.a. end-of-file.
	 *
	 * Data selection within the buffer, including its exceptions, matches
	 * Java's standard {@link java.io.InputStream#read(byte[],int,int) read}
	 * and {@link java.io.OutputStream#write(byte[],int,int) write}.
	 *
	 * @param buf the input buffer.
	 * @param off the start index [offset] in the buffer.
	 * @param len the number of bytes available since the offset.
	 * @return either the encoding size, or 0 for EOF, or 1 for malformed.
	 * @throws IllegalArgumentException when the buffer capacity minus its
	 *         offset is less than {@link #BUF_MIN}.
	 * @throws IndexOutOfBoundsException when the buffer capacity does not
	 *         match the offset–length combination.
	 */
	public int unmarshal(byte[] buf, int off, int len) {
		if ((off | len) < 0 || buf.length - off < len)
			throw new IndexOutOfBoundsException("range beyond buffer dimensions");
		if (buf.length - off < BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");
		if (len < 3) return 0;
		final long word0 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (0L * 8L));
		final long word1 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (1L * 8L));
		final long word2 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (2L * 8L));
		final long word3 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (3L * 8L));
		final long word4 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (4L * 8L));
		final long word5 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (5L * 8L));
		final long word6 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (6L * 8L));

		final int size = (int)word0 & 0xfff;
		final int fixed_size = (int)(word0 >> 12) & 0xfff;
		if (size < fixed_size || fixed_size < 4) return 1;
		if (size > len) return 0;

		// read index at variable section
		int r = off + fixed_size;
		int payload_offset = off + size; // packed in reverse order
		// unpack .a8 opaque8
		this.a8 = (byte)(word0 >> 24);
		// unpack .a8n2 opaque8
		this.a8n2[0] = (byte)(word0 >> 32);
		this.a8n2[1] = (byte)(word0 >> 40);
		// unpack .a8l []opaque8
		if (fixed_size <= 6) {
			this.a8l = this.zero_a8l;
		} else {
			this.a8l = new byte[(int)(word0 >> 48) & 0xff];
			payload_offset -= this.a8l.length;
			if (payload_offset < r) return 1;
			java_unsafe.copyMemory(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset,
				this.a8l, java_unsafe.ARRAY_BYTE_BASE_OFFSET,
				this.a8l.length);
		}
		// unpack .a16 opaque16
		short v4 = (short)(word0>>>56 | word1<<8);
		this.a16 = v4;
		// unpack .a16n2 opaque16
		short v5 = (short)(word1 >>> 8);
		this.a16n2[0] = v5;
		short v6 = (short)(word1 >>> 24);
		this.a16n2[1] = v6;
		// unpack .a16l []opaque16
		if (fixed_size <= 13) {
			this.a16l = this.zero_a16l;
		} else {
			this.a16l = new short[(int)(word1 >> 40) & 0xff];
			payload_offset -= this.a16l.length;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.a16l.length; i++)
				this.a16l[i] = java_unsafe.getShort(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<2);
		}
		// unpack .a32 opaque32
		int v8 = (int)(word1>>>48 | word2<<(64-48));
		this.a32 = v8;
		// unpack .a32n2 opaque32
		int v9 = (int)(word2 >>> 16);
		this.a32n2[0] = v9;
		int v10 = (int)(word2>>>48 | word3<<(64-48));
		this.a32n2[1] = v10;
		// unpack .a32l []opaque32
		if (fixed_size <= 26) {
			this.a32l = this.zero_a32l;
		} else {
			this.a32l = new int[(int)(word3 >> 16) & 0xff];
			payload_offset -= this.a32l.length << 2;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.a32l.length; i++)
				this.a32l[i] = java_unsafe.getInt(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<2);
		}
		// unpack .a64 opaque64
		long v12 = word3>>>24 | word4<<(64-24);
		this.a64 = v12;
		// unpack .a64n2 opaque64
		long v13 = word4>>>24 | word5<<(64-24);
		this.a64n2[0] = v13;
		long v14 = word5>>>24 | word6<<(64-24);
		this.a64n2[1] = v14;
		// unpack .a64l []opaque64
		if (fixed_size <= 51) {
			this.a64l = this.zero_a64l;
		} else {
			this.a64l = new long[(int)(word6 >> 24) & 0xff];
			payload_offset -= this.a64l.length << 3;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.a64l.length; i++)
				this.a64l[i] = java_unsafe.getLong(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<3);
		}


		if (payload_offset < r) return 1;
		// clear/undo absent fields
		if (fixed_size < 52) switch (fixed_size) {
			default:
				return 1;
			case 51:
			case 35:
				this.a64n2[0] = 0;
  
				this.a64n2[1] = 0;
  
			case 27:
				this.a64 = 0;
			case 26:
			case 18:
				this.a32n2[0] = 0;
  
				this.a32n2[1] = 0;
  
			case 14:
				this.a32 = 0;
			case 13:
			case 9:
				this.a16n2[0] = 0;
  
				this.a16n2[1] = 0;
  
			case 7:
				this.a16 = 0;
			case 6:
			case 4:
				this.a8n2[0] = 0;
  
				this.a8n2[1] = 0;
  
		}

		return size;
	}

	/**
	 * {@link java.io.Serializable} version number reflects the fields present.
	 * Values in range [0, 127] belong to Colfer version 1.
	 */
	private static final long serialVersionUID = 52L << 7;

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param out serial destination.
	 * @throws java.io.IOException a {@link java.io.WriteAbortedException}
	 *         or an {@link java.io.InvalidObjectException} when encoding
	 *         would exceed {@link #MARSHAL_MAX}.
	 * @throws java.io.IOException either an 
	 */
	private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		byte[] buf = new byte[MARSHAL_MAX];
		int n = marshalWithBounds(buf, 0);
		if (n == 0) throw new java.io.InvalidObjectException("MARSHAL_MAX reached");
		try {
			out.write(buf, 0, n);
		} catch (java.io.IOException e) {
			throw new java.io.WriteAbortedException("halt on Colfer payload", e);
		}
	}

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param in serial source.
	 * @throws ClassNotFoundException never.
	 * @throws java.io.IOException either from {@code in} or a
	 *  {@link java.io.StreamCorruptedException}.
	 */
	private void readObject(java.io.ObjectInputStream in)
	throws ClassNotFoundException, java.io.IOException {
		byte[] buf = new byte[UNMARSHAL_MAX];
		in.readFully(buf, 0, UNMARSHAL_MIN);
		int size = (buf[0] & 0xff) | (buf[1] & 0xf) << 8;
		in.readFully(buf, UNMARSHAL_MIN, size - UNMARSHAL_MIN);
		if (unmarshal(buf, 0, size) != size)
			throw new java.io.StreamCorruptedException("not a OpaqueTypes Colfer encoding");
	}

	/**
	 * Gets gen.OpaqueTypes.a8.
	 * @return the value.
	 */
	public byte getA8() {
		return this.a8;
	}
	/**
	 * Sets gen.OpaqueTypes.a8.
	 * @param value the replacement.
	 */
	public void setA8(byte value) {
		this.a8 = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a8.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA8(byte value) {
		setA8(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a8n2.
	 * @return the value.
	 */
	public byte[] getA8n2() {
		return this.a8n2;
	}

	/**
	 * Gets gen.OpaqueTypes.a8l.
	 * @return the value.
	 */
	public byte[] getA8l() {
		return this.a8l;
	}
	/**
	 * Sets gen.OpaqueTypes.a8l.
	 * @param value the replacement.
	 */
	public void setA8l(byte[] value) {
		this.a8l = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a8l.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA8l(byte[] value) {
		setA8l(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a16.
	 * @return the value.
	 */
	public short getA16() {
		return this.a16;
	}
	/**
	 * Sets gen.OpaqueTypes.a16.
	 * @param value the replacement.
	 */
	public void setA16(short value) {
		this.a16 = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a16.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA16(short value) {
		setA16(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a16n2.
	 * @return the value.
	 */
	public short[] getA16n2() {
		return this.a16n2;
	}

	/**
	 * Gets gen.OpaqueTypes.a16l.
	 * @return the value.
	 */
	public short[] getA16l() {
		return this.a16l;
	}
	/**
	 * Sets gen.OpaqueTypes.a16l.
	 * @param value the replacement.
	 */
	public void setA16l(short[] value) {
		this.a16l = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a16l.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA16l(short[] value) {
		setA16l(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a32.
	 * @return the value.
	 */
	public int getA32() {
		return this.a32;
	}
	/**
	 * Sets gen.OpaqueTypes.a32.
	 * @param value the replacement.
	 */
	public void setA32(int value) {
		this.a32 = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a32.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA32(int value) {
		setA32(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a32n2.
	 * @return the value.
	 */
	public int[] getA32n2() {
		return this.a32n2;
	}

	/**
	 * Gets gen.OpaqueTypes.a32l.
	 * @return the value.
	 */
	public int[] getA32l() {
		return this.a32l;
	}
	/**
	 * Sets gen.OpaqueTypes.a32l.
	 * @param value the replacement.
	 */
	public void setA32l(int[] value) {
		this.a32l = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a32l.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA32l(int[] value) {
		setA32l(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a64.
	 * @return the value.
	 */
	public long getA64() {
		return this.a64;
	}
	/**
	 * Sets gen.OpaqueTypes.a64.
	 * @param value the replacement.
	 */
	public void setA64(long value) {
		this.a64 = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a64.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA64(long value) {
		setA64(value);
		return this;
	}

	/**
	 * Gets gen.OpaqueTypes.a64n2.
	 * @return the value.
	 */
	public long[] getA64n2() {
		return this.a64n2;
	}

	/**
	 * Gets gen.OpaqueTypes.a64l.
	 * @return the value.
	 */
	public long[] getA64l() {
		return this.a64l;
	}
	/**
	 * Sets gen.OpaqueTypes.a64l.
	 * @param value the replacement.
	 */
	public void setA64l(long[] value) {
		this.a64l = value;
	}

	/**
	 * Sets gen.OpaqueTypes.a64l.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public OpaqueTypes withA64l(long[] value) {
		setA64l(value);
		return this;
	}

	/**
	 * Deep hash is consistent with {@link #equals(Object)}.
	 * @return the standard Java digest.
	 */
	@Override
	public final int hashCode() {
		int h = 1;
		h = h * 31 + (int)this.a8;
		h = h * 31 + (int)this.a8n2[0];
		h = h * 31 + (int)this.a8n2[1];
		h = h * 31 + java.util.Arrays.hashCode(this.a8l);
		h = h * 31 + (int)this.a16;
		h = h * 31 + (int)this.a16n2[0];
		h = h * 31 + (int)this.a16n2[1];
		h = h * 31 + java.util.Arrays.hashCode(this.a16l);
		h = h * 31 + this.a32;
		h = h * 31 + this.a32n2[0];
		h = h * 31 + this.a32n2[1];
		h = h * 31 + java.util.Arrays.hashCode(this.a32l);
		h = h * 31 + Long.hashCode(this.a64);
		h = h * 31 + Long.hashCode(this.a64n2[0]);
		h = h * 31 + Long.hashCode(this.a64n2[1]);
		h = h * 31 + java.util.Arrays.hashCode(this.a64l);
		return h;
	}

	/**
	 * Deep comparison is consistent with {@link #hashCode}.
	 * @param o anything, including {@code null}.
	 * @return the type and content match.
	 */
	@Override
	public final boolean equals(Object o) {
		return o instanceof OpaqueTypes && equals((OpaqueTypes)o);
	}

	/**
	 * Typed alternative to {@link #equals(Object)}.
	 * @param o same class or {@code null}.
	 * @return the content match.
	 */
	public final boolean equals(OpaqueTypes o) {
		if (o == null) return false;
		if (o == this) return true;

		return this.a8 == o.a8
			&& this.a8n2[0] == o.a8n2[0]
			&& this.a8n2[1] == o.a8n2[1]
			&& java.util.Arrays.equals(this.a8l, o.a8l)
			&& this.a16 == o.a16
			&& this.a16n2[0] == o.a16n2[0]
			&& this.a16n2[1] == o.a16n2[1]
			&& java.util.Arrays.equals(this.a16l, o.a16l)
			&& this.a32 == o.a32
			&& this.a32n2[0] == o.a32n2[0]
			&& this.a32n2[1] == o.a32n2[1]
			&& java.util.Arrays.equals(this.a32l, o.a32l)
			&& this.a64 == o.a64
			&& this.a64n2[0] == o.a64n2[0]
			&& this.a64n2[1] == o.a64n2[1]
			&& java.util.Arrays.equals(this.a64l, o.a64l);
	}
}
