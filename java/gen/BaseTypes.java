package gen;

// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf.

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.StreamCorruptedException;
import java.io.WriteAbortedException;
import java.lang.reflect.Field;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.time.Instant;

/**
 * BaseTypes contains all data types understood by Colfer.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class BaseTypes
implements Serializable {

	/**
	 * Test binary flags.
	 */
	public static final int B_FLAG = 1 << 0;

	/**
	 * Bit field for the booleans defined as *{@code _FLAG} constants above.
	 */
	public int _flags;

	/**
	 * Test 8 bit–unsigned integers.
	 */
	public byte u8;

	/**
	 * Test 8 bit–signed integers.
	 */
	public byte i8;

	/**
	 * Test 16 bit–unsigned integers.
	 */
	public short u16;

	/**
	 * Test 16 bit–signed integers.
	 */
	public short i16;

	/**
	 * Test 32 bit–unsigned integers.
	 */
	public int u32;

	/**
	 * Test 32 bit–signed integers.
	 */
	public int i32;

	/**
	 * Test 64 bit–unsigned integers.
	 */
	public long u64;

	/**
	 * Test 64 bit–signed integers.
	 */
	public long i64;

	/**
	 * Tests single precision–floating points.
	 */
	public float f32;

	/**
	 * Tests double precision–floating points.
	 */
	public double f64;

	/**
	 * Test timestamps (with nanosecond precision).
	 */
	public Instant t = Instant.EPOCH;

	/**
	 * Test Unicode strings of variable size.
	 */
	public String s = "";

	// Colfer internals
	private static final int FIXED_SIZE = 33;
	private static final int OVERFLOW_MAX = 48;
	private static final long[] COLFER_MASKS = {
		0,
		0xffL,
		0xffffL,
		0xffffffL,
		0xffffffffL,
		0xffffffffffL,
		0xffffffffffffL,
		0xffffffffffffffL,
		0xffffffffffffffffL,
	};
	private static final sun.misc.Unsafe java_unsafe;
	static {
		try {
			Field f = Class.class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
			f.setAccessible(true);
			java_unsafe = (sun.misc.Unsafe) f.get(null);
		} catch (Exception e) {
			throw new Error("Java unsafe API required", e);
		}
	}

	/**
	 * Encodings of this data structure have 3 bytes of overhead.
	 * @see "Colfer's “compact profile” header"
	 * @see #COLFER_MAX
	 */
	public static final int COLFER_MIN = 3;

	/**
	 * Encodings of this data structure are limited to 4 KiB in size.
	 * The actual limit for this specific version (as defined by {@link
	 * #MARSHAL_MAX}) could be less.
	 * @see "Colfer's “compact profile” limits"
	 * @see #COLFER_MIN
	 */
	public static final int COLFER_MAX = 4096;

	/**
	 * Encodings of this specific version of the data structure consist of
	 * at most {@code MARSHAL_MAX} bytes.
	 * @see #MARSHAL_BUF_MAX
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_MAX = COLFER_MAX;

	/**
	 * Output buffers must have a capacity of at least this byte count.
	 * The threshold can be higher than {@link #MARSHAL_MAX} in some cases.
	 * @see #MARSHAL_BUF_MAX
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_BUF_MIN = (FIXED_SIZE + OVERFLOW_MAX + 7) & ~7;

	/**
	 * Output buffer capacity beyound this byte count won't affect encoding.
	 * {@link #MARSHAL_BUF_MIN} ≤ {@code MARSHAL_BUF_MAX}
	 * @see #MARSHAL_MAX
	 * @see #MARSHAL_BUF_MIN
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_BUF_MAX = java.lang.Math.max(MARSHAL_MAX, MARSHAL_BUF_MIN);

	/**
	 * Unmarshal buffers must have a capacity of at least this byte count.
	 * {@link #COLFER_MIN} ≤ {@code UNMARSHAL_BUF_MIN} ≤ {@link #COLFER_MAX}
	 * @see #unmarshal(byte[],int,int)
	 */
	public static final int UNMARSHAL_BUF_MIN = (512 + OVERFLOW_MAX + 7) & ~7;

	/** Default constructor. */
	public BaseTypes() { }

	/** {@link java.io.InputStream} reader. */
	public static class Unmarshaller {

		/** The data source. */
		private final InputStream in;

		/** The read buffer. */
		private final byte[] buf;

		/** The start index in {@link #buf}. */
		private int off;

		/** The number of bytes in {@link #buf} (since {@link #off}). */
		private int len;


		/**
		 * Deserializes the following object.
		 * @param in the data source.
		 * @param bufn the buffer size in bytes.
		 */
		public Unmarshaller(InputStream in, int bufn) {
			this.in = in;
			this.buf = new byte[bufn < COLFER_MAX ? COLFER_MAX : bufn];
		}

		/**
		 * Unmarshals next in line.
		 * @return the result or {@code null} when EOF.
		 * @throws java.io.IOException from the {@code java.io.InputStream}.
		 * @throws java.io.EOFException on a partial record.
		 * @throws java.io.StreamCorruptedException when the data does not match this object's schema.
		 */
		public BaseTypes nextOrNull() throws IOException {
			if (len == 0) {
				off = 0;
				if (!read()) return null; // EOF
			} else if (buf.length - off < COLFER_MIN) {
				System.arraycopy(buf, off, buf, 0, len);
				off = 0;
			}

			BaseTypes o = new BaseTypes();
			while (true) {
				int size = o.unmarshal(buf, off, len);
				if (size > 3) {
					off += size;
					len -= size;
					return o;
				}
				if (size != 0)
					throw new StreamCorruptedException("illegal Colfer encoding");
				if (off != 0) {
					System.arraycopy(buf, off, buf, 0, len);
					off = 0;
				}
				if (!read())
					throw new EOFException("partial Colfer encoding");
			}
		}

		/** Buffer more data. The return is {@code false} on EOF. */
		private boolean read() throws IOException {
			int pos = this.off + this.len;
			int n = in.read(buf, pos, buf.length - pos);
			if (n < 0) return false;
			this.len += n;
			return true;
		}

	}

	/**
	 * Writes the Colfer encoding of {@code this} data structure to a buffer
	 * at an offset. Marshalling requires at least {@link #MARSHAL_BUF_MIN}
	 * of space since the offset, as in {@code buf.length} − {@code off} ≥
	 * {@code BaseTypes.MARSHAL_BUF_MIN}.
	 * Preferably, use {@link #MARSHAL_BUF_MAX}—not {@link #MARSHAL_MAX}—to
	 * prevent any buffer overflows from happening.
	 *
	 * The return is zero ({@code 0}) on any of the following, exclusively.
	 * <ul>
	 * <li>buffer overflow—only possible below {@link #MARSHAL_BUF_MAX}
	 * <li>{@link #COLFER_MAX} exceeded
	 * <li>a text exceeds 255 bytes of UTF-8
	 * <li>a list exceeds 255 entries—none present yet
	 * </ul>
	 *
	 * @param buf the output buffer.
	 * @param off the start index [offset] in the buffer.
	 * @return either the encoding size or {@code 0}.
	 * @throws IllegalArgumentException on {@link #MARSHAL_BUF_MIN} breach.
	 */
	public int marshal(byte[] buf, int off) {
		if (off < 0 || buf.length - off < MARSHAL_BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");

		// write index at variable section
		int w = off + FIXED_SIZE;
		long word0 = FIXED_SIZE << 15;

		// pack .u8 uint8
		word0 |= Byte.toUnsignedLong(this.u8) << 24;

		// pack .i8 int8
		word0 |= Byte.toUnsignedLong(this.i8) << 32;

		// pack .u16 uint16
		long v2 = Short.toUnsignedLong(this.u16);
		if ((v2 & ~127L) == 0) {
			v2 = v2 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v2);
			int bitCount = 64 - Long.numberOfLeadingZeros(v2);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v2 >>>= (tailSize << 3) - 1;
			v2 = (v2 | 1L) << tailSize & 0xff;
		}
		word0 |= v2 << 40;

		// pack .i16 int16
		long v3 = Integer.toUnsignedLong(this.i16>>15 ^ this.i16<<1);
		if ((v3 & ~127L) == 0) {
			v3 = v3 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v3);
			int bitCount = 64 - Long.numberOfLeadingZeros(v3);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v3 >>>= (tailSize << 3) - 1;
			v3 = (v3 | 1L) << tailSize & 0xff;
		}
		word0 |= v3 << 48;

		// pack .u32 uint32
		long v4 = Integer.toUnsignedLong(this.u32);
		if ((v4 & ~127L) == 0) {
			v4 = v4 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v4);
			int bitCount = 64 - Long.numberOfLeadingZeros(v4);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v4 >>>= (tailSize << 3) - 1;
			v4 = (v4 | 1L) << tailSize & 0xff;
		}
		word0 |= v4 << 56;

		// pack .i32 int32
		long v5 = Integer.toUnsignedLong(this.i32>>31 ^ this.i32<<1);
		if ((v5 & ~127L) == 0) {
			v5 = v5 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v5);
			int bitCount = 64 - Long.numberOfLeadingZeros(v5);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v5 >>>= (tailSize << 3) - 1;
			v5 = (v5 | 1L) << tailSize & 0xff;
		}
		long word1 = v5;

		// pack .u64 uint64
		long v6 = this.u64;
		if ((v6 & ~127L) == 0) {
			v6 = v6 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v6);
			int bitCount = 64 - Long.numberOfLeadingZeros(v6);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v6 >>>= (tailSize << 3) - 1;
			v6 = (v6 | 1L) << tailSize & 0xff;
		}
		word1 |= v6 << 8;

		// pack .i64 int64
		long v7 = this.i64>>63 ^ this.i64<<1;
		if ((v7 & ~127L) == 0) {
			v7 = v7 << 1 | 1L;
		} else {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, v7);
			int bitCount = 64 - Long.numberOfLeadingZeros(v7);
			int tailSize = (((bitCount - 1) >>> 3) + bitCount) >>> 3;
			w += tailSize;
			v7 >>>= (tailSize << 3) - 1;
			v7 = (v7 | 1L) << tailSize & 0xff;
		}
		word1 |= v7 << 16;

		// pack .f32 float32
		long v8 = Integer.toUnsignedLong(Float.floatToRawIntBits(this.f32));
		word1 |= v8 << 24;

		// pack .f64 float64
		long v9 = Double.doubleToRawLongBits(this.f64);
		word1 |= v9 << 56;
		long word2 = v9 >>> (64-56);

		// pack .t timestamp
		long v10 = this.t.getEpochSecond() << 30 | Integer.toUnsignedLong(this.t.getNano());
		word2 |= v10 << 56;
		long word3 = v10 >>> (64-56);

		// pack .s text

		// pack .b bool
		long word4 = this._flags>>>0 & 0xff;

		// write payloads
		{
			final int utf8_off = w;
			final int utf16_len = this.s.length();
			if (buf.length - w < utf16_len)
				return 0;
			// size check is lazily redone on multi-byte encodings
			for (int i = 0; i < utf16_len; i++) {
				char c = this.s.charAt(i);
				if (c < '\u0080') {
					java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)c);
				} else if (c < '\u0800') {
					if (buf.length - w < (utf16_len - i) + 1)
						return 0;
					java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
						(short)(0x80c0 | c >> 6 | (c & 0x3f) << 8));
					w += 2;
				} else if (! Character.isHighSurrogate(c)) {
					if (buf.length - w < (utf16_len - i) + 2)
						return 0;
					java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, 0x8080e0 |
						(int)c >>> 12 | ((int)c << 2) & 0x3f00 | ((int)c << 16) & 0x3f0000);
					w += 3;
				} else {
					char low = 0;
					if (i + 1 < utf16_len) low = this.s.charAt(++i);
					if (!Character.isLowSurrogate(low)) { // broken pair
						java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)'?');
						i--; // unread
					} else {
						if (buf.length - w < (utf16_len - i) + 3)
							return 0;
						int cp = Character.toCodePoint(c, low);
						java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
							0x808080f0 | cp>>>18 | (cp>>>4 & 0x3f00) |
							(cp<<10 & 0x3f0000) | (cp<<24 & 0x3f000000));
						w += 4;
					}
				}
			}

			// write size declaration
			int utf8_len = w - utf8_off;
			if (utf8_len > 255)
				return 0;
			word3 |= (long)utf8_len << 56;
		}

		// write fixed positions
		int size = w - off;
		if (size > COLFER_MAX)
			return 0;
		word0 |= size << 3;
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (0 * 8), word0);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (1 * 8), word1);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (2 * 8), word2);
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (3 * 8), word3);
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + (4 * 8) + 0,
			(byte)(word4 >>> (0 * 8)));
		return size;
	}

	/**
	 * Reads a Colfer encoding of {@code this} data strucure from a buffer
	 * range. All fields are updated, regardless of their value beforehand.
	 * Unmarshalling requires at least {@link #UNMARSHAL_BUF_MIN} of space
	 * since the offset, as in {@code buf.length} − {@code off} ≥ {@code
	 * BaseTypes.UNMARSHAL_BUF_MIN}.
	 * Preferably, use {@link #COLFER_MAX}—not {@link #MARSHAL_MAX}—to
	 * prevent any buffer underflows from happening.
	 *
	 * The return is zero ({@code 0}) on incomplete data, one ({@code 1}) on
	 * malformed data, or in range {@link #COLFER_MIN}..{@link #COLFER_MAX}
	 * on valid data. Note that the return may be less than {@code len}.
	 * Data selection within the buffer, including its exceptions, matches
	 * Java's standard {@link java.io.InputStream#read(byte[],int,int) read}
	 * and {@link java.io.OutputStream#write(byte[],int,int) write}.
	 *
	 * @param buf the input buffer.
	 * @param off the start index [offset] in the buffer.
	 * @param len the number of bytes available since the offset.
	 * @return either the encoding size, or {@code 0}, or {code 1}.
	 * @throws IllegalArgumentException when the buffer capacity minus its
	 *         offset is less than {@link #UNMARSHAL_BUF_MIN}.
	 * @throws IndexOutOfBoundsException when the buffer capacity does not
	 *         match the offset–length combination.
	 */
	public int unmarshal(byte[] buf, int off, int len) {
		if ((off | len) < 0 || buf.length - off < len)
			throw new IndexOutOfBoundsException("range beyond buffer dimensions");
		if (buf.length - off < UNMARSHAL_BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");
		final long word0 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (0L * 8L));
		final long word1 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (1L * 8L));
		final long word2 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (2L * 8L));
		final long word3 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (3L * 8L));
		final long word4 = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + (4L * 8L));

		final int size = (int)word0>>>3 & 0xfff;
		final int fixed_size = (int)word0>>>15 & 0x1ff;
		if (len < COLFER_MIN || size > len) return 0;

		// read index at variable section
		int r = off + fixed_size;
		int payload_offset = off + size; // packed in reverse order
		// unpack .u8 uint8
		this.u8 = (byte)(word0 >> 24);
		// unpack .i8 int8
		this.i8 = (byte)(word0 >> 32);
		// unpack .u16 uint16
		long v2 = word0 >>> (40 + 1) & 0x7f;
		if ((1L << 40 & word0) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v2 | 0x80) + 1;
			r += tailSize;
			v2 <<= (tailSize << 3) - tailSize;
			v2 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.u16 = (short)v2;
		// unpack .i16 int16
		long v3 = word0 >>> (48 + 1) & 0x7f;
		if ((1L << 48 & word0) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v3 | 0x80) + 1;
			r += tailSize;
			v3 <<= (tailSize << 3) - tailSize;
			v3 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.i16 = (short)((short)(v3 >>> 1) ^ -(short)(v3 & 1L));
		// unpack .u32 uint32
		long v4 = word0 >>> (56 + 1) & 0x7f;
		if ((1L << 56 & word0) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v4 | 0x80) + 1;
			r += tailSize;
			v4 <<= (tailSize << 3) - tailSize;
			v4 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.u32 = (int)v4;
		// unpack .i32 int32
		long v5 = word1 >>> (0 + 1) & 0x7f;
		if ((1L << 0 & word1) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v5 | 0x80) + 1;
			r += tailSize;
			v5 <<= (tailSize << 3) - tailSize;
			v5 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.i32 = (int)(v5 >>> 1) ^ -(int)(v5 & 1L);
		// unpack .u64 uint64
		long v6 = word1 >>> (8 + 1) & 0x7f;
		if ((1L << 8 & word1) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v6 | 0x80) + 1;
			r += tailSize;
			v6 <<= (tailSize << 3) - tailSize;
			v6 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.u64 = v6;
		// unpack .i64 int64
		long v7 = word1 >>> (16 + 1) & 0x7f;
		if ((1L << 16 & word1) == 0) {
			long tail = java_unsafe.getLong(buf, (long)(
				java_unsafe.ARRAY_BYTE_BASE_OFFSET + r));
			int tailSize = Long.numberOfTrailingZeros(v7 | 0x80) + 1;
			r += tailSize;
			v7 <<= (tailSize << 3) - tailSize;
			v7 |= tail & java_unsafe.getLong(COLFER_MASKS, (long)(
				java_unsafe.ARRAY_LONG_BASE_OFFSET +
				tailSize * java_unsafe.ARRAY_LONG_INDEX_SCALE));
		}
		this.i64 = v7 >>> 1 ^ -(v7 & 1L);
		// unpack .f32 float32
		int v8 = (int)(word1 >>> 24);
		this.f32 = Float.intBitsToFloat(v8);
		// unpack .f64 float64
		long v9 = word1>>>56 | word2<<(64-56);
		this.f64 = Double.longBitsToDouble(v9);
		// unpack .t timestamp
		long v10 = word2>>>56 | word3<<(64-56);
		this.t = Instant.ofEpochSecond(v10 >>> 30, (int)v10 & (1 << 30) - 1);
		// unpack .s text
		if (fixed_size <= 31) {
			this.s = "";
		} else {
			int utf8_length = (int)(word3 >>> 56) & 255;
			payload_offset -= utf8_length;
			if (payload_offset < r) return 1;
			this.s = new String(buf, payload_offset, utf8_length, UTF_8);
		}
		// unpack .b bool
		this._flags = (int)(word4 >>> 0) & 0xff;



		// clear/undo absent fields
		if (fixed_size < FIXED_SIZE) switch (fixed_size) {
			default:
				return 1;
			case 32:
				this._flags &= (1 << 0) - 1;
			case 31:
			case 23:
				this.t = Instant.EPOCH;
			case 15:
				this.f64 = 0;
			case 11:
				this.f32 = 0;
			case 10:
				this.i64 = 0;
			case 9:
				this.u64 = 0;
			case 8:
				this.i32 = 0;
			case 7:
				this.u32 = 0;
			case 6:
				this.i16 = 0;
			case 5:
				this.u16 = 0;
			case 4:
				this.i8 = 0;
		}

		return size;
	}

	/**
	 * {@link java.io.Serializable} version number reflects the fields present.
	 * Values in range [0, 127] belong to Colfer version 1.
	 */
	private static final long serialVersionUID = 13L << 7;

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param out serial destination.
	 * @throws java.io.IOException a {@link java.io.WriteAbortedException}
	 *         or an {@link java.io.InvalidObjectException} when encoding
	 *         would exceed {@link #MARSHAL_MAX}.
	 */
	private void writeObject(ObjectOutputStream out) throws IOException {
		byte[] buf = new byte[MARSHAL_BUF_MAX];
		int n = marshal(buf, 0);
		if (n == 0) throw new InvalidObjectException("Colfer's compact profile exceeded");
		try {
			out.write(buf, 0, n);
		} catch (IOException e) {
			throw new WriteAbortedException("halt on Colfer payload", e);
		}
	}

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param in serial source.
	 * @throws ClassNotFoundException never.
	 * @throws java.io.IOException either from {@code in} or a
	 *  {@link java.io.StreamCorruptedException}.
	 */
	private void readObject(ObjectInputStream in)
	throws ClassNotFoundException, IOException {
		byte[] buf = new byte[COLFER_MAX];
		in.readFully(buf, 0, COLFER_MIN);
		int head = java_unsafe.getInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET);
		int size = head>>>3 & 0xfff;
		in.readFully(buf, COLFER_MIN, size - COLFER_MIN);
		if (unmarshal(buf, 0, size) != size)
			throw new StreamCorruptedException("not a Colfer encoding of BaseTypes");
	}

	/**
	 * Gets gen.BaseTypes.u8.
	 * @return the value.
	 */
	public byte getU8() {
		return this.u8;
	}
	/**
	 * Sets gen.BaseTypes.u8.
	 * @param value the replacement.
	 */
	public void setU8(byte value) {
		this.u8 = value;
	}

	/**
	 * Sets gen.BaseTypes.u8.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withU8(byte value) {
		setU8(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.i8.
	 * @return the value.
	 */
	public byte getI8() {
		return this.i8;
	}
	/**
	 * Sets gen.BaseTypes.i8.
	 * @param value the replacement.
	 */
	public void setI8(byte value) {
		this.i8 = value;
	}

	/**
	 * Sets gen.BaseTypes.i8.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withI8(byte value) {
		setI8(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.u16.
	 * @return the value.
	 */
	public short getU16() {
		return this.u16;
	}
	/**
	 * Sets gen.BaseTypes.u16.
	 * @param value the replacement.
	 */
	public void setU16(short value) {
		this.u16 = value;
	}

	/**
	 * Sets gen.BaseTypes.u16.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withU16(short value) {
		setU16(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.i16.
	 * @return the value.
	 */
	public short getI16() {
		return this.i16;
	}
	/**
	 * Sets gen.BaseTypes.i16.
	 * @param value the replacement.
	 */
	public void setI16(short value) {
		this.i16 = value;
	}

	/**
	 * Sets gen.BaseTypes.i16.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withI16(short value) {
		setI16(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.u32.
	 * @return the value.
	 */
	public int getU32() {
		return this.u32;
	}
	/**
	 * Sets gen.BaseTypes.u32.
	 * @param value the replacement.
	 */
	public void setU32(int value) {
		this.u32 = value;
	}

	/**
	 * Sets gen.BaseTypes.u32.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withU32(int value) {
		setU32(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.i32.
	 * @return the value.
	 */
	public int getI32() {
		return this.i32;
	}
	/**
	 * Sets gen.BaseTypes.i32.
	 * @param value the replacement.
	 */
	public void setI32(int value) {
		this.i32 = value;
	}

	/**
	 * Sets gen.BaseTypes.i32.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withI32(int value) {
		setI32(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.u64.
	 * @return the value.
	 */
	public long getU64() {
		return this.u64;
	}
	/**
	 * Sets gen.BaseTypes.u64.
	 * @param value the replacement.
	 */
	public void setU64(long value) {
		this.u64 = value;
	}

	/**
	 * Sets gen.BaseTypes.u64.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withU64(long value) {
		setU64(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.i64.
	 * @return the value.
	 */
	public long getI64() {
		return this.i64;
	}
	/**
	 * Sets gen.BaseTypes.i64.
	 * @param value the replacement.
	 */
	public void setI64(long value) {
		this.i64 = value;
	}

	/**
	 * Sets gen.BaseTypes.i64.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withI64(long value) {
		setI64(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.f32.
	 * @return the value.
	 */
	public float getF32() {
		return this.f32;
	}
	/**
	 * Sets gen.BaseTypes.f32.
	 * @param value the replacement.
	 */
	public void setF32(float value) {
		this.f32 = value;
	}

	/**
	 * Sets gen.BaseTypes.f32.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withF32(float value) {
		setF32(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.f64.
	 * @return the value.
	 */
	public double getF64() {
		return this.f64;
	}
	/**
	 * Sets gen.BaseTypes.f64.
	 * @param value the replacement.
	 */
	public void setF64(double value) {
		this.f64 = value;
	}

	/**
	 * Sets gen.BaseTypes.f64.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withF64(double value) {
		setF64(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.t.
	 * @return the value.
	 */
	public Instant getT() {
		return this.t;
	}
	/**
	 * Sets gen.BaseTypes.t.
	 * @param value the replacement.
	 */
	public void setT(Instant value) {
		this.t = value;
	}

	/**
	 * Sets gen.BaseTypes.t.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withT(Instant value) {
		setT(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.s.
	 * @return the value.
	 */
	public String getS() {
		return this.s;
	}
	/**
	 * Sets gen.BaseTypes.s.
	 * @param value the replacement.
	 */
	public void setS(String value) {
		this.s = value;
	}

	/**
	 * Sets gen.BaseTypes.s.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withS(String value) {
		setS(value);
		return this;
	}

	/**
	 * Gets gen.BaseTypes.b.
	 * @return the value.
	 */
	public boolean getB() {
		return (this._flags & B_FLAG) != 0;
	}

	/**
	 * Sets gen.BaseTypes.b.
	 * @param value the replacement.
	 */
	public void setB(boolean value) {
		if (value) {
			this._flags |= B_FLAG;
		} else {
			this._flags &= ~B_FLAG;
		}
	}

	/**
	 * Sets gen.BaseTypes.b.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public BaseTypes withB(boolean value) {
		setB(value);
		return this;
	}

	/**
	 * Deep hash is consistent with {@link #equals(Object)}.
	 * @return the standard Java digest.
	 */
	@Override
	public final int hashCode() {
		int h = 1;
		h = h * 31 + (int)this.u8;
		h = h * 31 + (int)this.i8;
		h = h * 31 + (int)this.u16;
		h = h * 31 + (int)this.i16;
		h = h * 31 + this.u32;
		h = h * 31 + this.i32;
		h = h * 31 + Long.hashCode(this.u64);
		h = h * 31 + Long.hashCode(this.i64);
		h = h * 31 + Float.hashCode(this.f32);
		h = h * 31 + Double.hashCode(this.f64);
		h = h * 31 + this.t.hashCode();
		h = h * 31 + this.s.hashCode();
		h = h * 31 + this._flags;
		return h;
	}

	/**
	 * Deep comparison is consistent with {@link #hashCode}.
	 * Two not-a-number values compare equal.
	 * @param o anything, including {@code null}.
	 * @return the type and content match.
	 */
	@Override
	public final boolean equals(Object o) {
		return o instanceof BaseTypes && equals((BaseTypes)o);
	}

	/**
	 * Typed alternative to {@link #equals(Object)}.
	 * @param o same class or {@code null}.
	 * @return the content match.
	 */
	public final boolean equals(BaseTypes o) {
		if (o == null) return false;
		if (o == this) return true;

		return this.u8 == o.u8
			&& this.i8 == o.i8
			&& this.u16 == o.u16
			&& this.i16 == o.i16
			&& this.u32 == o.u32
			&& this.i32 == o.i32
			&& this.u64 == o.u64
			&& this.i64 == o.i64
			&& (this.f32 == o.f32 || (this.f32 != this.f32 && o.f32 != o.f32))
			&& (this.f64 == o.f64 || (this.f64 != this.f64 && o.f64 != o.f64))
			&& this.t.equals(o.t)
			&& this.s.equals(o.s)
			&& this._flags == o._flags;
	}
}
