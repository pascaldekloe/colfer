// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf for package gen.

#include "Colfer.h"
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// floating-point byte mapping
union f32m {
	float f;
	uint32_t u;
};

union f64m {
	double f;
	uint64_t u;
};

const uint64_t COLFER_MASKS[9] = {
	0,
	0xff,
	0xffff,
	0xffffff,
	0xffffffff,
	0xffffffffff,
	0xffffffffffff,
	0xffffffffffffff,
	0xffffffffffffffff,
};

// Saturating subtract prevents overflows branchless.
static inline size_t
satsub(size_t minuend, size_t subtrahend) {
	// TODO: utilize ARM instructions
	return (minuend - subtrahend) * (minuend >= subtrahend);
}

size_t
gen_base_types_marshal(const struct gen_base_types* o, void* start) {
	uint64_t word0 = 33 - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 33;

	// pack .b bool
	word0 |= (uint64_t)o->bools<<(24-0) & (uint64_t)0xff<<24;

	// pack .i8 int8
	word0 |= (uint64_t)(uint8_t)o->i8 << 32;

	// pack .u8 uint8
	word0 |= (uint64_t)o->u8 << 40;

	// pack .i16 int16
	uint64_t v3 = (uint16_t)(o->i16 >> 15) ^ (uint16_t)(o->i16 << 1);
	if (v3 < 128) {
		v3 = v3 << 1 | 1;
	} else {
		p[0] = v3;
		p[1] = v3 >> 8;
		p[2] = v3 >> 16;
		p[3] = v3 >> 24;
		p[4] = v3 >> 32;
		p[5] = v3 >> 40;
		p[6] = v3 >> 48;
		p[7] = v3 >> 56;

		size_t bit_count = __builtin_ffsll(v3);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 >>= (tail_size << 3) - 1;
		v3 = (v3 | 1) << tail_size;
	}
	word0 |= v3 << 48;

	// pack .u16 uint16
	uint64_t v4 = o->u16;
	if (v4 < 128) {
		v4 = v4 << 1 | 1;
	} else {
		p[0] = v4;
		p[1] = v4 >> 8;
		p[2] = v4 >> 16;
		p[3] = v4 >> 24;
		p[4] = v4 >> 32;
		p[5] = v4 >> 40;
		p[6] = v4 >> 48;
		p[7] = v4 >> 56;

		size_t bit_count = __builtin_ffsll(v4);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 >>= (tail_size << 3) - 1;
		v4 = (v4 | 1) << tail_size;
	}
	word0 |= v4 << 56;

	// pack .i32 int32
	uint64_t v5 = (uint32_t)(o->i32 >> 31) ^ (uint32_t)(o->i32 << 1);
	if (v5 < 128) {
		v5 = v5 << 1 | 1;
	} else {
		p[0] = v5;
		p[1] = v5 >> 8;
		p[2] = v5 >> 16;
		p[3] = v5 >> 24;
		p[4] = v5 >> 32;
		p[5] = v5 >> 40;
		p[6] = v5 >> 48;
		p[7] = v5 >> 56;

		size_t bit_count = __builtin_ffsll(v5);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 >>= (tail_size << 3) - 1;
		v5 = (v5 | 1) << tail_size;
	}
	uint64_t word1 = v5;

	// pack .u32 uint32
	uint64_t v6 = o->u32;
	if (v6 < 128) {
		v6 = v6 << 1 | 1;
	} else {
		p[0] = v6;
		p[1] = v6 >> 8;
		p[2] = v6 >> 16;
		p[3] = v6 >> 24;
		p[4] = v6 >> 32;
		p[5] = v6 >> 40;
		p[6] = v6 >> 48;
		p[7] = v6 >> 56;

		size_t bit_count = __builtin_ffsll(v6);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 >>= (tail_size << 3) - 1;
		v6 = (v6 | 1) << tail_size;
	}
	word1 |= v6 << 8;

	// pack .i64 int64
	uint64_t v7 = (o->i64 >> 63) ^ (o->i64 << 1);
	if (v7 < 128) {
		v7 = v7 << 1 | 1;
	} else {
		p[0] = v7;
		p[1] = v7 >> 8;
		p[2] = v7 >> 16;
		p[3] = v7 >> 24;
		p[4] = v7 >> 32;
		p[5] = v7 >> 40;
		p[6] = v7 >> 48;
		p[7] = v7 >> 56;

		size_t bit_count = __builtin_ffsll(v7);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 >>= (tail_size << 3) - 1;
		v7 = (v7 | 1) << tail_size;
	}
	word1 |= v7 << 16;

	// pack .u64 uint64
	uint64_t v8 = o->u64;
	if (v8 < 128) {
		v8 = v8 << 1 | 1;
	} else {
		p[0] = v8;
		p[1] = v8 >> 8;
		p[2] = v8 >> 16;
		p[3] = v8 >> 24;
		p[4] = v8 >> 32;
		p[5] = v8 >> 40;
		p[6] = v8 >> 48;
		p[7] = v8 >> 56;

		size_t bit_count = __builtin_ffsll(v8);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v8 >>= (tail_size << 3) - 1;
		v8 = (v8 | 1) << tail_size;
	}
	word1 |= v8 << 24;

	// pack .f32 float32
	union f32m m9;
	m9.f = o->f32;
	uint64_t v9 = m9.u;
	word1 |= v9 << 32;

	// pack .f64 float64
	union f64m m10;
	m10.f = o->f64;
	uint64_t v10 = m10.u;
	uint64_t word2 = v10;

	// pack .t timestamp
	uint64_t v11 = o->t.tv_sec;
	v11 <<= 30;
	v11 |= o->t.tv_nsec;
	uint64_t word3 = v11;

	// pack .s text
	uint64_t v12 = o->s.len;
	if (v12 < 128) {
		v12 = v12 << 1 | 1;
	} else {
		p[0] = v12;
		p[1] = v12 >> 8;
		p[2] = v12 >> 16;
		p[3] = v12 >> 24;
		p[4] = v12 >> 32;
		p[5] = v12 >> 40;
		p[6] = v12 >> 48;
		p[7] = v12 >> 56;

		size_t bit_count = __builtin_ffsll(v12);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v12 >>= (tail_size << 3) - 1;
		v12 = (v12 | 1) << tail_size;
	}
	uint64_t word4 = v12;

	// copy payloads
	const uint8_t *max = p + COLFER_MAX;
	{
		size_t size = o->s.len;
		if (max - p < size) return 0;
		memcpy(p, o->s.utf8, size);
		p += size;
	}

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - 33;
	word0 |= variable_size << 17;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 8);
	memcpy((uint8_t *)start + (3 * 8), &word3, 8);
	memcpy((uint8_t *)start + (4 * 8), &word4, 1);

	return size;
}

size_t
gen_base_types_unmarshal(struct gen_base_types* o, const void* start) {
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 8);
	uint64_t word2;
	memcpy(&word2, (uint8_t *)start + (2 * 8), 8);
	uint64_t word3;
	memcpy(&word3, (uint8_t *)start + (3 * 8), 8);
	uint64_t word4;
	memcpy(&word4, (uint8_t *)start + (4 * 8), 1);

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;

	// unpack .b bool
	o->bools = word0 >> 24 & 0xff;

	// unpack .i8 int8
	o->i8 = word0 >> 32;

	// unpack .u8 uint8
	o->u8 = word0 >> 40;

	// unpack .i16 int16
	uint64_t v3 = word0 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v3 | 0x80) + 1;
		p += tail_size;
		v3 <<= (tail_size << 3) - tail_size;
		v3 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16 = (int16_t)(v3 >> 1) ^ -(int16_t)(v3 & 1);

	// unpack .u16 uint16
	uint64_t v4 = word0 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v4 | 0x80) + 1;
		p += tail_size;
		v4 <<= (tail_size << 3) - tail_size;
		v4 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16 = v4;

	// unpack .i32 int32
	uint64_t v5 = word1 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v5 | 0x80) + 1;
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32 = (int32_t)(v5 >> 1) ^ -(int32_t)(v5 & 1);

	// unpack .u32 uint32
	uint64_t v6 = word1 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v6 | 0x80) + 1;
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32 = v6;

	// unpack .i64 int64
	uint64_t v7 = word1 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v7 | 0x80) + 1;
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->i64 = (int64_t)(v7 >> 1) ^ -(int64_t)(v7 & 1);

	// unpack .u64 uint64
	uint64_t v8 = word1 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v8 | 0x80) + 1;
		p += tail_size;
		v8 <<= (tail_size << 3) - tail_size;
		v8 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64 = v8;

	// unpack .f32 float32
	uint64_t v9 = word1 >> 32;
	union f32m m9;
	m9.u = v9;
	o->f32 = m9.f;

	// unpack .f64 float64
	uint64_t v10 = word2;
	union f64m m10;
	m10.u = v10;
	o->f64 = m10.f;

	// unpack .t timestamp
	uint64_t v11 = word3;
	o->t.tv_sec = v11 >> 30;
	o->t.tv_nsec = (1<<30) - 1 & v11;

	// unpack .s text
	uint64_t v12 = word4 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v12 | 0x80) + 1;
		p += tail_size;
		v12 <<= (tail_size << 3) - tail_size;
		v12 |= tail & COLFER_MASKS[tail_size];
	}
	o->s.len = v12;

	// clear/undo absent fields
	if (fixed_size < 33) {
		switch (fixed_size) {
		default:
			return 0;
		case 4:
			o->i8 = 0;
		case 5:
			o->u8 = 0;
		case 6:
			o->i16 = 0;
		case 7:
			o->u16 = 0;
		case 8:
			o->i32 = 0;
		case 9:
			o->u32 = 0;
		case 10:
			o->i64 = 0;
		case 11:
			o->u64 = 0;
		case 12:
			o->f32 = 0;
		case 16:
			o->f64 = 0;
		case 24:
			o->t.tv_sec = 0;
			o->t.tv_nsec = 0;
		case 32:
			o->s.len = 0;
			o->s.utf8 = 0;
		}
	}

	// copy payloads
	size_t offset = size;
	offset = satsub(offset, o->s.len);
	uint8_t *split = (uint8_t *)start + offset;
	if (split < p) return 0;
	p = split;
 

	{
		size_t len = o->s.len;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->s.utf8 = s;
		p += len;
	}

	return size;
}

size_t
gen_list_types_marshal(const struct gen_list_types* o, void* start) {
	uint64_t word0 = 11 - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 11;

	// pack .a8 []opaque8
	uint64_t v0 = o->a8.len;
	if (v0 < 128) {
		v0 = v0 << 1 | 1;
	} else {
		p[0] = v0;
		p[1] = v0 >> 8;
		p[2] = v0 >> 16;
		p[3] = v0 >> 24;
		p[4] = v0 >> 32;
		p[5] = v0 >> 40;
		p[6] = v0 >> 48;
		p[7] = v0 >> 56;

		size_t bit_count = __builtin_ffsll(v0);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 >>= (tail_size << 3) - 1;
		v0 = (v0 | 1) << tail_size;
	}
	word0 |= v0 << 24;

	// pack .a16 []opaque16
	uint64_t v1 = o->a16.len;
	if (v1 < 128) {
		v1 = v1 << 1 | 1;
	} else {
		p[0] = v1;
		p[1] = v1 >> 8;
		p[2] = v1 >> 16;
		p[3] = v1 >> 24;
		p[4] = v1 >> 32;
		p[5] = v1 >> 40;
		p[6] = v1 >> 48;
		p[7] = v1 >> 56;

		size_t bit_count = __builtin_ffsll(v1);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v1 >>= (tail_size << 3) - 1;
		v1 = (v1 | 1) << tail_size;
	}
	word0 |= v1 << 32;

	// pack .a32 []opaque32
	uint64_t v2 = o->a32.len;
	if (v2 < 128) {
		v2 = v2 << 1 | 1;
	} else {
		p[0] = v2;
		p[1] = v2 >> 8;
		p[2] = v2 >> 16;
		p[3] = v2 >> 24;
		p[4] = v2 >> 32;
		p[5] = v2 >> 40;
		p[6] = v2 >> 48;
		p[7] = v2 >> 56;

		size_t bit_count = __builtin_ffsll(v2);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v2 >>= (tail_size << 3) - 1;
		v2 = (v2 | 1) << tail_size;
	}
	word0 |= v2 << 40;

	// pack .a64 []opaque64
	uint64_t v3 = o->a64.len;
	if (v3 < 128) {
		v3 = v3 << 1 | 1;
	} else {
		p[0] = v3;
		p[1] = v3 >> 8;
		p[2] = v3 >> 16;
		p[3] = v3 >> 24;
		p[4] = v3 >> 32;
		p[5] = v3 >> 40;
		p[6] = v3 >> 48;
		p[7] = v3 >> 56;

		size_t bit_count = __builtin_ffsll(v3);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 >>= (tail_size << 3) - 1;
		v3 = (v3 | 1) << tail_size;
	}
	word0 |= v3 << 48;

	// pack .f32s []float32
	uint64_t v4 = o->f32s.len;
	if (v4 < 128) {
		v4 = v4 << 1 | 1;
	} else {
		p[0] = v4;
		p[1] = v4 >> 8;
		p[2] = v4 >> 16;
		p[3] = v4 >> 24;
		p[4] = v4 >> 32;
		p[5] = v4 >> 40;
		p[6] = v4 >> 48;
		p[7] = v4 >> 56;

		size_t bit_count = __builtin_ffsll(v4);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 >>= (tail_size << 3) - 1;
		v4 = (v4 | 1) << tail_size;
	}
	word0 |= v4 << 56;

	// pack .f64s []float64
	uint64_t v5 = o->f64s.len;
	if (v5 < 128) {
		v5 = v5 << 1 | 1;
	} else {
		p[0] = v5;
		p[1] = v5 >> 8;
		p[2] = v5 >> 16;
		p[3] = v5 >> 24;
		p[4] = v5 >> 32;
		p[5] = v5 >> 40;
		p[6] = v5 >> 48;
		p[7] = v5 >> 56;

		size_t bit_count = __builtin_ffsll(v5);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 >>= (tail_size << 3) - 1;
		v5 = (v5 | 1) << tail_size;
	}
	uint64_t word1 = v5;

	// pack .ts []timestamp
	uint64_t v6 = o->ts.len;
	if (v6 < 128) {
		v6 = v6 << 1 | 1;
	} else {
		p[0] = v6;
		p[1] = v6 >> 8;
		p[2] = v6 >> 16;
		p[3] = v6 >> 24;
		p[4] = v6 >> 32;
		p[5] = v6 >> 40;
		p[6] = v6 >> 48;
		p[7] = v6 >> 56;

		size_t bit_count = __builtin_ffsll(v6);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 >>= (tail_size << 3) - 1;
		v6 = (v6 | 1) << tail_size;
	}
	word1 |= v6 << 8;

	// pack .ss []text
	uint64_t v7 = o->ss.len;
	if (v7 < 128) {
		v7 = v7 << 1 | 1;
	} else {
		p[0] = v7;
		p[1] = v7 >> 8;
		p[2] = v7 >> 16;
		p[3] = v7 >> 24;
		p[4] = v7 >> 32;
		p[5] = v7 >> 40;
		p[6] = v7 >> 48;
		p[7] = v7 >> 56;

		size_t bit_count = __builtin_ffsll(v7);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 >>= (tail_size << 3) - 1;
		v7 = (v7 | 1) << tail_size;
	}
	word1 |= v7 << 16;

	// copy payloads
	const uint8_t *max = p + COLFER_MAX;
	for (size_t i = o->ss.len; i-- != 0; ) {
		// TODO: encode size
	}
	for (size_t i = o->ss.len; i-- != 0; ) {
		size_t size = o->ss.list[i].len;
		if (max - p < size) return 0;
		memcpy(p, o->ss.list[i].utf8, size);
		p += size;
	}
	{
		size_t i = o->ts.len;
		size_t size = i * 8;
		if (max - p < size) return 0;
		while (i--) {
			uint64_t v = (uint64_t)o->ts.list[i].tv_sec << 30;
			v |= o->ts.list[i].tv_nsec;
			memcpy(p, &v, 8);
			p += 8;
		}
	}
	{
		size_t size = o->f64s.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->f64s.list, size);
		p += size;
	}
	{
		size_t size = o->f32s.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->f32s.list, size);
		p += size;
	}
	{
		size_t size = o->a64.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->a64.list, size);
		p += size;
	}
	{
		size_t size = o->a32.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->a32.list, size);
		p += size;
	}
	{
		size_t size = o->a8.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->a8.list, size);
		p += size;
	}

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - 11;
	word0 |= variable_size << 17;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 3);

	return size;
}

size_t
gen_list_types_unmarshal(struct gen_list_types* o, const void* start) {
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 3);

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;

	// unpack .a8 []opaque8
	uint64_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v0 | 0x80) + 1;
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->a8.len = v0;

	// unpack .a16 []opaque16
	uint64_t v1 = word0 >> (32 + 1) & 0x7f;
	if (((uint64_t)1 << 32 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v1 | 0x80) + 1;
		p += tail_size;
		v1 <<= (tail_size << 3) - tail_size;
		v1 |= tail & COLFER_MASKS[tail_size];
	}
	o->a16.len = v1;

	// unpack .a32 []opaque32
	uint64_t v2 = word0 >> (40 + 1) & 0x7f;
	if (((uint64_t)1 << 40 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v2 | 0x80) + 1;
		p += tail_size;
		v2 <<= (tail_size << 3) - tail_size;
		v2 |= tail & COLFER_MASKS[tail_size];
	}
	o->a32.len = v2;

	// unpack .a64 []opaque64
	uint64_t v3 = word0 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v3 | 0x80) + 1;
		p += tail_size;
		v3 <<= (tail_size << 3) - tail_size;
		v3 |= tail & COLFER_MASKS[tail_size];
	}
	o->a64.len = v3;

	// unpack .f32s []float32
	uint64_t v4 = word0 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v4 | 0x80) + 1;
		p += tail_size;
		v4 <<= (tail_size << 3) - tail_size;
		v4 |= tail & COLFER_MASKS[tail_size];
	}
	o->f32s.len = v4;

	// unpack .f64s []float64
	uint64_t v5 = word1 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v5 | 0x80) + 1;
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->f64s.len = v5;

	// unpack .ts []timestamp
	uint64_t v6 = word1 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v6 | 0x80) + 1;
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->ts.len = v6;

	// unpack .ss []text
	uint64_t v7 = word1 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v7 | 0x80) + 1;
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->ss.len = v7;

	// clear/undo absent fields
	if (fixed_size < 11) {
		switch (fixed_size) {
		default:
			return 0;
		case 4:
			o->a16.len = 0;
		case 5:
			o->a32.len = 0;
		case 6:
			o->a64.len = 0;
		case 7:
			o->f32s.len = 0;
		case 8:
			o->f64s.len = 0;
		case 9:
			o->ts.len = 0;
		case 10:
			o->ss.len = 0;
		}
	}

	// copy payloads
	size_t offset = size;
	// TODO: unmarshal text list
	offset = satsub(offset, o->ts.len * 8);
	offset = satsub(offset, o->f64s.len * sizeof(double));
	offset = satsub(offset, o->f32s.len * sizeof(float));
	offset = satsub(offset, o->a64.len * sizeof(uint64_t));
	offset = satsub(offset, o->a32.len * sizeof(uint32_t));
	offset = satsub(offset, o->a16.len * sizeof(uint16_t));
	offset = satsub(offset, o->a8.len * sizeof(uint8_t));
	uint8_t *split = (uint8_t *)start + offset;
	if (split < p) return 0;
	p = split;
 

	if (o->ss.len != 0) {
		o->ss.list = malloc(o->ss.len);

		// TODO: parse text sizes

		for (int i = 0; i < o->ss.len; i++) {
			char *s = malloc(o->ss.list[i].len + 1);
			memcpy(s, p, o->ss.len);
			s[o->ss.list[i].len] = 0; // null terminator
			o->ss.list[i].utf8 = s;
		}
	}
	if (o->ts.len != 0) {
		size_t len = o->ts.len;
		o->ts.list = malloc(len * sizeof(struct timespec));
		const uint64_t *view = (uint64_t *)p;
		p += len * 8;
		for (size_t i = o->ts.len; i--; ) {
			o->ts.list[i].tv_sec = view[i] >> 30;
			o->ts.list[i].tv_nsec = view[i] & (1<<30) - 1;
		}
	}
	if (o->f64s.len != 0) {
		size_t len = o->f64s.len;
		o->f64s.list = malloc(len * 8);
		memcpy(o->f64s.list, p, len * 8);
		p += len * 8;
	}
	if (o->f32s.len != 0) {
		size_t len = o->f32s.len;
		o->f32s.list = malloc(len * 4);
		memcpy(o->f32s.list, p, len * 4);
		p += len * 4;
	}
	if (o->a64.len != 0) {
		size_t len = o->a64.len;
		o->a64.list = malloc(len * 8);
		memcpy(o->a64.list, p, len * 8);
		p += len * 8;
	}
	if (o->a32.len != 0) {
		size_t len = o->a32.len;
		o->a32.list = malloc(len * 4);
		memcpy(o->a32.list, p, len * 4);
		p += len * 4;
	}
	if (o->a16.len != 0) {
		size_t len = o->a16.len;
		o->a16.list = malloc(len * 2);
		memcpy(o->a16.list, p, len * 2);
		p += len * 2;
	}
	if (o->a8.len != 0) {
		size_t len = o->a8.len;
		o->a8.list = malloc(len);
		memcpy(o->a8.list, p, len);
		p += len;
	}

	return size;
}

size_t
gen_array_types_marshal(const struct gen_array_types* o, void* start) {
	uint64_t word0 = 67 - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 67;

	// pack .f32a2 float32
	union f32m m0;
	m0.f = o->f32a2[0];
	uint64_t v0 = m0.u;
	word0 |= v0 << 24;
	union f32m m1;
	m1.f = o->f32a2[1];
	uint64_t v1 = m1.u;
	word0 |= v1 << 56;
	uint64_t word1 = v1 >> (64-56);

	// pack .f64a3 float64
	union f64m m2;
	m2.f = o->f64a3[0];
	uint64_t v2 = m2.u;
	word1 |= v2 << 24;
	uint64_t word2 = v2 >> (64-24);
	union f64m m3;
	m3.f = o->f64a3[1];
	uint64_t v3 = m3.u;
	word2 |= v3 << 24;
	uint64_t word3 = v3 >> (64-24);
	union f64m m4;
	m4.f = o->f64a3[2];
	uint64_t v4 = m4.u;
	word3 |= v4 << 24;
	uint64_t word4 = v4 >> (64-24);

	// pack .u64a2 uint64
	uint64_t v5 = o->u64a2[0];
	if (v5 < 128) {
		v5 = v5 << 1 | 1;
	} else {
		p[0] = v5;
		p[1] = v5 >> 8;
		p[2] = v5 >> 16;
		p[3] = v5 >> 24;
		p[4] = v5 >> 32;
		p[5] = v5 >> 40;
		p[6] = v5 >> 48;
		p[7] = v5 >> 56;

		size_t bit_count = __builtin_ffsll(v5);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 >>= (tail_size << 3) - 1;
		v5 = (v5 | 1) << tail_size;
	}
	word4 |= v5 << 24;
	uint64_t v6 = o->u64a2[1];
	if (v6 < 128) {
		v6 = v6 << 1 | 1;
	} else {
		p[0] = v6;
		p[1] = v6 >> 8;
		p[2] = v6 >> 16;
		p[3] = v6 >> 24;
		p[4] = v6 >> 32;
		p[5] = v6 >> 40;
		p[6] = v6 >> 48;
		p[7] = v6 >> 56;

		size_t bit_count = __builtin_ffsll(v6);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 >>= (tail_size << 3) - 1;
		v6 = (v6 | 1) << tail_size;
	}
	word4 |= v6 << 32;

	// pack .i32a2 int32
	uint64_t v7 = (uint32_t)(o->i32a2[0] >> 31) ^ (uint32_t)(o->i32a2[0] << 1);
	if (v7 < 128) {
		v7 = v7 << 1 | 1;
	} else {
		p[0] = v7;
		p[1] = v7 >> 8;
		p[2] = v7 >> 16;
		p[3] = v7 >> 24;
		p[4] = v7 >> 32;
		p[5] = v7 >> 40;
		p[6] = v7 >> 48;
		p[7] = v7 >> 56;

		size_t bit_count = __builtin_ffsll(v7);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 >>= (tail_size << 3) - 1;
		v7 = (v7 | 1) << tail_size;
	}
	word4 |= v7 << 40;
	uint64_t v8 = (uint32_t)(o->i32a2[1] >> 31) ^ (uint32_t)(o->i32a2[1] << 1);
	if (v8 < 128) {
		v8 = v8 << 1 | 1;
	} else {
		p[0] = v8;
		p[1] = v8 >> 8;
		p[2] = v8 >> 16;
		p[3] = v8 >> 24;
		p[4] = v8 >> 32;
		p[5] = v8 >> 40;
		p[6] = v8 >> 48;
		p[7] = v8 >> 56;

		size_t bit_count = __builtin_ffsll(v8);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v8 >>= (tail_size << 3) - 1;
		v8 = (v8 | 1) << tail_size;
	}
	word4 |= v8 << 48;

	// pack .u32a2 uint32
	uint64_t v9 = o->u32a2[0];
	if (v9 < 128) {
		v9 = v9 << 1 | 1;
	} else {
		p[0] = v9;
		p[1] = v9 >> 8;
		p[2] = v9 >> 16;
		p[3] = v9 >> 24;
		p[4] = v9 >> 32;
		p[5] = v9 >> 40;
		p[6] = v9 >> 48;
		p[7] = v9 >> 56;

		size_t bit_count = __builtin_ffsll(v9);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v9 >>= (tail_size << 3) - 1;
		v9 = (v9 | 1) << tail_size;
	}
	word4 |= v9 << 56;
	uint64_t v10 = o->u32a2[1];
	if (v10 < 128) {
		v10 = v10 << 1 | 1;
	} else {
		p[0] = v10;
		p[1] = v10 >> 8;
		p[2] = v10 >> 16;
		p[3] = v10 >> 24;
		p[4] = v10 >> 32;
		p[5] = v10 >> 40;
		p[6] = v10 >> 48;
		p[7] = v10 >> 56;

		size_t bit_count = __builtin_ffsll(v10);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v10 >>= (tail_size << 3) - 1;
		v10 = (v10 | 1) << tail_size;
	}
	uint64_t word5 = v10;

	// pack .i16a2 int16
	uint64_t v11 = (uint16_t)(o->i16a2[0] >> 15) ^ (uint16_t)(o->i16a2[0] << 1);
	if (v11 < 128) {
		v11 = v11 << 1 | 1;
	} else {
		p[0] = v11;
		p[1] = v11 >> 8;
		p[2] = v11 >> 16;
		p[3] = v11 >> 24;
		p[4] = v11 >> 32;
		p[5] = v11 >> 40;
		p[6] = v11 >> 48;
		p[7] = v11 >> 56;

		size_t bit_count = __builtin_ffsll(v11);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v11 >>= (tail_size << 3) - 1;
		v11 = (v11 | 1) << tail_size;
	}
	word5 |= v11 << 8;
	uint64_t v12 = (uint16_t)(o->i16a2[1] >> 15) ^ (uint16_t)(o->i16a2[1] << 1);
	if (v12 < 128) {
		v12 = v12 << 1 | 1;
	} else {
		p[0] = v12;
		p[1] = v12 >> 8;
		p[2] = v12 >> 16;
		p[3] = v12 >> 24;
		p[4] = v12 >> 32;
		p[5] = v12 >> 40;
		p[6] = v12 >> 48;
		p[7] = v12 >> 56;

		size_t bit_count = __builtin_ffsll(v12);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v12 >>= (tail_size << 3) - 1;
		v12 = (v12 | 1) << tail_size;
	}
	word5 |= v12 << 16;

	// pack .u16a2 uint16
	uint64_t v13 = o->u16a2[0];
	if (v13 < 128) {
		v13 = v13 << 1 | 1;
	} else {
		p[0] = v13;
		p[1] = v13 >> 8;
		p[2] = v13 >> 16;
		p[3] = v13 >> 24;
		p[4] = v13 >> 32;
		p[5] = v13 >> 40;
		p[6] = v13 >> 48;
		p[7] = v13 >> 56;

		size_t bit_count = __builtin_ffsll(v13);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v13 >>= (tail_size << 3) - 1;
		v13 = (v13 | 1) << tail_size;
	}
	word5 |= v13 << 24;
	uint64_t v14 = o->u16a2[1];
	if (v14 < 128) {
		v14 = v14 << 1 | 1;
	} else {
		p[0] = v14;
		p[1] = v14 >> 8;
		p[2] = v14 >> 16;
		p[3] = v14 >> 24;
		p[4] = v14 >> 32;
		p[5] = v14 >> 40;
		p[6] = v14 >> 48;
		p[7] = v14 >> 56;

		size_t bit_count = __builtin_ffsll(v14);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v14 >>= (tail_size << 3) - 1;
		v14 = (v14 | 1) << tail_size;
	}
	word5 |= v14 << 32;

	// pack .i8a2 int8
	word5 |= (uint64_t)(uint8_t)o->i8a2[0] << 40;
	word5 |= (uint64_t)(uint8_t)o->i8a2[1] << 48;

	// pack .u8a2 uint8
	word5 |= (uint64_t)o->u8a2[0] << 56;
	uint64_t word6 = o->u8a2[1];

	// pack .ta2 timestamp
	uint64_t v19 = o->ta2[0].tv_sec;
	v19 <<= 30;
	v19 |= o->ta2[0].tv_nsec;
	word6 |= v19 << 8;
	uint64_t word7 = v19 >> (64-8);
	uint64_t v20 = o->ta2[1].tv_sec;
	v20 <<= 30;
	v20 |= o->ta2[1].tv_nsec;
	word7 |= v20 << 8;
	uint64_t word8 = v20 >> (64-8);

	// pack .sa2 text
	uint64_t v21 = o->sa2[0].len;
	if (v21 < 128) {
		v21 = v21 << 1 | 1;
	} else {
		p[0] = v21;
		p[1] = v21 >> 8;
		p[2] = v21 >> 16;
		p[3] = v21 >> 24;
		p[4] = v21 >> 32;
		p[5] = v21 >> 40;
		p[6] = v21 >> 48;
		p[7] = v21 >> 56;

		size_t bit_count = __builtin_ffsll(v21);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v21 >>= (tail_size << 3) - 1;
		v21 = (v21 | 1) << tail_size;
	}
	word8 |= v21 << 8;
	uint64_t v22 = o->sa2[1].len;
	if (v22 < 128) {
		v22 = v22 << 1 | 1;
	} else {
		p[0] = v22;
		p[1] = v22 >> 8;
		p[2] = v22 >> 16;
		p[3] = v22 >> 24;
		p[4] = v22 >> 32;
		p[5] = v22 >> 40;
		p[6] = v22 >> 48;
		p[7] = v22 >> 56;

		size_t bit_count = __builtin_ffsll(v22);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v22 >>= (tail_size << 3) - 1;
		v22 = (v22 | 1) << tail_size;
	}
	word8 |= v22 << 16;

	// copy payloads
	const uint8_t *max = p + COLFER_MAX;
	{
		size_t size = o->sa2[0].len;
		if (max - p < size) return 0;
		memcpy(p, o->sa2[0].utf8, size);
		p += size;
	}
	{
		size_t size = o->sa2[1].len;
		if (max - p < size) return 0;
		memcpy(p, o->sa2[1].utf8, size);
		p += size;
	}

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - 67;
	word0 |= variable_size << 17;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 8);
	memcpy((uint8_t *)start + (3 * 8), &word3, 8);
	memcpy((uint8_t *)start + (4 * 8), &word4, 8);
	memcpy((uint8_t *)start + (5 * 8), &word5, 8);
	memcpy((uint8_t *)start + (6 * 8), &word6, 8);
	memcpy((uint8_t *)start + (7 * 8), &word7, 8);
	memcpy((uint8_t *)start + (8 * 8), &word8, 3);

	return size;
}

size_t
gen_array_types_unmarshal(struct gen_array_types* o, const void* start) {
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 8);
	uint64_t word2;
	memcpy(&word2, (uint8_t *)start + (2 * 8), 8);
	uint64_t word3;
	memcpy(&word3, (uint8_t *)start + (3 * 8), 8);
	uint64_t word4;
	memcpy(&word4, (uint8_t *)start + (4 * 8), 8);
	uint64_t word5;
	memcpy(&word5, (uint8_t *)start + (5 * 8), 8);
	uint64_t word6;
	memcpy(&word6, (uint8_t *)start + (6 * 8), 8);
	uint64_t word7;
	memcpy(&word7, (uint8_t *)start + (7 * 8), 8);
	uint64_t word8;
	memcpy(&word8, (uint8_t *)start + (8 * 8), 3);

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;

	// unpack .f32a2 float32
	uint64_t v0 = word0 >> 24;
	union f32m m0;
	m0.u = v0;
	o->f32a2[0] = m0.f;
	uint64_t v1 = word0>>56 | word1<<(64-56);
	union f32m m1;
	m1.u = v1;
	o->f32a2[1] = m1.f;

	// unpack .f64a3 float64
	uint64_t v2 = word1>>24 | word2<<(64-24);
	union f64m m2;
	m2.u = v2;
	o->f64a3[0] = m2.f;
	uint64_t v3 = word2>>24 | word3<<(64-24);
	union f64m m3;
	m3.u = v3;
	o->f64a3[1] = m3.f;
	uint64_t v4 = word3>>24 | word4<<(64-24);
	union f64m m4;
	m4.u = v4;
	o->f64a3[2] = m4.f;

	// unpack .u64a2 uint64
	uint64_t v5 = word4 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v5 | 0x80) + 1;
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64a2[0] = v5;
	uint64_t v6 = word4 >> (32 + 1) & 0x7f;
	if (((uint64_t)1 << 32 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v6 | 0x80) + 1;
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64a2[1] = v6;

	// unpack .i32a2 int32
	uint64_t v7 = word4 >> (40 + 1) & 0x7f;
	if (((uint64_t)1 << 40 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v7 | 0x80) + 1;
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32a2[0] = (int32_t)(v7 >> 1) ^ -(int32_t)(v7 & 1);
	uint64_t v8 = word4 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v8 | 0x80) + 1;
		p += tail_size;
		v8 <<= (tail_size << 3) - tail_size;
		v8 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32a2[1] = (int32_t)(v8 >> 1) ^ -(int32_t)(v8 & 1);

	// unpack .u32a2 uint32
	uint64_t v9 = word4 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v9 | 0x80) + 1;
		p += tail_size;
		v9 <<= (tail_size << 3) - tail_size;
		v9 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32a2[0] = v9;
	uint64_t v10 = word5 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word5) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v10 | 0x80) + 1;
		p += tail_size;
		v10 <<= (tail_size << 3) - tail_size;
		v10 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32a2[1] = v10;

	// unpack .i16a2 int16
	uint64_t v11 = word5 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word5) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v11 | 0x80) + 1;
		p += tail_size;
		v11 <<= (tail_size << 3) - tail_size;
		v11 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16a2[0] = (int16_t)(v11 >> 1) ^ -(int16_t)(v11 & 1);
	uint64_t v12 = word5 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word5) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v12 | 0x80) + 1;
		p += tail_size;
		v12 <<= (tail_size << 3) - tail_size;
		v12 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16a2[1] = (int16_t)(v12 >> 1) ^ -(int16_t)(v12 & 1);

	// unpack .u16a2 uint16
	uint64_t v13 = word5 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word5) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v13 | 0x80) + 1;
		p += tail_size;
		v13 <<= (tail_size << 3) - tail_size;
		v13 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16a2[0] = v13;
	uint64_t v14 = word5 >> (32 + 1) & 0x7f;
	if (((uint64_t)1 << 32 & word5) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v14 | 0x80) + 1;
		p += tail_size;
		v14 <<= (tail_size << 3) - tail_size;
		v14 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16a2[1] = v14;

	// unpack .i8a2 int8
	o->i8a2[0] = word5 >> 40;
	o->i8a2[1] = word5 >> 48;

	// unpack .u8a2 uint8
	o->u8a2[0] = word5 >> 56;
	o->u8a2[1] = word6 >> 0;

	// unpack .ta2 timestamp
	uint64_t v19 = word6>>8 | word7<<(64-8);
	o->ta2[0].tv_sec = v19 >> 30;
	o->ta2[0].tv_nsec = (1<<30) - 1 & v19;
	uint64_t v20 = word7>>8 | word8<<(64-8);
	o->ta2[1].tv_sec = v20 >> 30;
	o->ta2[1].tv_nsec = (1<<30) - 1 & v20;

	// unpack .sa2 text
	uint64_t v21 = word8 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word8) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v21 | 0x80) + 1;
		p += tail_size;
		v21 <<= (tail_size << 3) - tail_size;
		v21 |= tail & COLFER_MASKS[tail_size];
	}
	o->sa2[0].len = v21;
	uint64_t v22 = word8 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word8) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v22 | 0x80) + 1;
		p += tail_size;
		v22 <<= (tail_size << 3) - tail_size;
		v22 |= tail & COLFER_MASKS[tail_size];
	}
	o->sa2[1].len = v22;

	// clear/undo absent fields
	if (fixed_size < 67) {
		switch (fixed_size) {
		default:
			return 0;
		case 11:
			o->f64a3[0] = 0;
			o->f64a3[1] = 0;
			o->f64a3[2] = 0;
		case 35:
			o->u64a2[0] = 0;
			o->u64a2[1] = 0;
		case 37:
			o->i32a2[0] = 0;
			o->i32a2[1] = 0;
		case 39:
			o->u32a2[0] = 0;
			o->u32a2[1] = 0;
		case 41:
			o->i16a2[0] = 0;
			o->i16a2[1] = 0;
		case 43:
			o->u16a2[0] = 0;
			o->u16a2[1] = 0;
		case 45:
			o->i8a2[0] = 0;
			o->i8a2[1] = 0;
		case 47:
			o->u8a2[0] = 0;
			o->u8a2[1] = 0;
		case 49:
			o->ta2[0].tv_sec = 0;
			o->ta2[0].tv_nsec = 0;
			o->ta2[1].tv_sec = 0;
			o->ta2[1].tv_nsec = 0;
		case 65:
			o->sa2[0].len = 0;
			o->sa2[0].utf8 = 0;
			o->sa2[1].len = 0;
			o->sa2[1].utf8 = 0;
		}
	}

	// copy payloads
	size_t offset = size;
	offset = satsub(offset, o->sa2[0].len);
	offset = satsub(offset, o->sa2[1].len);
	uint8_t *split = (uint8_t *)start + offset;
	if (split < p) return 0;
	p = split;
 
    
	{
		size_t len = o->sa2[0].len ;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->sa2[0].utf8 = s;
		p += len;
	}
	{
		size_t len = o->sa2[1].len ;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->sa2[1].utf8 = s;
		p += len;
	}

	return size;
}

size_t
gen_opaque_types_marshal(const struct gen_opaque_types* o, void* start) {
	uint64_t word0 = 18 - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 18;

	// pack .a8 opaque8
	word0 |= (uint64_t)o->a8 << 24;

	// pack .a16 opaque16
	uint64_t v1 = o->a16;
	word0 |= v1 << 32;

	// pack .a32 opaque32
	uint64_t v2 = o->a32;
	word0 |= v2 << 48;
	uint64_t word1 = v2 >> (64-48);

	// pack .a64 opaque64
	uint64_t v3 = o->a64;
	word1 |= v3 << 16;
	uint64_t word2 = v3 >> (64-16);

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - 18;
	word0 |= variable_size << 17;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 2);

	return size;
}

size_t
gen_opaque_types_unmarshal(struct gen_opaque_types* o, const void* start) {
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 8);
	uint64_t word2;
	memcpy(&word2, (uint8_t *)start + (2 * 8), 2);

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;

	// unpack .a8 opaque8
	o->a8 = word0 >> 24;

	// unpack .a16 opaque16
	uint64_t v1 = word0 >> 32;
	o->a16 = v1;

	// unpack .a32 opaque32
	uint64_t v2 = word0>>48 | word1<<(64-48);
	o->a32 = v2;

	// unpack .a64 opaque64
	uint64_t v3 = word1>>16 | word2<<(64-16);
	o->a64 = v3;

	// clear/undo absent fields
	if (fixed_size < 18) {
		switch (fixed_size) {
		default:
			return 0;
		case 4:
			o->a16 = 0;
		case 6:
			o->a32 = 0;
		case 10:
			o->a64 = 0;
		}
	}

	return size;
}

size_t
gen_dromedary_case_marshal(const struct gen_dromedary_case* o, void* start) {
	uint64_t word0 = 5 - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 5;

	// pack .PascalCase text
	uint64_t v0 = o->pascal_case.len;
	if (v0 < 128) {
		v0 = v0 << 1 | 1;
	} else {
		p[0] = v0;
		p[1] = v0 >> 8;
		p[2] = v0 >> 16;
		p[3] = v0 >> 24;
		p[4] = v0 >> 32;
		p[5] = v0 >> 40;
		p[6] = v0 >> 48;
		p[7] = v0 >> 56;

		size_t bit_count = __builtin_ffsll(v0);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 >>= (tail_size << 3) - 1;
		v0 = (v0 | 1) << tail_size;
	}
	word0 |= v0 << 24;

	// pack .with_snake opaque8
	word0 |= (uint64_t)o->with_snake << 32;

	// copy payloads
	const uint8_t *max = p + COLFER_MAX;
	{
		size_t size = o->pascal_case.len;
		if (max - p < size) return 0;
		memcpy(p, o->pascal_case.utf8, size);
		p += size;
	}

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - 5;
	word0 |= variable_size << 17;
	memcpy((uint8_t *)start + (0 * 8), &word0, 5);

	return size;
}

size_t
gen_dromedary_case_unmarshal(struct gen_dromedary_case* o, const void* start) {
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 5);

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;

	// unpack .PascalCase text
	uint64_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v0 | 0x80) + 1;
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->pascal_case.len = v0;

	// unpack .with_snake opaque8
	o->with_snake = word0 >> 32;

	// clear/undo absent fields
	if (fixed_size < 5) {
		switch (fixed_size) {
		default:
			return 0;
		case 4:
			o->with_snake = 0;
		}
	}

	// copy payloads
	size_t offset = size;
	offset = satsub(offset, o->pascal_case.len);
	uint8_t *split = (uint8_t *)start + offset;
	if (split < p) return 0;
	p = split;
 

	{
		size_t len = o->pascal_case.len;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->pascal_case.utf8 = s;
		p += len;
	}

	return size;
}
