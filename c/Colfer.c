// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf for package gen.

#include "Colfer.h"
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// floating-point byte mapping
union f32m {
       float f;
       uint32_t u;
};

union f64m {
       double f;
       uint64_t u;
};

const uint64_t COLFER_MASKS[9] = {
    0,
    0xff,
    0xffff,
    0xffffff,
    0xffffffff,
    0xffffffffff,
    0xffffffffffff,
    0xffffffffffffff,
    0xffffffffffffffff,
};

size_t
gen_base_types_marshal(const struct gen_base_types* o, void* start) {
	// fixed section as 64-bit words
	uint64_t word0 = 34 - 4; // 16-bit size declaration

	// write cursor at variable section
	uint8_t *p = (uint8_t*)start + 34;

	// pack .b bool
	word0 |= (uint64_t)o->bools<<(24-0) & (uint64_t)0xff<<24;

	// pack .i8 int8
	word0 |= (uint64_t)(uint8_t)o->i8 << 32;

	// pack .u8 uint8
	word0 |= (uint64_t)o->u8 << 40;

	// pack .i16 int16
	uint64_t v3 = (uint16_t)(o->i16 >> 15) ^ (uint16_t)(o->i16 << 1);
	if (v3 < 128) {
		v3 = v3 << 1 | 1;
	} else {
		p[0] = v3;
		p[1] = v3 >> 8;
		p[2] = v3 >> 16;
		p[3] = v3 >> 24;
		p[4] = v3 >> 32;
		p[5] = v3 >> 40;
		p[6] = v3 >> 48;
		p[7] = v3 >> 56;

		size_t bit_count = __builtin_ffsll(v3);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 >>= (tail_size << 3) - 1;
		v3 = (v3 | 1) << tail_size;
	}
	word0 |= v3 << 48;

	// pack .u16 uint16
	uint64_t v4 = o->u16;
	if (v4 < 128) {
		v4 = v4 << 1 | 1;
	} else {
		p[0] = v4;
		p[1] = v4 >> 8;
		p[2] = v4 >> 16;
		p[3] = v4 >> 24;
		p[4] = v4 >> 32;
		p[5] = v4 >> 40;
		p[6] = v4 >> 48;
		p[7] = v4 >> 56;

		size_t bit_count = __builtin_ffsll(v4);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 >>= (tail_size << 3) - 1;
		v4 = (v4 | 1) << tail_size;
	}
	word0 |= v4 << 56;

	// pack .i32 int32
	uint64_t v5 = (uint32_t)(o->i32 >> 31) ^ (uint32_t)(o->i32 << 1);
	if (v5 < 128) {
		v5 = v5 << 1 | 1;
	} else {
		p[0] = v5;
		p[1] = v5 >> 8;
		p[2] = v5 >> 16;
		p[3] = v5 >> 24;
		p[4] = v5 >> 32;
		p[5] = v5 >> 40;
		p[6] = v5 >> 48;
		p[7] = v5 >> 56;

		size_t bit_count = __builtin_ffsll(v5);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 >>= (tail_size << 3) - 1;
		v5 = (v5 | 1) << tail_size;
	}
	uint64_t word1 = v5;

	// pack .u32 uint32
	uint64_t v6 = o->u32;
	if (v6 < 128) {
		v6 = v6 << 1 | 1;
	} else {
		p[0] = v6;
		p[1] = v6 >> 8;
		p[2] = v6 >> 16;
		p[3] = v6 >> 24;
		p[4] = v6 >> 32;
		p[5] = v6 >> 40;
		p[6] = v6 >> 48;
		p[7] = v6 >> 56;

		size_t bit_count = __builtin_ffsll(v6);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 >>= (tail_size << 3) - 1;
		v6 = (v6 | 1) << tail_size;
	}
	word1 |= v6 << 8;

	// pack .i64 int64
	uint64_t v7 = (o->i64 >> 63) ^ (o->i64 << 1);
	if (v7 < 128) {
		v7 = v7 << 1 | 1;
	} else {
		p[0] = v7;
		p[1] = v7 >> 8;
		p[2] = v7 >> 16;
		p[3] = v7 >> 24;
		p[4] = v7 >> 32;
		p[5] = v7 >> 40;
		p[6] = v7 >> 48;
		p[7] = v7 >> 56;

		size_t bit_count = __builtin_ffsll(v7);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 >>= (tail_size << 3) - 1;
		v7 = (v7 | 1) << tail_size;
	}
	word1 |= v7 << 16;

	// pack .u64 uint64
	uint64_t v8 = o->u64;
	if (v8 < 128) {
		v8 = v8 << 1 | 1;
	} else {
		p[0] = v8;
		p[1] = v8 >> 8;
		p[2] = v8 >> 16;
		p[3] = v8 >> 24;
		p[4] = v8 >> 32;
		p[5] = v8 >> 40;
		p[6] = v8 >> 48;
		p[7] = v8 >> 56;

		size_t bit_count = __builtin_ffsll(v8);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v8 >>= (tail_size << 3) - 1;
		v8 = (v8 | 1) << tail_size;
	}
	word1 |= v8 << 24;

	// pack .f32 float32
	union f32m m9;
	m9.f = o->f32;
	uint64_t v9 = m9.u;
	word1 |= v9 << 32;

	// pack .f64 float64
	union f64m m10;
	m10.f = o->f64;
	uint64_t v10 = m10.u;
	uint64_t word2 = v10;

	// pack .t timestamp
	uint64_t v11 = o->t.tv_sec;
	v11 <<= 30;
	v11 |= o->t.tv_nsec;
	uint64_t word3 = v11;

	// pack .a opaque
	uint64_t v12 = o->a.len;
	if (v12 < 128) {
		v12 = v12 << 1 | 1;
	} else {
		p[0] = v12;
		p[1] = v12 >> 8;
		p[2] = v12 >> 16;
		p[3] = v12 >> 24;
		p[4] = v12 >> 32;
		p[5] = v12 >> 40;
		p[6] = v12 >> 48;
		p[7] = v12 >> 56;

		size_t bit_count = __builtin_ffsll(v12);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v12 >>= (tail_size << 3) - 1;
		v12 = (v12 | 1) << tail_size;
	}
	uint64_t word4 = v12;

	// pack .s text
	uint64_t v13 = o->s.len;
	if (v13 < 128) {
		v13 = v13 << 1 | 1;
	} else {
		p[0] = v13;
		p[1] = v13 >> 8;
		p[2] = v13 >> 16;
		p[3] = v13 >> 24;
		p[4] = v13 >> 32;
		p[5] = v13 >> 40;
		p[6] = v13 >> 48;
		p[7] = v13 >> 56;

		size_t bit_count = __builtin_ffsll(v13);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v13 >>= (tail_size << 3) - 1;
		v13 = (v13 | 1) << tail_size;
	}
	word4 |= v13 << 8;

	// copy payloads
	if (o->s.len > COLFER_MAX - (p - (uint8_t*)start))
		return 0;
	memcpy(p, o->s.utf8, o->s.len);
	p += o->s.len;
	if (o->a.len > COLFER_MAX - (p - (uint8_t*)start))
		return 0;
	memcpy(p, o->a.octets, o->a.len);
	p += o->a.len;

	size_t size = p - (uint8_t*)start;

	// finish header
	word0 |= (uint64_t)(size - 34) << 17 | (1 << 16);
	memcpy((uint8_t*)start + (0 * 8), &word0, 8);
	memcpy((uint8_t*)start + (1 * 8), &word1, 8);
	memcpy((uint8_t*)start + (2 * 8), &word2, 8);
	memcpy((uint8_t*)start + (3 * 8), &word3, 8);
	memcpy((uint8_t*)start + (4 * 8), &word4, 2);

	return size;
}

size_t
gen_base_types_unmarshal(struct gen_base_types* o, const void* start) {
	// words of fixed section
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 8);
	uint64_t word2;
	memcpy(&word2, (uint8_t *)start + (2 * 8), 8);
	uint64_t word3;
	memcpy(&word3, (uint8_t *)start + (3 * 8), 8);
	uint64_t word4;
	memcpy(&word4, (uint8_t *)start + (4 * 8), 2);

	// read cursor at variable section
	uint8_t* p = (uint8_t*)start + (word0 & 0xffff) + 4;

	uint64_t v = word0 >> 17 & 0x7f;
	if (((uint64_t)1 << 16 & word0) == 0) {
		uint64_t tz = __builtin_ctz(v | 0x80) + 1;
		v <<= (tz << 3) - tz;
		v &= ~COLFER_MASKS[tz];
		uint64_t tail;
		memcpy(&tail, p, 8);
		v |= tail & COLFER_MASKS[tz];
		p += tz;
	}
	if (v > COLFER_MAX) return 0;
	size_t size = v + (word0 & 0xffff) + 4;

	// unpack .b bool
	o->bools = word0 >> 24 & 0xff;

	// unpack .i8 int8
	o->i8 = word0 >> 32;

	// unpack .u8 uint8
	o->u8 = word0 >> 40;

	// unpack .i16 int16
	uint64_t v3 = word0 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v3 | 0x80) + 1;
		p += tail_size;
		v3 <<= (tail_size << 3) - tail_size;
		v3 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16 = (int16_t)(v3 >> 1) ^ -(int16_t)(v3 & 1);

	// unpack .u16 uint16
	uint64_t v4 = word0 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v4 | 0x80) + 1;
		p += tail_size;
		v4 <<= (tail_size << 3) - tail_size;
		v4 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16 = v4;

	// unpack .i32 int32
	uint64_t v5 = word1 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v5 | 0x80) + 1;
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32 = (int32_t)(v5 >> 1) ^ -(int32_t)(v5 & 1);

	// unpack .u32 uint32
	uint64_t v6 = word1 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v6 | 0x80) + 1;
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32 = v6;

	// unpack .i64 int64
	uint64_t v7 = word1 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v7 | 0x80) + 1;
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->i64 = (int64_t)(v7 >> 1) ^ -(int64_t)(v7 & 1);

	// unpack .u64 uint64
	uint64_t v8 = word1 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word1) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v8 | 0x80) + 1;
		p += tail_size;
		v8 <<= (tail_size << 3) - tail_size;
		v8 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64 = v8;

	// unpack .f32 float32
	uint64_t v9 = word1 >> 32;
	union f32m m9;
	m9.u = v9;
	o->f32 = m9.f;

	// unpack .f64 float64
	uint64_t v10 = word2;
	union f64m m10;
	m10.u = v10;
	o->f64 = m10.f;

	// unpack .t timestamp
	uint64_t v11 = word3;
	o->t.tv_sec = v11 >> 30;
	o->t.tv_nsec = (1<<30) - 1 & v11;

	// unpack .a opaque
	uint64_t v12 = word4 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v12 | 0x80) + 1;
		p += tail_size;
		v12 <<= (tail_size << 3) - tail_size;
		v12 |= tail & COLFER_MASKS[tail_size];
	}
	o->a.len = v12;

	// unpack .s text
	uint64_t v13 = word4 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word4) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v13 | 0x80) + 1;
		p += tail_size;
		v13 <<= (tail_size << 3) - tail_size;
		v13 |= tail & COLFER_MASKS[tail_size];
	}
	o->s.len = v13;

	// clear/undo absent fields
	if ((word0 & 0xffff) < 34 - 4) {
		switch (word0 & 0xffff) {
		default:
			return 0;
		case 4 - 4:
			o->i8 = 0;
		case 5 - 4:
			o->u8 = 0;
		case 6 - 4:
			o->i16 = 0;
		case 7 - 4:
			o->u16 = 0;
		case 8 - 4:
			o->i32 = 0;
		case 9 - 4:
			o->u32 = 0;
		case 10 - 4:
			o->i64 = 0;
		case 11 - 4:
			o->u64 = 0;
		case 12 - 4:
			o->f32 = 0;
		case 16 - 4:
			o->f64 = 0;
		case 24 - 4:
			o->t.tv_sec = 0;
			o->t.tv_nsec = 0;
		case 32 - 4:
			o->a.len = 0;
		case 33 - 4:
			o->s.len = 0;
		}
	}
	// copy payloads
	uint8_t *end = (uint8_t *)start + size;
	uint8_t *offset = end;
	offset -= o->s.len;offset -= o->a.len;;
	if (offset < p) return 0;
  
	{
		char *s = malloc(o->s.len + 1);
		memcpy(s, offset, o->s.len);
		s[o->s.len] = 0; // null terminator
		o->s.utf8 = s;
		offset += o->s.len;
	}
  
	if (o->a.len) {
		o->a.octets = malloc(o->a.len);
		memcpy(o->a.octets, offset, o->a.len);
		offset += o->a.len;
	} else o->a.octets = NULL;
  
  
  
  
  
  
  
  
  
  
  
  

	return size;
}

size_t
gen_list_types_marshal(const struct gen_list_types* o, void* start) {
	// fixed section as 64-bit words
	uint64_t word0 = 7 - 4; // 16-bit size declaration

	// write cursor at variable section
	uint8_t *p = (uint8_t*)start + 7;

	// pack .f32s []float32
	uint64_t v0 = o->f32s.len;
	if (v0 < 128) {
		v0 = v0 << 1 | 1;
	} else {
		p[0] = v0;
		p[1] = v0 >> 8;
		p[2] = v0 >> 16;
		p[3] = v0 >> 24;
		p[4] = v0 >> 32;
		p[5] = v0 >> 40;
		p[6] = v0 >> 48;
		p[7] = v0 >> 56;

		size_t bit_count = __builtin_ffsll(v0);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 >>= (tail_size << 3) - 1;
		v0 = (v0 | 1) << tail_size;
	}
	word0 |= v0 << 24;

	// pack .f64s []float64
	uint64_t v1 = o->f64s.len;
	if (v1 < 128) {
		v1 = v1 << 1 | 1;
	} else {
		p[0] = v1;
		p[1] = v1 >> 8;
		p[2] = v1 >> 16;
		p[3] = v1 >> 24;
		p[4] = v1 >> 32;
		p[5] = v1 >> 40;
		p[6] = v1 >> 48;
		p[7] = v1 >> 56;

		size_t bit_count = __builtin_ffsll(v1);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v1 >>= (tail_size << 3) - 1;
		v1 = (v1 | 1) << tail_size;
	}
	word0 |= v1 << 32;

	// pack .as []opaque
	uint64_t v2 = o->as.len;
	if (v2 < 128) {
		v2 = v2 << 1 | 1;
	} else {
		p[0] = v2;
		p[1] = v2 >> 8;
		p[2] = v2 >> 16;
		p[3] = v2 >> 24;
		p[4] = v2 >> 32;
		p[5] = v2 >> 40;
		p[6] = v2 >> 48;
		p[7] = v2 >> 56;

		size_t bit_count = __builtin_ffsll(v2);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v2 >>= (tail_size << 3) - 1;
		v2 = (v2 | 1) << tail_size;
	}
	word0 |= v2 << 40;

	// pack .ss []text
	uint64_t v3 = o->ss.len;
	if (v3 < 128) {
		v3 = v3 << 1 | 1;
	} else {
		p[0] = v3;
		p[1] = v3 >> 8;
		p[2] = v3 >> 16;
		p[3] = v3 >> 24;
		p[4] = v3 >> 32;
		p[5] = v3 >> 40;
		p[6] = v3 >> 48;
		p[7] = v3 >> 56;

		size_t bit_count = __builtin_ffsll(v3);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 >>= (tail_size << 3) - 1;
		v3 = (v3 | 1) << tail_size;
	}
	word0 |= v3 << 48;

	// copy payloads

	size_t size = p - (uint8_t*)start;

	// finish header
	word0 |= (uint64_t)(size - 7) << 17 | (1 << 16);
	memcpy((uint8_t*)start + (0 * 8), &word0, 7);

	return size;
}

size_t
gen_list_types_unmarshal(struct gen_list_types* o, const void* start) {
	// words of fixed section
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 7);

	// read cursor at variable section
	uint8_t* p = (uint8_t*)start + (word0 & 0xffff) + 4;

	uint64_t v = word0 >> 17 & 0x7f;
	if (((uint64_t)1 << 16 & word0) == 0) {
		uint64_t tz = __builtin_ctz(v | 0x80) + 1;
		v <<= (tz << 3) - tz;
		v &= ~COLFER_MASKS[tz];
		uint64_t tail;
		memcpy(&tail, p, 8);
		v |= tail & COLFER_MASKS[tz];
		p += tz;
	}
	if (v > COLFER_MAX) return 0;
	size_t size = v + (word0 & 0xffff) + 4;

	// unpack .f32s []float32
	uint64_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v0 | 0x80) + 1;
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->f32s.len = v0;

	// unpack .f64s []float64
	uint64_t v1 = word0 >> (32 + 1) & 0x7f;
	if (((uint64_t)1 << 32 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v1 | 0x80) + 1;
		p += tail_size;
		v1 <<= (tail_size << 3) - tail_size;
		v1 |= tail & COLFER_MASKS[tail_size];
	}
	o->f64s.len = v1;

	// unpack .as []opaque
	uint64_t v2 = word0 >> (40 + 1) & 0x7f;
	if (((uint64_t)1 << 40 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v2 | 0x80) + 1;
		p += tail_size;
		v2 <<= (tail_size << 3) - tail_size;
		v2 |= tail & COLFER_MASKS[tail_size];
	}
	o->as.len = v2;

	// unpack .ss []text
	uint64_t v3 = word0 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v3 | 0x80) + 1;
		p += tail_size;
		v3 <<= (tail_size << 3) - tail_size;
		v3 |= tail & COLFER_MASKS[tail_size];
	}
	o->ss.len = v3;

	// clear/undo absent fields
	if ((word0 & 0xffff) < 7 - 4) {
		switch (word0 & 0xffff) {
		default:
			return 0;
		case 4 - 4:
			o->f64s.len = 0;
		case 5 - 4:
			o->as.len = 0;
		case 6 - 4:
			o->ss.len = 0;
		}
	}
	// copy payloads
	uint8_t *end = (uint8_t *)start + size;
	uint8_t *offset = end;
	offset -= o->ss.len;offset -= o->as.len;;
	if (offset < p) return 0;
  
	if (o->ss.len != 0) {
		o->ss.list = malloc(o->ss.len);

		// TODO: parse text sizes

		for (int i = 0; i < o->ss.len; i++) {
			char *s = malloc(o->ss.list[i].len + 1);
			memcpy(s, offset, o->ss.len);
			s[o->ss.list[i].len] = 0; // null terminator
			o->ss.list[i].utf8 = s;
		}
	}
  
	{
		// TODO
	}
  
  

	return size;
}

size_t
gen_opaque_types_marshal(const struct gen_opaque_types* o, void* start) {
	// fixed section as 64-bit words
	uint64_t word0 = 19 - 4; // 16-bit size declaration

	// write cursor at variable section
	uint8_t *p = (uint8_t*)start + 19;

	// pack .a opaque
	uint64_t v0 = o->a.len;
	if (v0 < 128) {
		v0 = v0 << 1 | 1;
	} else {
		p[0] = v0;
		p[1] = v0 >> 8;
		p[2] = v0 >> 16;
		p[3] = v0 >> 24;
		p[4] = v0 >> 32;
		p[5] = v0 >> 40;
		p[6] = v0 >> 48;
		p[7] = v0 >> 56;

		size_t bit_count = __builtin_ffsll(v0);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 >>= (tail_size << 3) - 1;
		v0 = (v0 | 1) << tail_size;
	}
	word0 |= v0 << 24;

	// pack .a8 opaque8
	word0 |= (uint64_t)o->a8 << 32;

	// pack .a16 opaque16
	uint64_t v2 = o->a16;
	word0 |= v2 << 40;

	// pack .a32 opaque32
	uint64_t v3 = o->a32;
	word0 |= v3 << 56;
	uint64_t word1 = v3 >> (64-56);

	// pack .a64 opaque64
	uint64_t v4 = o->a64;
	word1 |= v4 << 24;
        uint64_t word2 = v4 >> (64-24);

	// copy payloads
	if (o->a.len > COLFER_MAX - (p - (uint8_t*)start))
		return 0;
	memcpy(p, o->a.octets, o->a.len);
	p += o->a.len;

	size_t size = p - (uint8_t*)start;

	// finish header
	word0 |= (uint64_t)(size - 19) << 17 | (1 << 16);
	memcpy((uint8_t*)start + (0 * 8), &word0, 8);
	memcpy((uint8_t*)start + (1 * 8), &word1, 8);
	memcpy((uint8_t*)start + (2 * 8), &word2, 3);

	return size;
}

size_t
gen_opaque_types_unmarshal(struct gen_opaque_types* o, const void* start) {
	// words of fixed section
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 8);
	uint64_t word1;
	memcpy(&word1, (uint8_t *)start + (1 * 8), 8);
	uint64_t word2;
	memcpy(&word2, (uint8_t *)start + (2 * 8), 3);

	// read cursor at variable section
	uint8_t* p = (uint8_t*)start + (word0 & 0xffff) + 4;

	uint64_t v = word0 >> 17 & 0x7f;
	if (((uint64_t)1 << 16 & word0) == 0) {
		uint64_t tz = __builtin_ctz(v | 0x80) + 1;
		v <<= (tz << 3) - tz;
		v &= ~COLFER_MASKS[tz];
		uint64_t tail;
		memcpy(&tail, p, 8);
		v |= tail & COLFER_MASKS[tz];
		p += tz;
	}
	if (v > COLFER_MAX) return 0;
	size_t size = v + (word0 & 0xffff) + 4;

	// unpack .a opaque
	uint64_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v0 | 0x80) + 1;
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->a.len = v0;

	// unpack .a8 opaque8
	o->a8 = word0 >> 32;

	// unpack .a16 opaque16
	uint64_t v2 = word0 >> 40;
	o->a16 = v2;

	// unpack .a32 opaque32
	uint64_t v3 = word0>>56 | word1<<(64-56);
	o->a32 = v3;

	// unpack .a64 opaque64
	uint64_t v4 = word1>>24 | word2<<(64-24);
	o->a64 = v4;

	// clear/undo absent fields
	if ((word0 & 0xffff) < 19 - 4) {
		switch (word0 & 0xffff) {
		default:
			return 0;
		case 4 - 4:
			o->a8 = 0;
		case 5 - 4:
			o->a16 = 0;
		case 7 - 4:
			o->a32 = 0;
		case 11 - 4:
			o->a64 = 0;
		}
	}
	// copy payloads
	uint8_t *end = (uint8_t *)start + size;
	uint8_t *offset = end;
	offset -= o->a.len;;
	if (offset < p) return 0;
  
  
  
  
  
	if (o->a.len) {
		o->a.octets = malloc(o->a.len);
		memcpy(o->a.octets, offset, o->a.len);
		offset += o->a.len;
	} else o->a.octets = NULL;

	return size;
}

size_t
gen_dromedary_case_marshal(const struct gen_dromedary_case* o, void* start) {
	// fixed section as 64-bit words
	uint64_t word0 = 5 - 4; // 16-bit size declaration

	// write cursor at variable section
	uint8_t *p = (uint8_t*)start + 5;

	// pack .PascalCase text
	uint64_t v0 = o->pascal_case.len;
	if (v0 < 128) {
		v0 = v0 << 1 | 1;
	} else {
		p[0] = v0;
		p[1] = v0 >> 8;
		p[2] = v0 >> 16;
		p[3] = v0 >> 24;
		p[4] = v0 >> 32;
		p[5] = v0 >> 40;
		p[6] = v0 >> 48;
		p[7] = v0 >> 56;

		size_t bit_count = __builtin_ffsll(v0);
		size_t tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 >>= (tail_size << 3) - 1;
		v0 = (v0 | 1) << tail_size;
	}
	word0 |= v0 << 24;

	// pack .with_snake opaque8
	word0 |= (uint64_t)o->with_snake << 32;

	// copy payloads
	if (o->pascal_case.len > COLFER_MAX - (p - (uint8_t*)start))
		return 0;
	memcpy(p, o->pascal_case.utf8, o->pascal_case.len);
	p += o->pascal_case.len;

	size_t size = p - (uint8_t*)start;

	// finish header
	word0 |= (uint64_t)(size - 5) << 17 | (1 << 16);
	memcpy((uint8_t*)start + (0 * 8), &word0, 5);

	return size;
}

size_t
gen_dromedary_case_unmarshal(struct gen_dromedary_case* o, const void* start) {
	// words of fixed section
	uint64_t word0;
	memcpy(&word0, (uint8_t *)start + (0 * 8), 5);

	// read cursor at variable section
	uint8_t* p = (uint8_t*)start + (word0 & 0xffff) + 4;

	uint64_t v = word0 >> 17 & 0x7f;
	if (((uint64_t)1 << 16 & word0) == 0) {
		uint64_t tz = __builtin_ctz(v | 0x80) + 1;
		v <<= (tz << 3) - tz;
		v &= ~COLFER_MASKS[tz];
		uint64_t tail;
		memcpy(&tail, p, 8);
		v |= tail & COLFER_MASKS[tz];
		p += tz;
	}
	if (v > COLFER_MAX) return 0;
	size_t size = v + (word0 & 0xffff) + 4;

	// unpack .PascalCase text
	uint64_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		uint64_t tail = p[0];
		tail |= (uint64_t)p[1] << 8;
		tail |= (uint64_t)p[2] << 16;
		tail |= (uint64_t)p[3] << 24;
		tail |= (uint64_t)p[4] << 32;
		tail |= (uint64_t)p[5] << 40;
		tail |= (uint64_t)p[6] << 48;
		tail |= (uint64_t)p[7] << 56;

		size_t tail_size = __builtin_ctz(v0 | 0x80) + 1;
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->pascal_case.len = v0;

	// unpack .with_snake opaque8
	o->with_snake = word0 >> 32;

	// clear/undo absent fields
	if ((word0 & 0xffff) < 5 - 4) {
		switch (word0 & 0xffff) {
		default:
			return 0;
		case 4 - 4:
			o->with_snake = 0;
		}
	}
	// copy payloads
	uint8_t *end = (uint8_t *)start + size;
	uint8_t *offset = end;
	offset -= o->pascal_case.len;;
	if (offset < p) return 0;
  
  
	{
		char *s = malloc(o->pascal_case.len + 1);
		memcpy(s, offset, o->pascal_case.len);
		s[o->pascal_case.len] = 0; // null terminator
		o->pascal_case.utf8 = s;
		offset += o->pascal_case.len;
	}

	return size;
}
