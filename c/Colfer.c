// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file seal.colf for package seal.

#include "Colfer.h"
#include <stdint.h> // types with defined width
#include <string.h> // size_t & memcpy(3)

typedef unsigned long long word_t;

// floating-point byte mapping
union f32m {
	float f;
	uint32_t u;
};
union f64m {
	double f;
	uint64_t u;
};

const word_t COLFER_MASKS[9] = {
	0,
	0xff,
	0xffff,
	0xffffff,
	0xffffffff,
	0xffffffffff,
	0xffffffffffff,
	0xffffffffffffff,
	0xffffffffffffffff,
};

// Saturating subtract prevents overflows branchless.
static inline size_t
satsub(size_t minuend, size_t subtrahend) {
	// TODO: utilize ARM instructions
	return (minuend - subtrahend) * (minuend >= subtrahend);
}

size_t
seal_base_types_marshal(const struct seal_base_types* o, void* start) {
	word_t word0 = 33 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 33;

	// pack .u8 uint8
	word0 |= (word_t)o->u8 << 24;

	// pack .i8 int8
	word0 |= (word_t)(uint8_t)o->i8 << 32;

	// pack .u16 uint16
	word_t v2 = o->u16;
	if (v2 < 0x80) {
		v2 = v2<<1 | 1;
	} else {
		memcpy(p, &v2, 8);
		int bit_count = 64 - __builtin_clzll(v2);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v2 = v2 >> ((tail_size * 8) - 1) | 1;
		v2 = v2 << tail_size & 0xff;
	}
	word0 |= v2 << 40;

	// pack .i16 int16
	word_t v3 = (uint16_t)(o->i16 >> 15) ^ (uint16_t)(o->i16 << 1);
	if (v3 < 0x80) {
		v3 = v3<<1 | 1;
	} else {
		memcpy(p, &v3, 8);
		int bit_count = 64 - __builtin_clzll(v3);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 = v3 >> ((tail_size * 8) - 1) | 1;
		v3 = v3 << tail_size & 0xff;
	}
	word0 |= v3 << 48;

	// pack .u32 uint32
	word_t v4 = o->u32;
	if (v4 < 0x80) {
		v4 = v4<<1 | 1;
	} else {
		memcpy(p, &v4, 8);
		int bit_count = 64 - __builtin_clzll(v4);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 = v4 >> ((tail_size * 8) - 1) | 1;
		v4 = v4 << tail_size & 0xff;
	}
	word0 |= v4 << 56;

	// pack .i32 int32
	word_t v5 = (uint32_t)(o->i32 >> 31) ^ (uint32_t)(o->i32 << 1);
	if (v5 < 0x80) {
		v5 = v5<<1 | 1;
	} else {
		memcpy(p, &v5, 8);
		int bit_count = 64 - __builtin_clzll(v5);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 = v5 >> ((tail_size * 8) - 1) | 1;
		v5 = v5 << tail_size & 0xff;
	}
	word_t word1 = v5;

	// pack .u64 uint64
	word_t v6 = o->u64;
	if (v6 < 0x80) {
		v6 = v6<<1 | 1;
	} else {
		memcpy(p, &v6, 8);
		int bit_count = 64 - __builtin_clzll(v6);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 = v6 >> ((tail_size * 8) - 1) | 1;
		v6 = v6 << tail_size & 0xff;
	}
	word1 |= v6 << 8;

	// pack .i64 int64
	word_t v7 = (o->i64 >> 63) ^ (o->i64 << 1);
	if (v7 < 0x80) {
		v7 = v7<<1 | 1;
	} else {
		memcpy(p, &v7, 8);
		int bit_count = 64 - __builtin_clzll(v7);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 = v7 >> ((tail_size * 8) - 1) | 1;
		v7 = v7 << tail_size & 0xff;
	}
	word1 |= v7 << 16;

	// pack .f32 float32
	word_t v8 = (union f32m){.f = o->f32}.u;
	word1 |= v8 << 24;

	// pack .f64 float64
	word_t v9 = (union f64m){.f = o->f64}.u;
	word1 |= v9 << 56;
	uint64_t word2 = v9 >> (64-56);

	// pack .t timestamp
	word_t v10 = o->t.tv_sec;
	v10 <<= 30;
	v10 |= o->t.tv_nsec;
	word2 |= v10 << 56;
	uint64_t word3 = v10 >> (64-56);

	// pack .s text
	if (o->s.len > 255) return 0;
	word3 |= (word_t)o->s.len << 56;

	// pack .b bool
	word_t word4 = (word_t)o->_flags>>0 & 0xff;

	// copy payloads
	const uint8_t *max = p + 0xfff;
	{
		size_t z = o->s.len;
		if (max - p < z) return 0;
		memcpy(p, o->s.utf8, z);
		p += z;
	}

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 8);
	memcpy((uint8_t *)start + (3 * 8), &word3, 8);
	memcpy((uint8_t *)start + (4 * 8), &word4, 1);

	return size;
}

size_t
seal_base_types_unmarshal(struct seal_base_types* o, const void* start, void* (*malloc)(size_t)) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 8);
	word_t word1;
	memcpy(&word1, &base[1 * 8], 8);
	word_t word2;
	memcpy(&word2, &base[2 * 8], 8);
	word_t word3;
	memcpy(&word3, &base[3 * 8], 8);
	word_t word4;
	memcpy(&word4, &base[4 * 8], 1);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_base_types){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .u8 uint8
	o->u8 = word0 >> 24;

	// unpack .i8 int8
	o->i8 = word0 >> 32;

	// unpack .u16 uint16
	word_t v2 = word0 >> (40 + 1) & 0x7f;
	if (((uint64_t)1 << 40 & word0) == 0) {
		int tail_size = __builtin_ctz(v2 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v2 <<= (tail_size << 3) - tail_size;
		v2 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16 = v2;

	// unpack .i16 int16
	word_t v3 = word0 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word0) == 0) {
		int tail_size = __builtin_ctz(v3 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v3 <<= (tail_size << 3) - tail_size;
		v3 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16 = (int16_t)(v3 >> 1) ^ -(int16_t)(v3 & 1);

	// unpack .u32 uint32
	word_t v4 = word0 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word0) == 0) {
		int tail_size = __builtin_ctz(v4 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v4 <<= (tail_size << 3) - tail_size;
		v4 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32 = v4;

	// unpack .i32 int32
	word_t v5 = word1 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word1) == 0) {
		int tail_size = __builtin_ctz(v5 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32 = (int32_t)(v5 >> 1) ^ -(int32_t)(v5 & 1);

	// unpack .u64 uint64
	word_t v6 = word1 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word1) == 0) {
		int tail_size = __builtin_ctz(v6 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64 = v6;

	// unpack .i64 int64
	word_t v7 = word1 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word1) == 0) {
		int tail_size = __builtin_ctz(v7 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->i64 = (int64_t)(v7 >> 1) ^ -(int64_t)(v7 & 1);

	// unpack .f32 float32
	uint64_t v8 = word1 >> 24;
	o->f32 = (union f32m){.u = v8}.f;

	// unpack .f64 float64
	uint64_t v9 = word1>>56 | word2<<(64-56);
	o->f64 = (union f64m){.u = v9}.f;

	// unpack .t timestamp
	uint64_t v10 = word2>>56 | word3<<(64-56);
	o->t.tv_sec = v10 >> 30;
	o->t.tv_nsec = (1<<30) - 1 & v10;

	// unpack .s text
	{
		size_t n = (size_t)(word3 >> 56) & 0xff;
		size_t offset = satsub(end, n);
		n = end - offset;
		end = offset;

		char* utf8 = NULL;
		if (n && fixed_size > 31) {
			utf8 = malloc(n);
			if (__builtin_expect(utf8 == NULL, 0)) {
				o->s.utf8 = NULL;
				o->s.len = 0;

				return 0;
			}
			memcpy(utf8, &base[offset], n);
		}

		o->s.utf8 = utf8;
		o->s.len = n;
	}

	// unpack .b bool
	o->_flags = word4 >> 0 & 0xff;

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 33, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_base_types){ 0 };
		return 0;
	case 3:
		o->u8 = 0;
	case 4:
		o->i8 = 0;
	case 5:
		o->u16 = 0;
	case 6:
		o->i16 = 0;
	case 7:
		o->u32 = 0;
	case 8:
		o->i32 = 0;
	case 9:
		o->u64 = 0;
	case 10:
		o->i64 = 0;
	case 11:
		o->f32 = 0;
	case 15:
		o->f64 = 0;
	case 23:
		o->t.tv_sec = 0;
		o->t.tv_nsec = 0;
	case 31:
		// checked inline allready
	case 32:
		o->_flags &= (1 << 0) - 1;
	}

	return size;
}

size_t
seal_array_types_marshal(const struct seal_array_types* o, void* start) {
	word_t word0 = 61 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 61;

	// pack .u8n2 uint8
	word0 |= (word_t)o->u8n2[0] << 24;
	word0 |= (word_t)o->u8n2[1] << 32;

	// pack .i8n2 int8
	word0 |= (word_t)(uint8_t)o->i8n2[0] << 40;
	word0 |= (word_t)(uint8_t)o->i8n2[1] << 48;

	// pack .u16n2 uint32
	word_t v4 = o->u16n2[0];
	if (v4 < 0x80) {
		v4 = v4<<1 | 1;
	} else {
		memcpy(p, &v4, 8);
		int bit_count = 64 - __builtin_clzll(v4);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 = v4 >> ((tail_size * 8) - 1) | 1;
		v4 = v4 << tail_size & 0xff;
	}
	word0 |= v4 << 56;
	word_t v5 = o->u16n2[1];
	if (v5 < 0x80) {
		v5 = v5<<1 | 1;
	} else {
		memcpy(p, &v5, 8);
		int bit_count = 64 - __builtin_clzll(v5);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 = v5 >> ((tail_size * 8) - 1) | 1;
		v5 = v5 << tail_size & 0xff;
	}
	word_t word1 = v5;

	// pack .i16n2 int32
	word_t v6 = (uint32_t)(o->i16n2[0] >> 31) ^ (uint32_t)(o->i16n2[0] << 1);
	if (v6 < 0x80) {
		v6 = v6<<1 | 1;
	} else {
		memcpy(p, &v6, 8);
		int bit_count = 64 - __builtin_clzll(v6);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 = v6 >> ((tail_size * 8) - 1) | 1;
		v6 = v6 << tail_size & 0xff;
	}
	word1 |= v6 << 8;
	word_t v7 = (uint32_t)(o->i16n2[1] >> 31) ^ (uint32_t)(o->i16n2[1] << 1);
	if (v7 < 0x80) {
		v7 = v7<<1 | 1;
	} else {
		memcpy(p, &v7, 8);
		int bit_count = 64 - __builtin_clzll(v7);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 = v7 >> ((tail_size * 8) - 1) | 1;
		v7 = v7 << tail_size & 0xff;
	}
	word1 |= v7 << 16;

	// pack .u32n2 uint16
	word_t v8 = o->u32n2[0];
	if (v8 < 0x80) {
		v8 = v8<<1 | 1;
	} else {
		memcpy(p, &v8, 8);
		int bit_count = 64 - __builtin_clzll(v8);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v8 = v8 >> ((tail_size * 8) - 1) | 1;
		v8 = v8 << tail_size & 0xff;
	}
	word1 |= v8 << 24;
	word_t v9 = o->u32n2[1];
	if (v9 < 0x80) {
		v9 = v9<<1 | 1;
	} else {
		memcpy(p, &v9, 8);
		int bit_count = 64 - __builtin_clzll(v9);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v9 = v9 >> ((tail_size * 8) - 1) | 1;
		v9 = v9 << tail_size & 0xff;
	}
	word1 |= v9 << 32;

	// pack .i32n2 int16
	word_t v10 = (uint16_t)(o->i32n2[0] >> 15) ^ (uint16_t)(o->i32n2[0] << 1);
	if (v10 < 0x80) {
		v10 = v10<<1 | 1;
	} else {
		memcpy(p, &v10, 8);
		int bit_count = 64 - __builtin_clzll(v10);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v10 = v10 >> ((tail_size * 8) - 1) | 1;
		v10 = v10 << tail_size & 0xff;
	}
	word1 |= v10 << 40;
	word_t v11 = (uint16_t)(o->i32n2[1] >> 15) ^ (uint16_t)(o->i32n2[1] << 1);
	if (v11 < 0x80) {
		v11 = v11<<1 | 1;
	} else {
		memcpy(p, &v11, 8);
		int bit_count = 64 - __builtin_clzll(v11);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v11 = v11 >> ((tail_size * 8) - 1) | 1;
		v11 = v11 << tail_size & 0xff;
	}
	word1 |= v11 << 48;

	// pack .u64n2 uint64
	word_t v12 = o->u64n2[0];
	if (v12 < 0x80) {
		v12 = v12<<1 | 1;
	} else {
		memcpy(p, &v12, 8);
		int bit_count = 64 - __builtin_clzll(v12);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v12 = v12 >> ((tail_size * 8) - 1) | 1;
		v12 = v12 << tail_size & 0xff;
	}
	word1 |= v12 << 56;
	word_t v13 = o->u64n2[1];
	if (v13 < 0x80) {
		v13 = v13<<1 | 1;
	} else {
		memcpy(p, &v13, 8);
		int bit_count = 64 - __builtin_clzll(v13);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v13 = v13 >> ((tail_size * 8) - 1) | 1;
		v13 = v13 << tail_size & 0xff;
	}
	word_t word2 = v13;

	// pack .i64n2 int64
	word_t v14 = (o->i64n2[0] >> 63) ^ (o->i64n2[0] << 1);
	if (v14 < 0x80) {
		v14 = v14<<1 | 1;
	} else {
		memcpy(p, &v14, 8);
		int bit_count = 64 - __builtin_clzll(v14);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v14 = v14 >> ((tail_size * 8) - 1) | 1;
		v14 = v14 << tail_size & 0xff;
	}
	word2 |= v14 << 8;
	word_t v15 = (o->i64n2[1] >> 63) ^ (o->i64n2[1] << 1);
	if (v15 < 0x80) {
		v15 = v15<<1 | 1;
	} else {
		memcpy(p, &v15, 8);
		int bit_count = 64 - __builtin_clzll(v15);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v15 = v15 >> ((tail_size * 8) - 1) | 1;
		v15 = v15 << tail_size & 0xff;
	}
	word2 |= v15 << 16;

	// pack .f32n2 float32
	word_t v16 = (union f32m){.f = o->f32n2[0]}.u;
	word2 |= v16 << 24;
	word_t v17 = (union f32m){.f = o->f32n2[1]}.u;
	word2 |= v17 << 56;
	uint64_t word3 = v17 >> (64-56);

	// pack .f64n2 float64
	word_t v18 = (union f64m){.f = o->f64n2[0]}.u;
	word3 |= v18 << 24;
	uint64_t word4 = v18 >> (64-24);
	word_t v19 = (union f64m){.f = o->f64n2[1]}.u;
	word4 |= v19 << 24;
	uint64_t word5 = v19 >> (64-24);

	// pack .tn2 timestamp
	word_t v20 = o->tn2[0].tv_sec;
	v20 <<= 30;
	v20 |= o->tn2[0].tv_nsec;
	word5 |= v20 << 24;
	uint64_t word6 = v20 >> (64-24);
	word_t v21 = o->tn2[1].tv_sec;
	v21 <<= 30;
	v21 |= o->tn2[1].tv_nsec;
	word6 |= v21 << 24;
	uint64_t word7 = v21 >> (64-24);

	// pack .sn2 text
	if (o->sn2[0].len > 255) return 0;
	word7 |= (word_t)o->sn2[0].len << 24;
	if (o->sn2[1].len > 255) return 0;
	word7 |= (word_t)o->sn2[1].len << 32;

	// copy payloads
	const uint8_t *max = p + 0xfff;
	{
		size_t z = o->sn2[0].len;
		if (max - p < z) return 0;
		memcpy(p, o->sn2[0].utf8, z);
		p += z;
	}
	{
		size_t z = o->sn2[1].len;
		if (max - p < z) return 0;
		memcpy(p, o->sn2[1].utf8, z);
		p += z;
	}

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 8);
	memcpy((uint8_t *)start + (3 * 8), &word3, 8);
	memcpy((uint8_t *)start + (4 * 8), &word4, 8);
	memcpy((uint8_t *)start + (5 * 8), &word5, 8);
	memcpy((uint8_t *)start + (6 * 8), &word6, 8);
	memcpy((uint8_t *)start + (7 * 8), &word7, 5);

	return size;
}

size_t
seal_array_types_unmarshal(struct seal_array_types* o, const void* start, void* (*malloc)(size_t)) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 8);
	word_t word1;
	memcpy(&word1, &base[1 * 8], 8);
	word_t word2;
	memcpy(&word2, &base[2 * 8], 8);
	word_t word3;
	memcpy(&word3, &base[3 * 8], 8);
	word_t word4;
	memcpy(&word4, &base[4 * 8], 8);
	word_t word5;
	memcpy(&word5, &base[5 * 8], 8);
	word_t word6;
	memcpy(&word6, &base[6 * 8], 8);
	word_t word7;
	memcpy(&word7, &base[7 * 8], 5);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_array_types){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .u8n2 uint8
	o->u8n2[0] = word0 >> 24;
	o->u8n2[1] = word0 >> 32;

	// unpack .i8n2 int8
	o->i8n2[0] = word0 >> 40;
	o->i8n2[1] = word0 >> 48;

	// unpack .u16n2 uint32
	word_t v4 = word0 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word0) == 0) {
		int tail_size = __builtin_ctz(v4 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v4 <<= (tail_size << 3) - tail_size;
		v4 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16n2[0] = v4;
	word_t v5 = word1 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word1) == 0) {
		int tail_size = __builtin_ctz(v5 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v5 <<= (tail_size << 3) - tail_size;
		v5 |= tail & COLFER_MASKS[tail_size];
	}
	o->u16n2[1] = v5;

	// unpack .i16n2 int32
	word_t v6 = word1 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word1) == 0) {
		int tail_size = __builtin_ctz(v6 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v6 <<= (tail_size << 3) - tail_size;
		v6 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16n2[0] = (int32_t)(v6 >> 1) ^ -(int32_t)(v6 & 1);
	word_t v7 = word1 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word1) == 0) {
		int tail_size = __builtin_ctz(v7 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v7 <<= (tail_size << 3) - tail_size;
		v7 |= tail & COLFER_MASKS[tail_size];
	}
	o->i16n2[1] = (int32_t)(v7 >> 1) ^ -(int32_t)(v7 & 1);

	// unpack .u32n2 uint16
	word_t v8 = word1 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word1) == 0) {
		int tail_size = __builtin_ctz(v8 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v8 <<= (tail_size << 3) - tail_size;
		v8 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32n2[0] = v8;
	word_t v9 = word1 >> (32 + 1) & 0x7f;
	if (((uint64_t)1 << 32 & word1) == 0) {
		int tail_size = __builtin_ctz(v9 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v9 <<= (tail_size << 3) - tail_size;
		v9 |= tail & COLFER_MASKS[tail_size];
	}
	o->u32n2[1] = v9;

	// unpack .i32n2 int16
	word_t v10 = word1 >> (40 + 1) & 0x7f;
	if (((uint64_t)1 << 40 & word1) == 0) {
		int tail_size = __builtin_ctz(v10 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v10 <<= (tail_size << 3) - tail_size;
		v10 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32n2[0] = (int16_t)(v10 >> 1) ^ -(int16_t)(v10 & 1);
	word_t v11 = word1 >> (48 + 1) & 0x7f;
	if (((uint64_t)1 << 48 & word1) == 0) {
		int tail_size = __builtin_ctz(v11 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v11 <<= (tail_size << 3) - tail_size;
		v11 |= tail & COLFER_MASKS[tail_size];
	}
	o->i32n2[1] = (int16_t)(v11 >> 1) ^ -(int16_t)(v11 & 1);

	// unpack .u64n2 uint64
	word_t v12 = word1 >> (56 + 1) & 0x7f;
	if (((uint64_t)1 << 56 & word1) == 0) {
		int tail_size = __builtin_ctz(v12 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v12 <<= (tail_size << 3) - tail_size;
		v12 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64n2[0] = v12;
	word_t v13 = word2 >> (0 + 1) & 0x7f;
	if (((uint64_t)1 << 0 & word2) == 0) {
		int tail_size = __builtin_ctz(v13 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v13 <<= (tail_size << 3) - tail_size;
		v13 |= tail & COLFER_MASKS[tail_size];
	}
	o->u64n2[1] = v13;

	// unpack .i64n2 int64
	word_t v14 = word2 >> (8 + 1) & 0x7f;
	if (((uint64_t)1 << 8 & word2) == 0) {
		int tail_size = __builtin_ctz(v14 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v14 <<= (tail_size << 3) - tail_size;
		v14 |= tail & COLFER_MASKS[tail_size];
	}
	o->i64n2[0] = (int64_t)(v14 >> 1) ^ -(int64_t)(v14 & 1);
	word_t v15 = word2 >> (16 + 1) & 0x7f;
	if (((uint64_t)1 << 16 & word2) == 0) {
		int tail_size = __builtin_ctz(v15 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v15 <<= (tail_size << 3) - tail_size;
		v15 |= tail & COLFER_MASKS[tail_size];
	}
	o->i64n2[1] = (int64_t)(v15 >> 1) ^ -(int64_t)(v15 & 1);

	// unpack .f32n2 float32
	uint64_t v16 = word2 >> 24;
	o->f32n2[0] = (union f32m){.u = v16}.f;
	uint64_t v17 = word2>>56 | word3<<(64-56);
	o->f32n2[1] = (union f32m){.u = v17}.f;

	// unpack .f64n2 float64
	uint64_t v18 = word3>>24 | word4<<(64-24);
	o->f64n2[0] = (union f64m){.u = v18}.f;
	uint64_t v19 = word4>>24 | word5<<(64-24);
	o->f64n2[1] = (union f64m){.u = v19}.f;

	// unpack .tn2 timestamp
	uint64_t v20 = word5>>24 | word6<<(64-24);
	o->tn2[0].tv_sec = v20 >> 30;
	o->tn2[0].tv_nsec = (1<<30) - 1 & v20;
	uint64_t v21 = word6>>24 | word7<<(64-24);
	o->tn2[1].tv_sec = v21 >> 30;
	o->tn2[1].tv_nsec = (1<<30) - 1 & v21;

	// unpack .sn2 text
	{
		size_t n = (size_t)(word7 >> 24) & 0xff;
		size_t offset = satsub(end, n);
		n = end - offset;
		end = offset;

		char* utf8 = NULL;
		if (n && fixed_size > 59) {
			utf8 = malloc(n);
			if (__builtin_expect(utf8 == NULL, 0)) {
				for (int i = 0; i < 2; i++) {
					o->sn2[0].utf8 = NULL;
					o->sn2[0].len = 0;
				}

				return 0;
			}
			memcpy(utf8, &base[offset], n);
		}

		o->sn2[0].utf8 = utf8;
		o->sn2[0].len = n;
	}
	{
		size_t n = (size_t)(word7 >> 32) & 0xff;
		size_t offset = satsub(end, n);
		n = end - offset;
		end = offset;

		char* utf8 = NULL;
		if (n && fixed_size > 60) {
			utf8 = malloc(n);
			if (__builtin_expect(utf8 == NULL, 0)) {
				for (int i = 1; i < 2; i++) {
					o->sn2[1].utf8 = NULL;
					o->sn2[1].len = 0;
				}

				o->sn2[0].utf8 = NULL;
				o->sn2[0].len = 0;
				o->sn2[1].utf8 = NULL;
				o->sn2[1].len = 0;
				return 0;
			}
			memcpy(utf8, &base[offset], n);
		}

		o->sn2[1].utf8 = utf8;
		o->sn2[1].len = n;
	}

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 61, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_array_types){ 0 };
		return 0;
	case 3:
		o->u8n2[0] = 0;
		o->u8n2[1] = 0;
	case 5:
		o->i8n2[0] = 0;
		o->i8n2[1] = 0;
	case 7:
		o->u16n2[0] = 0;
		o->u16n2[1] = 0;
	case 9:
		o->i16n2[0] = 0;
		o->i16n2[1] = 0;
	case 11:
		o->u32n2[0] = 0;
		o->u32n2[1] = 0;
	case 13:
		o->i32n2[0] = 0;
		o->i32n2[1] = 0;
	case 15:
		o->u64n2[0] = 0;
		o->u64n2[1] = 0;
	case 17:
		o->i64n2[0] = 0;
		o->i64n2[1] = 0;
	case 19:
		o->f32n2[0] = 0;
		o->f32n2[1] = 0;
	case 27:
		o->f64n2[0] = 0;
		o->f64n2[1] = 0;
	case 43:
		o->tn2[0].tv_sec = 0;
		o->tn2[0].tv_nsec = 0;
		o->tn2[1].tv_sec = 0;
		o->tn2[1].tv_nsec = 0;
	case 59:
		// checked inline allready
	}

	return size;
}

size_t
seal_list_types_marshal(const struct seal_list_types* o, void* start) {
	word_t word0 = 11 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 11;

	// pack .a8l []opaque8
	word_t v0 = o->a8l.len;
	if (v0 < 0x80) {
		v0 = v0<<1 | 1;
	} else {
		memcpy(p, &v0, 8);
		int bit_count = 64 - __builtin_clzll(v0);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 = v0 >> ((tail_size * 8) - 1) | 1;
		v0 = v0 << tail_size & 0xff;
	}
	word0 |= v0 << 24;

	// pack .a16l []opaque16
	word_t v1 = o->a16l.len;
	if (v1 < 0x80) {
		v1 = v1<<1 | 1;
	} else {
		memcpy(p, &v1, 8);
		int bit_count = 64 - __builtin_clzll(v1);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v1 = v1 >> ((tail_size * 8) - 1) | 1;
		v1 = v1 << tail_size & 0xff;
	}
	word0 |= v1 << 32;

	// pack .a32l []opaque32
	word_t v2 = o->a32l.len;
	if (v2 < 0x80) {
		v2 = v2<<1 | 1;
	} else {
		memcpy(p, &v2, 8);
		int bit_count = 64 - __builtin_clzll(v2);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v2 = v2 >> ((tail_size * 8) - 1) | 1;
		v2 = v2 << tail_size & 0xff;
	}
	word0 |= v2 << 40;

	// pack .a64l []opaque64
	word_t v3 = o->a64l.len;
	if (v3 < 0x80) {
		v3 = v3<<1 | 1;
	} else {
		memcpy(p, &v3, 8);
		int bit_count = 64 - __builtin_clzll(v3);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v3 = v3 >> ((tail_size * 8) - 1) | 1;
		v3 = v3 << tail_size & 0xff;
	}
	word0 |= v3 << 48;

	// pack .f32l []float32
	word_t v4 = o->f32l.len;
	if (v4 < 0x80) {
		v4 = v4<<1 | 1;
	} else {
		memcpy(p, &v4, 8);
		int bit_count = 64 - __builtin_clzll(v4);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v4 = v4 >> ((tail_size * 8) - 1) | 1;
		v4 = v4 << tail_size & 0xff;
	}
	word0 |= v4 << 56;

	// pack .f64l []float64
	word_t v5 = o->f64l.len;
	if (v5 < 0x80) {
		v5 = v5<<1 | 1;
	} else {
		memcpy(p, &v5, 8);
		int bit_count = 64 - __builtin_clzll(v5);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v5 = v5 >> ((tail_size * 8) - 1) | 1;
		v5 = v5 << tail_size & 0xff;
	}
	word_t word1 = v5;

	// pack .tl []timestamp
	word_t v6 = o->tl.len;
	if (v6 < 0x80) {
		v6 = v6<<1 | 1;
	} else {
		memcpy(p, &v6, 8);
		int bit_count = 64 - __builtin_clzll(v6);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v6 = v6 >> ((tail_size * 8) - 1) | 1;
		v6 = v6 << tail_size & 0xff;
	}
	word1 |= v6 << 8;

	// pack .sl []text
	word_t v7 = o->sl.len;
	if (v7 < 0x80) {
		v7 = v7<<1 | 1;
	} else {
		memcpy(p, &v7, 8);
		int bit_count = 64 - __builtin_clzll(v7);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v7 = v7 >> ((tail_size * 8) - 1) | 1;
		v7 = v7 << tail_size & 0xff;
	}
	word1 |= v7 << 16;

	// copy payloads
	const uint8_t *max = p + 0xfff;
	if (o->sl.len) {
		size_t n = o->sl.len;
		if (max - p < n) return 0;
		size_t sum = 0;
		for (size_t i = 0; i < n; i++) {
			size_t z = o->sl.list[i].len;
			if (z > 255) return 0;
			p[i] = z;
			sum += z;
		}
		p += n;
		if (max - p < sum) return 0;
		while (n--) {
			size_t z = o->sl.list[n].len;
			memcpy(p, o->sl.list[n].utf8, z);
			p += z;
		}
	}
	{
		size_t i = o->tl.len;
		if (max - p < i * 8) return 0;
		while (i--) {
			word_t v = (word_t)o->tl.list[i].tv_sec << 30;
			v |= o->tl.list[i].tv_nsec;
			memcpy(p, &v, 8);
			p += 8;
		}
	}
	{
		size_t size = o->f64l.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->f64l.list, size);
		p += size;
	}
	{
		size_t size = o->f32l.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->f32l.list, size);
		p += size;
	}
	{
		size_t size = o->a64l.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->a64l.list, size);
		p += size;
	}
	{
		size_t size = o->a32l.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->a32l.list, size);
		p += size;
	}
	{
		size_t size = o->a8l.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->a8l.list, size);
		p += size;
	}

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 3);

	return size;
}

size_t
seal_list_types_unmarshal(struct seal_list_types* o, const void* start, void* (*malloc)(size_t)) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 8);
	word_t word1;
	memcpy(&word1, &base[1 * 8], 3);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_list_types){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .a8l []opaque8
	{
		size_t n = (size_t)(word0 >> 24) & 0xff;
		size_t offset = satsub(end, n * sizeof(uint8_t));
		n = (end - offset) / sizeof(uint8_t);
		end = offset;

		typeof(o->a8l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->a8l.list = NULL;
				o->a8l.len = 0;

				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->a8l.list = list;
		o->a8l.len = n;
	}

	// unpack .a16l []opaque16
	{
		size_t n = (size_t)(word0 >> 32) & 0xff;
		size_t offset = satsub(end, n * sizeof(uint16_t));
		n = (end - offset) / sizeof(uint16_t);
		end = offset;

		typeof(o->a16l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->a16l.list = NULL;
				o->a16l.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->a16l.list = list;
		o->a16l.len = n;
	}

	// unpack .a32l []opaque32
	{
		size_t n = (size_t)(word0 >> 40) & 0xff;
		size_t offset = satsub(end, n * sizeof(uint32_t));
		n = (end - offset) / sizeof(uint32_t);
		end = offset;

		typeof(o->a32l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->a32l.list = NULL;
				o->a32l.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->a32l.list = list;
		o->a32l.len = n;
	}

	// unpack .a64l []opaque64
	{
		size_t n = (size_t)(word0 >> 48) & 0xff;
		size_t offset = satsub(end, n * sizeof(uint64_t));
		n = (end - offset) / sizeof(uint64_t);
		end = offset;

		typeof(o->a64l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->a64l.list = NULL;
				o->a64l.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->a64l.list = list;
		o->a64l.len = n;
	}

	// unpack .f32l []float32
	{
		size_t n = (size_t)(word0 >> 56) & 0xff;
		size_t offset = satsub(end, n * sizeof(float));
		n = (end - offset) / sizeof(float);
		end = offset;

		typeof(o->f32l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->f32l.list = NULL;
				o->f32l.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				o->a64l.list = NULL;
				o->a64l.len = 0;
				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->f32l.list = list;
		o->f32l.len = n;
	}

	// unpack .f64l []float64
	{
		size_t n = (size_t)(word1 >> 0) & 0xff;
		size_t offset = satsub(end, n * sizeof(double));
		n = (end - offset) / sizeof(double);
		end = offset;

		typeof(o->f64l.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->f64l.list = NULL;
				o->f64l.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				o->a64l.list = NULL;
				o->a64l.len = 0;
				o->f32l.list = NULL;
				o->f32l.len = 0;
				return 0;
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->f64l.list = list;
		o->f64l.len = n;
	}

	// unpack .tl []timestamp
	{
		size_t n = (size_t)(word1 >> 8) & 0xff;
		size_t offset = satsub(end, n * 8);
		n = (end - offset) / 8;
		end = offset;

		typeof(o->tl.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->tl.list = NULL;
				o->tl.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				o->a64l.list = NULL;
				o->a64l.len = 0;
				o->f32l.list = NULL;
				o->f32l.len = 0;
				o->f64l.list = NULL;
				o->f64l.len = 0;
				return 0;
			}
			const uint64_t *view = (const uint64_t *)&base[offset];
			for (size_t i = 0; i < n; i++) {
				list[i].tv_sec = view[i] >> 30;
				list[i].tv_nsec = view[i] & (1<<30) - 1;
			}
		}

		o->tl.list = list;
		o->tl.len = n;
	}

	// unpack .sl []text
	{
		size_t n = (size_t)(word1 >> 16) & 0xff;
		size_t size_table_offset = satsub(end, n);
		n = end - size_table_offset;
		end = size_table_offset;

		typeof(o->sl.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->sl.list = NULL;
				o->sl.len = 0;

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				o->a64l.list = NULL;
				o->a64l.len = 0;
				o->f32l.list = NULL;
				o->f32l.len = 0;
				o->f64l.list = NULL;
				o->f64l.len = 0;
				o->tl.list = NULL;
				o->tl.len = 0;
				return 0;
			}

			for (size_t i = 0; i < n; i++) {
				size_t offset = satsub(end, base[size_table_offset + n]);
				size_t len = end - offset;
				end = offset;

				if (!len) {
					list[i].utf8 = NULL;
					list[i].len = 0;
					continue;
				}

				char* utf8 = malloc(len);
				if (__builtin_expect(utf8 != NULL, 1)) {
					memcpy(utf8, &base[offset], len);
					list[i].utf8 = utf8;
					list[i].len = len;
					continue;
				}

				// malloc failed
				do {
					list[i].utf8 = NULL;
					list[i].len = 0;
				} while (++i > n);

				o->a8l.list = NULL;
				o->a8l.len = 0;
				o->a16l.list = NULL;
				o->a16l.len = 0;
				o->a32l.list = NULL;
				o->a32l.len = 0;
				o->a64l.list = NULL;
				o->a64l.len = 0;
				o->f32l.list = NULL;
				o->f32l.len = 0;
				o->f64l.list = NULL;
				o->f64l.len = 0;
				o->tl.list = NULL;
				o->tl.len = 0;
				return 0;
			}
		}

		o->sl.list = list;
		o->sl.len = n;
	}

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 11, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_list_types){ 0 };
		return 0;
	case 3:
		// checked inline allready
	case 4:
		// checked inline allready
	case 5:
		// checked inline allready
	case 6:
		// checked inline allready
	case 7:
		// checked inline allready
	case 8:
		// checked inline allready
	case 9:
		// checked inline allready
	case 10:
		// checked inline allready
	}

	return size;
}

size_t
seal_opaque_types_marshal(const struct seal_opaque_types* o, void* start) {
	word_t word0 = 48 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 48;

	// pack .a8 opaque8
	word0 |= (word_t)o->a8 << 24;

	// pack .a8n2 opaque8
	word0 |= (word_t)o->a8n2[0] << 32;
	word0 |= (word_t)o->a8n2[1] << 40;

	// pack .a16 opaque16
	word_t v3 = o->a16;
	word0 |= v3 << 48;

	// pack .a16n2 opaque16
	word_t v4 = o->a16n2[0];
	uint64_t word1 = v4;
	word_t v5 = o->a16n2[1];
	word1 |= v5 << 16;

	// pack .a32 opaque32
	word_t v6 = o->a32;
	word1 |= v6 << 32;

	// pack .a32n2 opaque32
	word_t v7 = o->a32n2[0];
	uint64_t word2 = v7;
	word_t v8 = o->a32n2[1];
	word2 |= v8 << 32;

	// pack .a64 opaque64
	word_t v9 = o->a64;
	uint64_t word3 = v9;

	// pack .a64n2 opaque64
	word_t v10 = o->a64n2[0];
	uint64_t word4 = v10;
	word_t v11 = o->a64n2[1];
	uint64_t word5 = v11;

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 8);
	memcpy((uint8_t *)start + (2 * 8), &word2, 8);
	memcpy((uint8_t *)start + (3 * 8), &word3, 8);
	memcpy((uint8_t *)start + (4 * 8), &word4, 8);
	memcpy((uint8_t *)start + (5 * 8), &word5, 8);

	return size;
}

size_t
seal_opaque_types_unmarshal(struct seal_opaque_types* o, const void* start) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 8);
	word_t word1;
	memcpy(&word1, &base[1 * 8], 8);
	word_t word2;
	memcpy(&word2, &base[2 * 8], 8);
	word_t word3;
	memcpy(&word3, &base[3 * 8], 8);
	word_t word4;
	memcpy(&word4, &base[4 * 8], 8);
	word_t word5;
	memcpy(&word5, &base[5 * 8], 8);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_opaque_types){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .a8 opaque8
	o->a8 = word0 >> 24;

	// unpack .a8n2 opaque8
	o->a8n2[0] = word0 >> 32;
	o->a8n2[1] = word0 >> 40;

	// unpack .a16 opaque16
	uint64_t v3 = word0 >> 48;
	o->a16 = v3;

	// unpack .a16n2 opaque16
	uint64_t v4 = word1;
	o->a16n2[0] = v4;
	uint64_t v5 = word1 >> 16;
	o->a16n2[1] = v5;

	// unpack .a32 opaque32
	uint64_t v6 = word1 >> 32;
	o->a32 = v6;

	// unpack .a32n2 opaque32
	uint64_t v7 = word2;
	o->a32n2[0] = v7;
	uint64_t v8 = word2 >> 32;
	o->a32n2[1] = v8;

	// unpack .a64 opaque64
	uint64_t v9 = word3;
	o->a64 = v9;

	// unpack .a64n2 opaque64
	uint64_t v10 = word4;
	o->a64n2[0] = v10;
	uint64_t v11 = word5;
	o->a64n2[1] = v11;

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 48, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_opaque_types){ 0 };
		return 0;
	case 3:
		o->a8 = 0;
	case 4:
		o->a8n2[0] = 0;
		o->a8n2[1] = 0;
	case 6:
		o->a16 = 0;
	case 8:
		o->a16n2[0] = 0;
		o->a16n2[1] = 0;
	case 12:
		o->a32 = 0;
	case 16:
		o->a32n2[0] = 0;
		o->a32n2[1] = 0;
	case 24:
		o->a64 = 0;
	case 32:
		o->a64n2[0] = 0;
		o->a64n2[1] = 0;
	}

	return size;
}

size_t
seal_many_flags_marshal(const struct seal_many_flags* o, void* start) {
	word_t word0 = 11 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 11;

	// pack .b1 bool
	word0 |= (word_t)o->_flags<<(24-0) & (word_t)0xff<<24;

	// pack .b2 bool

	// pack .b3 bool

	// pack .b4 bool

	// pack .b5 bool

	// pack .b6 bool

	// pack .b7 bool

	// pack .b8 bool

	// pack .b9 bool
	word0 |= (word_t)o->_flags<<(32-8) & (word_t)0xff<<32;

	// pack .b10 bool

	// pack .shift opaque32
	word_t v10 = o->shift;
	word0 |= v10 << 40;
	uint64_t word1 = v10 >> (64-40);

	// pack .b11 bool

	// pack .b12 bool

	// pack .b13 bool

	// pack .b14 bool

	// pack .b15 bool

	// pack .b16 bool

	// pack .b17 bool
	word1 |= (word_t)o->_flags>>(16-8) & (word_t)0xff<<8;

	// pack .end opaque8
	word1 |= (word_t)o->end << 16;

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 8);
	memcpy((uint8_t *)start + (1 * 8), &word1, 3);

	return size;
}

size_t
seal_many_flags_unmarshal(struct seal_many_flags* o, const void* start) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 8);
	word_t word1;
	memcpy(&word1, &base[1 * 8], 3);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_many_flags){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .b1 bool
	o->_flags = word0 >> 24 & 0xff;

	// unpack .b2 bool
	// travels for free

	// unpack .b3 bool
	// travels for free

	// unpack .b4 bool
	// travels for free

	// unpack .b5 bool
	// travels for free

	// unpack .b6 bool
	// travels for free

	// unpack .b7 bool
	// travels for free

	// unpack .b8 bool
	// travels for free

	// unpack .b9 bool
	o->_flags = word0 >> (32-8) & (0xff<<8);

	// unpack .b10 bool
	// travels for free

	// unpack .shift opaque32
	uint64_t v10 = word0>>40 | word1<<(64-40);
	o->shift = v10;

	// unpack .b11 bool
	// travels for free

	// unpack .b12 bool
	// travels for free

	// unpack .b13 bool
	// travels for free

	// unpack .b14 bool
	// travels for free

	// unpack .b15 bool
	// travels for free

	// unpack .b16 bool
	// travels for free

	// unpack .b17 bool
	o->_flags = word1 << (16-8) & (0xff<<16);

	// unpack .end opaque8
	o->end = word1 >> 16;

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 11, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_many_flags){ 0 };
		return 0;
	case 3:
		o->_flags &= (1 << 0) - 1;
	case 4:
		o->_flags &= (1 << 8) - 1;
	case 5:
		o->shift = 0;
	case 9:
		o->_flags &= (1 << 16) - 1;
	case 10:
		o->end = 0;
	}

	return size;
}

size_t
seal_nested_types_marshal(const struct seal_nested_types* o, void* start) {
	word_t word0 = 7 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 7;

	// pack .list []BaseTypes
	word_t v0 = o->list.len;
	if (v0 < 0x80) {
		v0 = v0<<1 | 1;
	} else {
		memcpy(p, &v0, 8);
		int bit_count = 64 - __builtin_clzll(v0);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 = v0 >> ((tail_size * 8) - 1) | 1;
		v0 = v0 << tail_size & 0xff;
	}
	word0 |= v0 << 24;

	// copy payloads
	const uint8_t *max = p + 0xfff;

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 7);

	return size;
}

size_t
seal_nested_types_unmarshal(struct seal_nested_types* o, const void* start, void* (*malloc)(size_t)) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 7);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_nested_types){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .list []BaseTypes

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 7, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_nested_types){ 0 };
		return 0;
	case 3:
		// checked inline allready
	}

	return size;
}

size_t
seal_dromedary_case_marshal(const struct seal_dromedary_case* o, void* start) {
	word_t word0 = 5 << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + 5;

	// pack .PascalCase int32
	word_t v0 = (uint32_t)(o->pascal_case >> 31) ^ (uint32_t)(o->pascal_case << 1);
	if (v0 < 0x80) {
		v0 = v0<<1 | 1;
	} else {
		memcpy(p, &v0, 8);
		int bit_count = 64 - __builtin_clzll(v0);
		int tail_size = (((bit_count - 1) >> 3) + bit_count) >> 3;
		p += tail_size;
		v0 = v0 >> ((tail_size * 8) - 1) | 1;
		v0 = v0 << tail_size & 0xff;
	}
	word0 |= v0 << 24;

	// pack .with_snake opaque8
	word0 |= (word_t)o->with_snake << 32;

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;
	memcpy((uint8_t *)start + (0 * 8), &word0, 5);

	return size;
}

size_t
seal_dromedary_case_unmarshal(struct seal_dromedary_case* o, const void* start) {
	const uint8_t* base = (const uint8_t*)start; // address octets
	word_t word0;
	memcpy(&word0, &base[0 * 8], 5);

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct seal_dromedary_case){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

	// unpack .PascalCase int32
	word_t v0 = word0 >> (24 + 1) & 0x7f;
	if (((uint64_t)1 << 24 & word0) == 0) {
		int tail_size = __builtin_ctz(v0 | 0x80) + 1;
		word_t tail;
		memcpy(&tail, p, 8);
		p += tail_size;
		v0 <<= (tail_size << 3) - tail_size;
		v0 |= tail & COLFER_MASKS[tail_size];
	}
	o->pascal_case = (int32_t)(v0 >> 1) ^ -(int32_t)(v0 & 1);

	// unpack .with_snake opaque8
	o->with_snake = word0 >> 32;

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < 5, 0)) switch (fixed_size) {
	default:
		*o = (const struct seal_dromedary_case){ 0 };
		return 0;
	case 3:
		o->pascal_case = 0;
	case 4:
		o->with_snake = 0;
	}

	return size;
}
