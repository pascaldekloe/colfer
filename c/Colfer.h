// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file seal.colf for package seal.

#include <stdint.h>
#include <stdlib.h>
#include <time.h>

#ifdef __cplusplus
extern "C" {
#endif

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_BASE_TYPES_FRAME_CAP 4096
// Encodings with the compact profile limit each text in byte size.
#define SEAL_BASE_TYPES_UTF8_CAP 255

// Encodings from this version of the data structure are limited in size by the
// profile capacity.
#define SEAL_BASE_TYPES_MARSHAL_MAX SEAL_BASE_TYPES_FRAME_CAP

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_BASE_TYPES_MARSHAL_BUF (SEAL_BASE_TYPES_MARSHAL_MAX+7 & ~7)

// BaseTypes contains each data type supported by Colfer, including a single-line comment.
struct seal_base_types {
	// Test 8 bit–unsigned integers.
	uint8_t u8;

	// Test 8 bit–signed integers.
	int8_t i8;

	// Test 16 bit–unsigned integers.
	uint16_t u16;

	// Test 16 bit–signed integers.
	int16_t i16;

	// Test 32 bit–unsigned integers.
	uint32_t u32;

	// Test 32 bit–signed integers.
	int32_t i32;

	// Test 64 bit–unsigned integers.
	uint64_t u64;

	// Test 64 bit–signed integers.
	int64_t i64;

	// Tests single precision–floating points.
	float f32;

	// Tests double precision–floating points.
	double f64;

	// Test timestamps (with nanosecond precision).
	struct timespec t;

	// Test Unicode strings of variable size.
	struct {
		const char* utf8;
		size_t len; // octet count
	} s;

	// Bit field for booleans defined as SEAL_BASE_TYPES_B_FLAG_*_FLAG.
	unsigned int _flags;
};

// Test binary flags.
#define SEAL_BASE_TYPES_B_FLAG (1 << 0)

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_BASE_TYPES_MARSHAL_BUF.
// The return is zero (0) on any of the following, exclusively.
//
//  • encoding exceeds SEAL_BASE_TYPES_FRAME_CAP
//  • a text exceeds SEAL_BASE_TYPES_TEXT_CAP
//  • a list exceeds SEAL_BASE_TYPES_LIST_CAP
//
size_t
seal_base_types_marshal(const struct seal_base_types* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_BASE_TYPES_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters. Malloc is not used on decoding errors.
// ENOMEM may leave fields unintialized
// Texts are allocated including null ('\0') terminator, even when empty.
// Caller owns the memory.
size_t
seal_base_types_unmarshal(struct seal_base_types* o, const void* start, void* (*malloc)(size_t));

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_ARRAY_TYPES_FRAME_CAP 4096
// Encodings with the compact profile limit each text in byte size.
#define SEAL_ARRAY_TYPES_UTF8_CAP 255

// Encodings from this version of the data structure are limited in size by the
// profile capacity.
#define SEAL_ARRAY_TYPES_MARSHAL_MAX SEAL_ARRAY_TYPES_FRAME_CAP

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_ARRAY_TYPES_MARSHAL_BUF (SEAL_ARRAY_TYPES_MARSHAL_MAX+7 & ~7)

// ArrayTypes contains all BaseTypes in array form, excluding bool(eans).
// 
// Comments span multiple lines as opposed to BaseTypes.
struct seal_array_types {
	// Two values for each field break word boundaries in encoding.
	// 
	// The minimium size of this data structure is 2 + header = 5.
	uint8_t u8n2[2];

	// empty line
	// 
	int8_t i8n2[2];

	// indent space only
	// 
	uint32_t u16n2[2];

	// blank space
	//  
	int32_t i16n2[2];

	// 	tab
	// 	without indent space
	uint16_t u32n2[2];

	int16_t i32n2[2];

	uint64_t u64n2[2];

	int64_t i64n2[2];

	// floating points
	float f32n2[2];

	double f64n2[2];

	// complex types
	struct timespec tn2[2];

	struct {
		const char* utf8;
		size_t len; // octet count
	} sn2[2];
};

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_ARRAY_TYPES_MARSHAL_BUF.
// The return is zero (0) on any of the following, exclusively.
//
//  • encoding exceeds SEAL_ARRAY_TYPES_FRAME_CAP
//  • a text exceeds SEAL_ARRAY_TYPES_TEXT_CAP
//  • a list exceeds SEAL_ARRAY_TYPES_LIST_CAP
//
size_t
seal_array_types_marshal(const struct seal_array_types* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_ARRAY_TYPES_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters. Malloc is not used on decoding errors.
// ENOMEM may leave fields unintialized
// Texts are allocated including null ('\0') terminator, even when empty.
// Caller owns the memory.
size_t
seal_array_types_unmarshal(struct seal_array_types* o, const void* start, void* (*malloc)(size_t));

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_LIST_TYPES_FRAME_CAP 4096
// Encodings with the compact profile limit each text in byte size.
#define SEAL_LIST_TYPES_UTF8_CAP 255
// Encodings with the compact profile limit each lists in element count.
#define SEAL_LIST_TYPES_LIST_CAP 255

// Encodings from this version of the data structure are limited in size by the
// profile capacity.
#define SEAL_LIST_TYPES_MARSHAL_MAX SEAL_LIST_TYPES_FRAME_CAP

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_LIST_TYPES_MARSHAL_BUF (SEAL_LIST_TYPES_MARSHAL_MAX+7 & ~7)

// ListTypes contains all list types supported by Colfer.
struct seal_list_types {
	// opaque values
	struct {
		uint8_t* list;
		size_t len; // element count
	} a8l;

	struct {
		uint16_t* list;
		size_t len; // element count
	} a16l;

	struct {
		uint32_t* list;
		size_t len; // element count
	} a32l;

	struct {
		uint64_t* list;
		size_t len; // element count
	} a64l;

	// floating points
	struct {
		float* list;
		size_t len; // element count
	} f32l;

	struct {
		double* list;
		size_t len; // element count
	} f64l;

	// complex types
	struct {
		struct timespec* list;
		size_t len; // element count
	} tl;

	struct {
		struct {
			const char* utf8;
			size_t len; // octet count
		}* list;
		size_t len; // element count
	} sl;
};

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_LIST_TYPES_MARSHAL_BUF.
// The return is zero (0) on any of the following, exclusively.
//
//  • encoding exceeds SEAL_LIST_TYPES_FRAME_CAP
//  • a text exceeds SEAL_LIST_TYPES_TEXT_CAP
//  • a list exceeds SEAL_LIST_TYPES_LIST_CAP
//
size_t
seal_list_types_marshal(const struct seal_list_types* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_LIST_TYPES_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters. Malloc is not used on decoding errors.
// ENOMEM may leave fields unintialized
// Texts are allocated including null ('\0') terminator, even when empty.
// Lists are allocated including <stddef.h> nullptr sentinel, even when empty.
// Caller owns the memory.
size_t
seal_list_types_unmarshal(struct seal_list_types* o, const void* start, void* (*malloc)(size_t));

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_OPAQUE_TYPES_FRAME_CAP 4096

// Encodings from this version of the data structure have a fixed size.
#define SEAL_OPAQUE_TYPES_MARSHAL_MAX 48

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_OPAQUE_TYPES_MARSHAL_BUF (SEAL_OPAQUE_TYPES_MARSHAL_MAX+7 & ~7)

// OpaqueTypes is fixed in size. The variable sized are in ListTypes.
struct seal_opaque_types {
	// Test 8-bit values.
	uint8_t a8;

	// Test 8-bit arrays.
	uint8_t a8n2[2];

	// Test 16-bit values.
	uint16_t a16;

	// Test 16-bit arrays.
	uint16_t a16n2[2];

	// Test 32-bit values.
	uint32_t a32;

	// Test 32-bit arrays.
	uint32_t a32n2[2];

	// Test 64-bit values.
	uint64_t a64;

	// Test 64-bit arrays.
	uint64_t a64n2[2];
};

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_OPAQUE_TYPES_MARSHAL_BUF.
// This specific version of the data structure always succeeds with a return of
// exactly SEAL_OPAQUE_TYPES_MARSHAL_MAX.
// However, future revisions may return zero (0) on any the following.
//
//  • encoding exceeds SEAL_OPAQUE_TYPES_FRAME_CAP
//  • a text exceeds SEAL_OPAQUE_TYPES_TEXT_CAP
//  • a list exceeds SEAL_OPAQUE_TYPES_LIST_CAP
//
size_t
seal_opaque_types_marshal(const struct seal_opaque_types* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_OPAQUE_TYPES_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters.
size_t
seal_opaque_types_unmarshal(struct seal_opaque_types* o, const void* start);

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_MANY_FLAGS_FRAME_CAP 4096

// Encodings from this version of the data structure have a fixed size.
#define SEAL_MANY_FLAGS_MARSHAL_MAX 11

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_MANY_FLAGS_MARSHAL_BUF (SEAL_MANY_FLAGS_MARSHAL_MAX+7 & ~7)

// ManyFlags encodes over multiple bit-fields.
struct seal_many_flags {
	// Bit field for booleans defined as SEAL_MANY_FLAGS_B1_FLAG_*_FLAG.
	unsigned int _flags;

	// because we can
	uint32_t shift;

	uint8_t end;
};

#define SEAL_MANY_FLAGS_B1_FLAG (1 << 0)

#define SEAL_MANY_FLAGS_B2_FLAG (1 << 1)

#define SEAL_MANY_FLAGS_B3_FLAG (1 << 2)

#define SEAL_MANY_FLAGS_B4_FLAG (1 << 3)

#define SEAL_MANY_FLAGS_B5_FLAG (1 << 4)

#define SEAL_MANY_FLAGS_B6_FLAG (1 << 5)

#define SEAL_MANY_FLAGS_B7_FLAG (1 << 6)

// last in bit field
#define SEAL_MANY_FLAGS_B8_FLAG (1 << 7)

// second bit-field
#define SEAL_MANY_FLAGS_B9_FLAG (1 << 8)

#define SEAL_MANY_FLAGS_B10_FLAG (1 << 9)

#define SEAL_MANY_FLAGS_B11_FLAG (1 << 10)

#define SEAL_MANY_FLAGS_B12_FLAG (1 << 11)

#define SEAL_MANY_FLAGS_B13_FLAG (1 << 12)

#define SEAL_MANY_FLAGS_B14_FLAG (1 << 13)

#define SEAL_MANY_FLAGS_B15_FLAG (1 << 14)

#define SEAL_MANY_FLAGS_B16_FLAG (1 << 15)

// third bit-field
#define SEAL_MANY_FLAGS_B17_FLAG (1 << 16)

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_MANY_FLAGS_MARSHAL_BUF.
// This specific version of the data structure always succeeds with a return of
// exactly SEAL_MANY_FLAGS_MARSHAL_MAX.
// However, future revisions may return zero (0) on any the following.
//
//  • encoding exceeds SEAL_MANY_FLAGS_FRAME_CAP
//  • a text exceeds SEAL_MANY_FLAGS_TEXT_CAP
//  • a list exceeds SEAL_MANY_FLAGS_LIST_CAP
//
size_t
seal_many_flags_marshal(const struct seal_many_flags* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_MANY_FLAGS_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters.
size_t
seal_many_flags_unmarshal(struct seal_many_flags* o, const void* start);

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_NESTED_TYPES_FRAME_CAP 4096
// Encodings with the compact profile limit each lists in element count.
#define SEAL_NESTED_TYPES_LIST_CAP 255

// Encodings from this version of the data structure are limited in size by the
// profile capacity.
#define SEAL_NESTED_TYPES_MARSHAL_MAX SEAL_NESTED_TYPES_FRAME_CAP

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_NESTED_TYPES_MARSHAL_BUF (SEAL_NESTED_TYPES_MARSHAL_MAX+7 & ~7)

// NestedTypes contains embedded data structures.
struct seal_nested_types {
	// variable size
	struct {
		struct seal_base_types* list;
		size_t len; // element count
	} list;
};

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_NESTED_TYPES_MARSHAL_BUF.
// The return is zero (0) on any of the following, exclusively.
//
//  • encoding exceeds SEAL_NESTED_TYPES_FRAME_CAP
//  • a text exceeds SEAL_NESTED_TYPES_TEXT_CAP
//  • a list exceeds SEAL_NESTED_TYPES_LIST_CAP
//
size_t
seal_nested_types_marshal(const struct seal_nested_types* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_NESTED_TYPES_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters. Malloc is not used on decoding errors.
// ENOMEM may leave fields unintialized
// Lists are allocated including <stddef.h> nullptr sentinel, even when empty.
// Caller owns the memory.
size_t
seal_nested_types_unmarshal(struct seal_nested_types* o, const void* start, void* (*malloc)(size_t));

// Encodings with the compact profile are limited to 4 KiB in size.
#define SEAL_DROMEDARY_CASE_FRAME_CAP 4096

// Encodings from this version of the data structure have a natural size limit.
#define SEAL_DROMEDARY_CASE_MARSHAL_MAX (5 + 8)

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define SEAL_DROMEDARY_CASE_MARSHAL_BUF (SEAL_DROMEDARY_CASE_MARSHAL_MAX+7 & ~7)

// DromedaryCase mixes name conventions.
// Its serial size has a natural limit.
struct seal_dromedary_case {
	// title-case option
	int32_t pascal_case;

	// best-case scenario
	uint8_t with_snake;
};

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than SEAL_DROMEDARY_CASE_MARSHAL_BUF.
// This specific version of the data structure always succeeds with a return of
// up to SEAL_DROMEDARY_CASE_MARSHAL_MAX.
// However, future revisions may return zero (0) on any the following.
//
//  • encoding exceeds SEAL_DROMEDARY_CASE_FRAME_CAP
//  • a text exceeds SEAL_DROMEDARY_CASE_TEXT_CAP
//  • a list exceeds SEAL_DROMEDARY_CASE_LIST_CAP
//
size_t
seal_dromedary_case_marshal(const struct seal_dromedary_case* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than SEAL_DROMEDARY_CASE_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters.
size_t
seal_dromedary_case_unmarshal(struct seal_dromedary_case* o, const void* start);
#ifdef __cplusplus
} // extern "C"
#endif
