// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf for package gen.

/// Package gen tests all field mapping options.

import 'dart:typed_data';
import 'package:collection/collection.dart';
import 'package:quiver/core.dart';
import 'dart:convert';

/// The upper limit for serial byte sizes.
final colferSizeMax = 16 * 1024 * 1024;

/// The upper limit for the number of elements in a list.
final colferListMax = 64 * 1024;

/// O contains all supported data types.
class O {
  /// B tests booleans.
  bool b;

  /// U32 tests unsigned 32-bit integers.
  int u32;

  /// U64 tests unsigned 64-bit integers.
  int u64;

  /// I32 tests signed 32-bit integers.
  int i32;

  /// I64 tests signed 64-bit integers.
  int i64;

  /// F32 tests 32-bit floating points.
  double f32;

  /// F64 tests 64-bit floating points.
  double f64;

  /// T tests timestamps.
  DateTime? t;

  /// S tests text.
  String s;

  /// A tests binaries.
  Uint8List a;

  /// O tests nested data structures.
  O? o;

  /// Os tests data structure lists.
  List<O?> os;

  /// Ss tests text lists.
  List<String> ss;

  /// As tests binary lists.
  List<Uint8List> as_;

  /// U8 tests unsigned 8-bit integers.
  int u8;

  /// U16 tests unsigned 16-bit integers.
  int u16;

  /// F32s tests 32-bit floating point lists.
  Float32List f32s;

  /// F64s tests 64-bit floating point lists.
  Float64List f64s;

  @override
  bool operator ==(_other) {
    return (_other is O) &&
        _other.b == b &&
        _other.u32 == u32 &&
        _other.u64 == u64 &&
        _other.i32 == i32 &&
        _other.i64 == i64 &&
        _other.f32 == f32 &&
        _other.f64 == f64 &&
        _other.t == t &&
        _other.s == s &&
        IterableEquality().equals(_other.a, a) &&
        _other.o == o &&
        IterableEquality().equals(_other.os, os) &&
        IterableEquality().equals(_other.ss, ss) &&
        DeepCollectionEquality().equals(_other.as_, as_) &&
        _other.u8 == u8 &&
        _other.u16 == u16 &&
        IterableEquality().equals(_other.f32s, f32s) &&
        IterableEquality().equals(_other.f64s, f64s);
  }

  String toString() {
    return 'class O {'
            'b: ${b.toString()}'
            ', u32: ${u32.toString()}'
            ', u64: ${u64.toString()}'
            ', i32: ${i32.toString()}'
            ', i64: ${i64.toString()}'
            ', f32: ${f32.toString()}'
            ', f64: ${f64.toString()}'
            ', t: ${t.toString()}'
            ', s: "$s"'
            ', a: ${a.toString()}'
            ', o: ${o.toString()}'
            ', os: List<O>${os.toString()}'
            ', ss: [' +
        (ss.isNotEmpty ? '"${ss.join('", "')}"' : '') +
        ']'
            ', as_: List<Uint8List>${as_.toString()}'
            ', u8: ${u8.toString()}'
            ', u16: ${u16.toString()}'
            ', f32s: List<Float32List>${f32s.toString()}'
            ', f64s: List<Float64List>${f64s.toString()}';
  }

  @override
  int get hashCode =>
      hashObjects([b, u32, u64, i32, i64, f32, f64, t, s, a, o, os, ss, as_, u8, u16, f32s, f64s]);

  O({
    this.b = false,
    this.u32 = 0,
    this.u64 = 0,
    this.i32 = 0,
    this.i64 = 0,
    this.f32 = 0.0,
    this.f64 = 0.0,
    this.t,
    this.s = '',
    Uint8List? a,
    this.o,
    List<O>? os,
    List<String>? ss,
    List<Uint8List>? as_,
    this.u8 = 0,
    this.u16 = 0,
    Float32List? f32s,
    Float64List? f64s,
  })  : a = a ?? Uint8List(0),
        os = os ?? [],
        ss = ss ?? [],
        as_ = as_ ?? [],
        f32s = f32s ?? Float32List(0),
        f64s = f64s ?? Float64List(0);

  /// Returns an over estimatation of marshal length.

  /// Throws [Exception] if the size of a list exceeds [colferListMax],
  /// or if a text, binary, or the estimation exceeds [colferSizeMax].
  /// Returns an over estimated length for the required buffer. String
  /// characters are counted for 4 bytes, everything has its exact size.
  int marshalLen() {
    int _l = 1;
    {
      if (b) {
        _l++;
      }
    }
    {
      int _x = u32;
      if (_x >= 1 << 21) {
        _l += 5;
      } else if (_x != 0) {
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      int _x = u64;
      if (_x < 0 || 0x2000000000000 <= _x) {
        _l += 9;
      } else if (_x != 0) {
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      int _x = i32;
      if (_x != 0) {
        if (_x < 0) {
          _x = -_x;
        }
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      int _x = i64;
      if (_x != 0) {
        if (-_x == _x) {
          _l += 10;
        } else {
          _l += 2;
          if (_x < 0) {
            _x = -_x;
          }
          for (; _x >= 0x80; _l++) {
            _x >>= 7;
          }
        }
      }
    }
    {
      if (f32 != 0) {
        _l += 5;
      }
    }
    {
      if (f64 != 0) {
        _l += 9;
      }
    }
    {
      final _v = t;
      if (_v != null) {
        int _us = _v.microsecondsSinceEpoch;
        int _s = _us ~/ 1E6;
        if (_s >= 1 << 33 || _us < 0) {
          _l += 13;
        } else {
          _l += 9;
        }
      }
    }
    {
      int _x = s.length;
      if (_x != 0) {
        _x *= 4;
        if (_x > colferSizeMax) {
          throw Exception('colfer: gen.o.s size $_x exceeds $colferSizeMax bytes');
        }
        for (_l += _x + 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      int _x = a.length;
      if (_x != 0) {
        if (_x > colferSizeMax) {
          throw Exception('colfer: gen.o.a size $_x exceeds $colferSizeMax bytes');
        }
        for (_l += _x + 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      if (o != null) {
        _l += o!.marshalLen() + 1;
      }
    }
    {
      int _x = os.length;
      if (_x != 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.os size $_x exceeds $colferListMax');
        }
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
        for (final _v in os) {
          if (_v == null) {
            _l++;
            continue;
          }
          _l += _v.marshalLen();
        }
        if (_l > colferSizeMax) {
          throw Exception('colfer: gen.o.os size $_l exceeds $colferSizeMax bytes');
        }
      }
    }
    {
      int _x = ss.length;
      if (_x != 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.ss size $_x exceeds $colferListMax');
        }
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
        for (final _a in ss) {
          _x = _a.length;
          _x *= 4;
          if (_x > colferSizeMax) {
            throw Exception('colfer: gen.o.ss size $_x exceeds $colferSizeMax bytes');
          }
          for (_l += _x + 1; _x >= 0x80; _l++) {
            _x >>= 7;
          }
        }
        if (_l >= colferSizeMax) {
          throw Exception('colfer: gen.o.ss size $_l exceeds $colferSizeMax bytes');
        }
      }
    }
    {
      int _x = as_.length;
      if (_x != 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.as size $_x exceeds $colferListMax');
        }
        for (_l += 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
        for (final _a in as_) {
          _x = _a.length;
          if (_x > colferSizeMax) {
            throw Exception('colfer: gen.o.as size $_x exceeds $colferSizeMax bytes');
          }
          for (_l += _x + 1; _x >= 0x80; _l++) {
            _x >>= 7;
          }
        }
        if (_l >= colferSizeMax) {
          throw Exception('colfer: gen.o.as size $_l exceeds $colferSizeMax bytes');
        }
      }
    }
    {
      if (u8 != 0) {
        _l += 2;
      }
    }
    {
      if (u16 >= 1 << 8) {
        _l += 3;
      } else if (u16 != 0) {
        _l += 2;
      }
    }
    {
      int _x = f32s.length;
      if (_x != 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.f32s size $_x exceeds $colferListMax');
        }
        for (_l += 2 + _x * 4; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    {
      int _x = f64s.length;
      if (_x != 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.f64s size $_x exceeds $colferListMax');
        }
        for (_l += 2 + _x * 8; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    if (_l > colferSizeMax) {
      throw Exception('colfer: gen.o size $_l exceeds $colferSizeMax bytes');
    }
    return _l;
  }

  /// Encodes as Colfer into [_buf].

  /// Throws [Exception] if uint8, uint16, uint32 or int32 value overflows, or
  /// when the size of a list exceeds [colferListMax], or is a text, binary, or
  /// [_buf] exceeds [colferSizeMax]. Returns the number of bytes written.
  int marshalTo(Uint8List _buf) {
    var _view = _buf.buffer.asByteData();
    int _i = 0;
    {
      if (b) {
        _buf[_i] = 0;
        _i++;
      }
    }
    {
      int _x = u32;
      if (_x != 0) {
        if (_x > 4294967295 || _x < 0) {
          throw Exception('colfer: $_x out of reach: u32');
        }
        if (_x < 0x200000) {
          _buf[_i] = 1;
          _i++;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _i++;
        } else {
          _buf[_i] = 1 | 128;
          _view.setInt32(_i + 1, _x);
          _i += 5;
        }
      }
    }
    {
      int _x = u64;
      if (_x != 0) {
        if (0 < _x && _x < 0x2000000000000) {
          _buf[_i] = 2;
          _i++;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _i++;
        } else {
          _buf[_i] = 2 | 128;
          _view.setInt64(_i + 1, _x);
          _i += 9;
        }
      }
    }
    {
      int _x = i32;
      if (_x != 0) {
        if (_x < 0) {
          if (_x < -2147483648) {
            throw Exception('colfer: $_x out of reach: i32');
          }
          _buf[_i] = 3 | 128;
          _i++;
          _x = -_x;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _i++;
        } else {
          if (_x > 2147483647) {
            throw Exception('colfer: $_x out of reach: i32');
          }
          _buf[_i] = 3;
          _i++;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _i++;
        }
      }
    }
    {
      int _x = i64;
      if (_x != 0) {
        if (_x < 0) {
          _buf[_i] = 4 | 128;
          _i++;
          _x = -_x;
          if (i64 == _x) {
            _buf.fillRange(_i, 10, 128);
            _i += 9;
          } else {
            while (_x > 127) {
              _buf[_i] = (_x & 127) | 128;
              _i++;
              _x >>= 7;
            }
            _buf[_i] = _x;
            _i++;
          }
        } else {
          _buf[_i] = 4;
          _i++;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _i++;
        }
      }
    }
    {
      if (f32 != 0) {
        _buf[_i] = 5;
        if (f32.isNaN) {
          _buf[_i + 1] = 0x7f;
          _buf[_i + 2] = 0xc0;
        } else {
          _view.setFloat32(_i + 1, f32);
        }
        _i += 5;
      }
    }
    {
      if (f64 != 0) {
        _buf[_i] = 6;
        if (f64.isNaN) {
          _buf[_i + 1] = 0x7f;
          _buf[_i + 2] = 0xf8;
          _buf[_i + 8] = 1;
        } else {
          _view.setFloat64(_i + 1, f64);
        }
        _i += 9;
      }
    }
    {
      if (t != null) {
        int _us = t!.microsecondsSinceEpoch;
        int _res = _us % 1000000;
        _us -= _res;
        int _s = _us ~/ 1E6;
        int _ns = _res * 1000;

        if (_s >= 1 << 33 || _us < 0) {
          _buf[_i] = 7 | 128;
          _view.setInt64(_i + 1, _s);
          _i += 9;
        } else {
          _buf[_i] = 7;
          _view.setInt32(_i + 1, _s);
          _i += 5;
        }
        _view.setInt32(_i, _ns);
        _i += 4;
      }
    }
    {
      int _x = s.length;
      if (_x > 0) {
        _buf[_i] = 8;
        _i++;
        var _v = utf8.encode(s);
        _x = _v.length;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _buf.setAll(_i + 1, _v);
        _i += 1 + _v.length;
      }
    }
    {
      int _x = a.length;
      if (_x > 0) {
        _buf[_i] = 9;
        _i++;
        var _v = a;
        _x = _v.length;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _buf.setAll(_i + 1, _v);
        _i += 1 + _v.length;
      }
    }
    {
      if (o != null) {
        _buf[_i] = 10;
        _i++;
        _i += o!.marshalTo(Uint8List.view(_buf.buffer, _i));
      }
    }
    {
      int _x = os.length;
      if (_x > 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.os size $_x exceeds $colferListMax');
        }
        _buf[_i] = 11;
        _i++;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _i++;
        for (var _vi in os) {
          if (_vi == null) {
            _vi = O();
          }
          _i += _vi.marshalTo(Uint8List.view(_buf.buffer, _i));
        }
      }
    }
    {
      int _x = ss.length;
      if (_x > 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.ss size $_x exceeds $colferListMax');
        }
        _buf[_i] = 12;
        _i++;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _i++;
        for (final _vi in ss) {
          var _v = utf8.encode(_vi);
          _x = _v.length;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _buf.setAll(_i + 1, _v);
          _i += 1 + _v.length;
        }
      }
    }
    {
      int _x = as_.length;
      if (_x > 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.as size $_x exceeds $colferListMax');
        }
        _buf[_i] = 13;
        _i++;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _i++;
        for (final _vi in as_) {
          var _v = _vi;
          _x = _v.length;
          while (_x > 127) {
            _buf[_i] = (_x & 127) | 128;
            _i++;
            _x >>= 7;
          }
          _buf[_i] = _x;
          _buf.setAll(_i + 1, _v);
          _i += 1 + _v.length;
        }
      }
    }
    {
      if (u8 != 0) {
        if (u8 > 255 || u8 < 0) {
          throw Exception('colfer: $u8 out of reach: u8');
        }
        _buf[_i] = 14;
        _buf[_i + 1] = u8;
        _i += 2;
      }
    }
    {
      if (u16 != 0) {
        if (u16 > 65535 || u16 < 0) {
          throw Exception('colfer: $u16 out of reach: u16');
        }
        if (u16 < 256) {
          _buf[_i] = 15 | 128;
          _buf[_i + 1] = u16;
          _i += 2;
        } else {
          _buf[_i] = 15;
          _buf[_i + 1] = u16 >> 8;
          _buf[_i + 2] = u16;
          _i += 3;
        }
      }
    }
    {
      int _x = f32s.length;
      if (_x > 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.f32s size $_x exceeds $colferListMax');
        }
        _buf[_i] = 16;
        _i++;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _i++;
        for (final _vi in f32s) {
          if (_vi.isNaN) {
            _buf[_i] = 0x7f;
            _buf[_i + 1] = 0xc0;
          } else {
            _view.setFloat32(_i, _vi);
          }
          _i += 4;
        }
      }
    }
    {
      int _x = f64s.length;
      if (_x > 0) {
        if (_x > colferListMax) {
          throw Exception('colfer: gen.o.f64s size $_x exceeds $colferListMax');
        }
        _buf[_i] = 17;
        _i++;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _i++;
        for (final _vi in f64s) {
          if (_vi.isNaN) {
            _buf[_i] = 0x7f;
            _buf[_i + 1] = 0xf8;
            _buf[_i + 7] = 1;
          } else {
            _view.setFloat64(_i, _vi);
          }
          _i += 8;
        }
      }
    }

    _buf[_i] = 127;
    _i++;
    if (_i >= colferSizeMax) {
      throw Exception('colfer: gen.o size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }

  /// Decodes [_data] as Colfer.

  /// Throws [RangeError] if there is an unexpexted end of data, or [Exception]
  /// if a list exceeds [colferListMax], or if a text, binary or [_data] exceeds
  /// [colferSizeMax]. Returns the number of bytes read.
  int unmarshal(Uint8List _data) {
    int _header = 0, _i = 0;
    var _view = ByteData.view(_data.buffer);
    int _nextData() {
      int _dataI = _data[_i];
      _i++;
      return _dataI;
    }

    _header = _nextData();

    int readVarint() {
      int _c = _data[_i];
      _i++;
      if (_c >= 0x80) {
        _c &= 0x7f;
        for (int _shift = 7;; _shift += 7) {
          int _b = _data[_i];
          _i++;
          if (_b < 0x80 || _shift == 56) {
            _c |= _b << _shift;
            break;
          }
          _c |= (_b & 0x7f) << _shift;
        }
      }
      return _c;
    }

    if (_header == 0) {
      b = true;
      _header = _nextData();
    }

    if (_header == 1) {
      u32 = readVarint();
      _header = _nextData();
    } else if (_header == (1 | 128)) {
      u32 = _view.getUint32(_i);
      _i += 4;
      _header = _nextData();
    }

    if (_header == 2) {
      u64 = readVarint();
      _header = _nextData();
    } else if (_header == (2 | 128)) {
      int _v = _view.getUint32(_i) * 0x100000000;
      _v += _view.getUint32(_i + 4);
      u64 = _v;
      _i += 8;
      _header = _nextData();
    }

    if (_header == 3) {
      i32 = readVarint();
      _header = _nextData();
    } else if (_header == (3 | 128)) {
      i32 = -1 * readVarint();
      _header = _nextData();
    }

    if (_header == 4) {
      i64 = readVarint();
      _header = _nextData();
    } else if (_header == (4 | 128)) {
      i64 = -1 * readVarint();
      _header = _nextData();
    }

    if (_header == 5) {
      f32 = _view.getFloat32(_i);
      _i += 4;
      _header = _nextData();
    }

    if (_header == 6) {
      f64 = _view.getFloat64(_i);
      _i += 8;
      _header = _nextData();
    }

    if (_header == 7) {
      int _s = _view.getUint32(_i);
      int _us = _view.getUint32(_i + 4) ~/ 1000;
      t = DateTime.fromMicrosecondsSinceEpoch(_s * 1000000 + _us);
      _i += 8;
      _header = _nextData();
    } else if (_header == (7 | 128)) {
      int _s = _view.getInt64(_i);
      int _us = _view.getUint32(_i + 8) ~/ 1000;
      t = DateTime.fromMicrosecondsSinceEpoch(_s * 1000000 + _us);
      _i += 12;
      _header = _nextData();
    }

    if (_header == 8) {
      int _size = readVarint();
      if (_size < 0 || _size > colferSizeMax) {
        throw Exception('colfer: gen.o.s size $_size exceeds $colferSizeMax bytes');
      }

      int _s = _i;
      _i += _size;
      s = utf8.decode(_data.sublist(_s, _i));
      _header = _nextData();
    }

    if (_header == 9) {
      int _size = readVarint();
      if (_size < 0 || _size > colferSizeMax) {
        throw Exception('colfer: gen.o.a size $_size exceeds $colferSizeMax bytes');
      }

      int _start = _i;
      _i += _size;
      a = _data.sublist(_start, _i);
      _header = _nextData();
    }

    if (_header == 10) {
      var _s = O();
      _i += _s.unmarshal(_data.sublist(_i));
      o = _s;
      _header = _nextData();
    }

    if (_header == 11) {
      int _v = readVarint();
      if (_v < 0 || _v > colferListMax) {
        throw Exception('colfer: gen.o.os size $_v exceeds $colferListMax');
      }

      if (os.length != _v) {
        os = List<O>.filled(_v, O());
      }
      for (var _vi in os) {
        if (_vi == null) {
          _vi = O();
        }
        _i += _vi.unmarshal(_data.sublist(_i));
      }
      _header = _nextData();
    }

    if (_header == 12) {
      int _v = readVarint();
      if (_v < 0 || _v > colferListMax) {
        throw Exception('colfer: gen.o.ss size $_v exceeds $colferListMax');
      }

      if (ss.length != _v) {
        ss = List<String>.filled(_v, '');
      }
      for (int _vi = 0; _vi < _v; _vi++) {
        int _size = readVarint();
        if (_size < 0 || _size > colferSizeMax) {
          throw Exception('colfer: gen.o.ss size $_size exceeds $colferSizeMax bytes');
        }

        int _s = _i;
        _i += _size;
        ss[_vi] = utf8.decode(_data.sublist(_s, _i));
      }
      _header = _nextData();
    }

    if (_header == 13) {
      int _v = readVarint();
      if (_v < 0 || _v > colferListMax) {
        throw Exception('colfer: gen.o.as size $_v exceeds $colferListMax');
      }

      if (as_.length != _v) {
        as_ = List<Uint8List>.filled(_v, Uint8List(0));
      }
      for (int _vi = 0; _vi < _v; _vi++) {
        int _size = readVarint();
        if (_size < 0 || _size > colferSizeMax) {
          throw Exception('colfer: gen.o.as size $_size exceeds $colferSizeMax bytes');
        }

        int _s = _i;
        _i += _size;
        as_[_vi] = _data.sublist(_s, _i);
      }
      _header = _nextData();
    }

    if (_header == 14) {
      u8 = _nextData();
      _header = _nextData();
    }

    if (_header == 15) {
      u16 = (_nextData() << 8) | _nextData();
      _header = _nextData();
    } else if (_header == (15 | 128)) {
      u16 = _nextData();
      _header = _nextData();
    }

    if (_header == 16) {
      int _v = readVarint();
      if (_v < 0 || _v > colferListMax) {
        throw Exception('colfer: gen.o.f32s size $_v exceeds $colferListMax');
      }

      if (f32s.length != _v) {
        f32s = Float32List(_v);
      }
      for (int _vi = 0; _vi < _v; _vi++) {
        f32s[_vi] = _view.getFloat32(_i);
        _i += 4;
      }
      _header = _nextData();
    }

    if (_header == 17) {
      int _v = readVarint();
      if (_v < 0 || _v > colferListMax) {
        throw Exception('colfer: gen.o.f64s size $_v exceeds $colferListMax');
      }

      if (f64s.length != _v) {
        f64s = Float64List(_v);
      }
      for (int _vi = 0; _vi < _v; _vi++) {
        f64s[_vi] = _view.getFloat64(_i);
        _i += 8;
      }
      _header = _nextData();
    }

    if (_header != 127) {
      throw Exception('colfer: unknown header $_header at byte ${_i - 1}');
    }
    if (_i > colferSizeMax) {
      throw Exception('colfer: gen.o size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }
}

/// DromedaryCase oposes name casings.
class DromedaryCase {
  String pascalCase;

  @override
  bool operator ==(_other) {
    return (_other is DromedaryCase) && _other.pascalCase == pascalCase;
  }

  String toString() {
    return 'class DromedaryCase {'
        'pascalCase: "$pascalCase"';
  }

  @override
  int get hashCode => pascalCase.hashCode;

  DromedaryCase({
    this.pascalCase = '',
  });

  /// Returns an over estimatation of marshal length.

  /// Throws [Exception] if the size of a list exceeds [colferListMax],
  /// or if a text, binary, or the estimation exceeds [colferSizeMax].
  /// Returns an over estimated length for the required buffer. String
  /// characters are counted for 4 bytes, everything has its exact size.
  int marshalLen() {
    int _l = 1;
    {
      int _x = pascalCase.length;
      if (_x != 0) {
        _x *= 4;
        if (_x > colferSizeMax) {
          throw Exception(
              'colfer: gen.dromedaryCase.PascalCase size $_x exceeds $colferSizeMax bytes');
        }
        for (_l += _x + 2; _x >= 0x80; _l++) {
          _x >>= 7;
        }
      }
    }
    if (_l > colferSizeMax) {
      throw Exception('colfer: gen.dromedaryCase size $_l exceeds $colferSizeMax bytes');
    }
    return _l;
  }

  /// Encodes as Colfer into [_buf].

  /// Throws [Exception] if uint8, uint16, uint32 or int32 value overflows, or
  /// when the size of a list exceeds [colferListMax], or is a text, binary, or
  /// [_buf] exceeds [colferSizeMax]. Returns the number of bytes written.
  int marshalTo(Uint8List _buf) {
    int _i = 0;
    {
      int _x = pascalCase.length;
      if (_x > 0) {
        _buf[_i] = 0;
        _i++;
        var _v = utf8.encode(pascalCase);
        _x = _v.length;
        while (_x > 127) {
          _buf[_i] = (_x & 127) | 128;
          _i++;
          _x >>= 7;
        }
        _buf[_i] = _x;
        _buf.setAll(_i + 1, _v);
        _i += 1 + _v.length;
      }
    }

    _buf[_i] = 127;
    _i++;
    if (_i >= colferSizeMax) {
      throw Exception('colfer: gen.dromedaryCase size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }

  /// Decodes [_data] as Colfer.

  /// Throws [RangeError] if there is an unexpexted end of data, or [Exception]
  /// if a list exceeds [colferListMax], or if a text, binary or [_data] exceeds
  /// [colferSizeMax]. Returns the number of bytes read.
  int unmarshal(Uint8List _data) {
    int _header = 0, _i = 0;
    int _nextData() {
      int _dataI = _data[_i];
      _i++;
      return _dataI;
    }

    _header = _nextData();

    int readVarint() {
      int _c = _data[_i];
      _i++;
      if (_c >= 0x80) {
        _c &= 0x7f;
        for (int _shift = 7;; _shift += 7) {
          int _b = _data[_i];
          _i++;
          if (_b < 0x80 || _shift == 56) {
            _c |= _b << _shift;
            break;
          }
          _c |= (_b & 0x7f) << _shift;
        }
      }
      return _c;
    }

    if (_header == 0) {
      int _size = readVarint();
      if (_size < 0 || _size > colferSizeMax) {
        throw Exception(
            'colfer: gen.dromedaryCase.PascalCase size $_size exceeds $colferSizeMax bytes');
      }

      int _s = _i;
      _i += _size;
      pascalCase = utf8.decode(_data.sublist(_s, _i));
      _header = _nextData();
    }

    if (_header != 127) {
      throw Exception('colfer: unknown header $_header at byte ${_i - 1}');
    }
    if (_i > colferSizeMax) {
      throw Exception('colfer: gen.dromedaryCase size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }
}

/// EmbedO has an inner object only.
/// Covers regression of issue #66.
class EmbedO {
  O? inner;

  @override
  bool operator ==(_other) {
    return (_other is EmbedO) && _other.inner == inner;
  }

  String toString() {
    return 'class EmbedO {'
        'inner: ${inner.toString()}';
  }

  @override
  int get hashCode => inner.hashCode;

  EmbedO({
    this.inner,
  });

  /// Returns an over estimatation of marshal length.

  /// Throws [Exception] if the size of a list exceeds [colferListMax],
  /// or if a text, binary, or the estimation exceeds [colferSizeMax].
  /// Returns an over estimated length for the required buffer. String
  /// characters are counted for 4 bytes, everything has its exact size.
  int marshalLen() {
    int _l = 1;
    {
      if (inner != null) {
        _l += inner!.marshalLen() + 1;
      }
    }
    if (_l > colferSizeMax) {
      throw Exception('colfer: gen.EmbedO size $_l exceeds $colferSizeMax bytes');
    }
    return _l;
  }

  /// Encodes as Colfer into [_buf].

  /// Throws [Exception] if uint8, uint16, uint32 or int32 value overflows, or
  /// when the size of a list exceeds [colferListMax], or is a text, binary, or
  /// [_buf] exceeds [colferSizeMax]. Returns the number of bytes written.
  int marshalTo(Uint8List _buf) {
    int _i = 0;
    {
      if (inner != null) {
        _buf[_i] = 0;
        _i++;
        _i += inner!.marshalTo(Uint8List.view(_buf.buffer, _i));
      }
    }

    _buf[_i] = 127;
    _i++;
    if (_i >= colferSizeMax) {
      throw Exception('colfer: gen.EmbedO size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }

  /// Decodes [_data] as Colfer.

  /// Throws [RangeError] if there is an unexpexted end of data, or [Exception]
  /// if a list exceeds [colferListMax], or if a text, binary or [_data] exceeds
  /// [colferSizeMax]. Returns the number of bytes read.
  int unmarshal(Uint8List _data) {
    int _header = 0, _i = 0;
    int _nextData() {
      int _dataI = _data[_i];
      _i++;
      return _dataI;
    }

    _header = _nextData();
    if (_header == 0) {
      var _s = O();
      _i += _s.unmarshal(_data.sublist(_i));
      inner = _s;
      _header = _nextData();
    }

    if (_header != 127) {
      throw Exception('colfer: unknown header $_header at byte ${_i - 1}');
    }
    if (_i > colferSizeMax) {
      throw Exception('colfer: gen.EmbedO size $_i exceeds $colferSizeMax bytes');
    }
    return _i;
  }
}
