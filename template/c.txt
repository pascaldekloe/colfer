// Code generated by colf(1); DO NOT EDIT.
{{- range .}}
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{- end}}

#include "Colfer.h"
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
{{- if .HasTimestamp}}
#include <time.h>
{{- end}}

{{- if .HasFloat}}

// floating-point byte mapping
union f32m {
	float f;
	uint32_t u;
};

union f64m {
	double f;
	uint64_t u;
};
{{- end}}

const uint64_t COLFER_MASKS[9] = {
	0,
	0xff,
	0xffff,
	0xffffff,
	0xffffffff,
	0xffffffffff,
	0xffffffffffff,
	0xffffffffffffff,
	0xffffffffffffffff,
};

// Saturating subtract prevents overflows branchless.
static inline size_t
satsub(size_t minuend, size_t subtrahend) {
	// TODO: utilize ARM instructions
	return (minuend - subtrahend) * (minuend >= subtrahend);
}

{{- range .}}{{/* packages */}}
{{- range .Structs}}

size_t
{{.NameNative}}_marshal(const struct {{.NameNative}}* o, void* start) {
	uint64_t word0 = {{.FixedSize}} - 4 | 0x10000;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + {{.FixedSize}};
{{- range .Fields}}

	// pack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.len;
{{template "marshal-integer" .}}
 {{- else}}{{/* not list */}}
  {{- if eq .Type "bool"}}
   {{- if .FirstInBitField}}
    {{- if eq .WordShift 0}}
	uint64_t word{{.WordIndex}} = (uint64_t)o->bools>>{{.BoolIndex}} & 0xff;
    {{- else if le .BoolIndex .WordShift}}
	word{{.WordIndex}} |= (uint64_t)o->bools<<({{.WordShift}}-{{.BoolIndex}}) & (uint64_t)0xff<<{{.WordShift}};
    {{- else}}
	word{{.WordIndex}} |= (uint64_t)o->bools>>({{.BoolIndex}}-{{.WordShift}}) & (uint64_t)0xff<<{{.WordShift}};
    {{- end}}
   {{- end}}

  {{- else if eq .Type "int8" "uint8" "opaque8"}}
   {{- if eq .ElementCount 0}}
    {{- if eq .WordShift 0}}
	uint64_t word{{.WordIndex}} = {{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}};
    {{- else}}
	word{{.WordIndex}} |= (uint64_t){{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}} << {{.WordShift}};
    {{- end}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
    {{- if eq .WordShift 0}}
	uint64_t word{{.WordIndex}} = {{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}}[{{$arrayIndex}}];
    {{- else}}
	word{{.WordIndex}} |= (uint64_t){{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}}[{{$arrayIndex}}] << {{.WordShift}};
    {{- end}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int16"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = (uint16_t)(o->{{.NameNative}} >> 15) ^ (uint16_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = (uint16_t)(o->{{.NameNative}}[{{$arrayIndex}}] >> 15) ^ (uint16_t)(o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int32"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = (uint32_t)(o->{{.NameNative}} >> 31) ^ (uint32_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = (uint32_t)(o->{{.NameNative}}[{{$arrayIndex}}] >> 31) ^ (uint32_t)(o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int64"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = (o->{{.NameNative}} >> 63) ^ (o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = (o->{{.NameNative}}[{{$arrayIndex}}] >> 63) ^ (o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float32"}}
   {{- if eq .ElementCount 0}}
	union f32m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}};
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal32" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	union f32m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}}[{{$arrayIndex}}];
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal32" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float64"}}
   {{- if eq .ElementCount 0}}
	union f64m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}};
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	union f64m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}}[{{$arrayIndex}}];
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "timestamp"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.tv_sec;
	v{{.Index}} <<= 30;
	v{{.Index}} |= o->{{.NameNative}}.tv_nsec;
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}].tv_sec;
	v{{.Index}} <<= 30;
	v{{.Index}} |= o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec;
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque16"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal16" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal16" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque32"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal32" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal32" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque64"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "text"}}
   {{- if eq .ElementCount 0}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.len;
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	uint64_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}].len;
{{template "marshal-integer" .}}
   {{- end}}{{end}}{{end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* not list */}}
{{- end}}{{/* field range */}}

{{- if or .HasText .HasList}}

	// copy payloads
	const uint8_t *max = p + COLFER_MAX;
 {{- range .FieldsReversed}}
  {{- if eq .Type "uint8" "opaque8"}}
   {{- if .TypeList}}
	{
		size_t size = o->{{.NameNative}}.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}
   {{- end}}

  {{- else if eq .Type "float32" "opaque32"}}
   {{- if .TypeList}}
	{
		size_t size = o->{{.NameNative}}.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}
   {{- end}}

  {{- else if eq .Type "float64" "opaque64"}}
   {{- if .TypeList}}
	{
		size_t size = o->{{.NameNative}}.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}
   {{- end}}

  {{- else if eq .Type "timestamp"}}
   {{- if .TypeList}}
	{
		size_t i = o->{{.NameNative}}.len;
		size_t size = i * 8;
		if (max - p < size) return 0;
		while (i--) {
			uint64_t v = (uint64_t)o->{{.NameNative}}.list[i].tv_sec << 30;
			v |= o->{{.NameNative}}.list[i].tv_nsec;
			memcpy(p, &v, 8);
			p += 8;
		}
	}
   {{- end}}

  {{- else if eq .Type "text"}}
   {{- if .TypeList}}
	for (size_t i = o->{{.NameNative}}.len; i-- != 0; ) {
		// TODO: encode size
	}
	for (size_t i = o->{{.NameNative}}.len; i-- != 0; ) {
		size_t size = o->{{.NameNative}}.list[i].len;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list[i].utf8, size);
		p += size;
	}
   {{- else if eq .ElementCount 0}}
	{
		size_t size = o->{{.NameNative}}.len;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.utf8, size);
		p += size;
	}
   {{- else}}{{range $arrayIndex, $element := .Elements}}
	{
		size_t size = o->{{.NameNative}}[{{$arrayIndex}}].len;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}[{{$arrayIndex}}].utf8, size);
		p += size;
	}
   {{- end}}{{end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

	const size_t size = p - (uint8_t *)start;
	const size_t variable_size = size - {{.FixedSize}};
	word0 |= variable_size << 17;

{{- range .FixedWordIndices}}
	memcpy((uint8_t *)start + ({{.}} * 8), &word{{.}}, 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	memcpy((uint8_t *)start + ({{$index}} * 8), &word{{$index}}, {{.FixedWordRemainderSize}});
{{- end}}

	return size;
}

size_t
{{.NameNative}}_unmarshal(struct {{.NameNative}}* o, const void* start) {
{{- range .FixedWordIndices}}
	uint64_t word{{.}};
	memcpy(&word{{.}}, (uint8_t *)start + ({{.}} * 8), 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	uint64_t word{{$index}};
	memcpy(&word{{$index}}, (uint8_t *)start + ({{$index}} * 8), {{.FixedWordRemainderSize}});
{{- end}}

	const size_t fixed_size = (word0 & 0xffff) + 4;
	// read cursor at variable section
	const uint8_t *p = (const uint8_t *)start + fixed_size;
	size_t variable_size = word0 >> 17 & 0x7f;
	if ((word0 & 0x10000) == 0) {
		if ((word0 & 0x20000) == 0) return 0;
		variable_size = variable_size >> 1 | (size_t)*p++ << 6;
	}
	const size_t size = fixed_size + variable_size;


{{- range .Fields}}

	// unpack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}.len = v{{.Index}};
 {{- else}}{{/* not list */}}
  {{- if eq .Type "bool"}}

   {{- if .FirstInBitField}}
    {{- if eq .BoolIndex 0}}
	o->bools = word{{.WordIndex}} >> {{.WordShift}} & 0xff;
    {{- else}}
     {{- if le .BoolIndex .WordShift}}
	o->bools = word{{.WordIndex}} >> {{.WordShift}}-{{.BoolIndex}} & 0xff<<{{.BoolIndex}};
     {{- else}}
	o->bools = word{{.WordIndex}} << {{.BoolIndex}}-{{.WordShift}} & 0xff<<{{.BoolIndex}};
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "int8" "uint8" "opaque8"}}
   {{- if eq .ElementCount 0}}
	o->{{.NameNative}} = word{{.WordIndex}} >> {{.WordShift}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	o->{{.NameNative}}[{{$arrayIndex}}] = word{{.WordIndex}} >> {{.WordShift}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int16"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int16_t)(v{{.Index}} >> 1) ^ -(int16_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int16_t)(v{{.Index}} >> 1) ^ -(int16_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int32"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int32_t)(v{{.Index}} >> 1) ^ -(int32_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int32_t)(v{{.Index}} >> 1) ^ -(int32_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int64_t)(v{{.Index}} >> 1) ^ -(int64_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int64_t)(v{{.Index}} >> 1) ^ -(int64_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float32"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
	union f32m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}} = m{{.Index}}.f;
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
	union f32m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}}[{{$arrayIndex}}] = m{{.Index}}.f;
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
	union f64m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}} = m{{.Index}}.f;
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	union f64m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}}[{{$arrayIndex}}] = m{{.Index}}.f;
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "timestamp"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}.tv_sec = v{{.Index}} >> 30;
	o->{{.NameNative}}.tv_nsec = (1<<30) - 1 & v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}[{{$arrayIndex}}].tv_sec = v{{.Index}} >> 30;
	o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec = (1<<30) - 1 & v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque16"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal16" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal16" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque32"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "text"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}.len = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}].len = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* not list */}}
{{- end}}{{/* field range */}}

	// clear/undo absent fields
	if (fixed_size < {{.FixedSize}}) {
		switch (fixed_size) {
		default:
			return 0;
{{- range .Fields}}
 {{- if eq .Index 0}}
  {{- continue}}{{/* one field required */}}
 {{- end}}
 {{- if eq .Type "bool"}}{{- if not .FirstInBitField}}
  {{- continue}}{{/* packed per eight */}}
 {{- end}}{{end}}
		case {{.FixedIndex}}:

 {{- if .TypeList}}
			o->{{.NameNative}}.len = 0;

 {{- else if eq .Type "bool"}}
			o->bools &= (1 << {{.BoolIndex}}) - 1;

 {{- else if eq .Type "timestamp"}}
  {{- if eq .ElementCount 0}}
			o->{{.NameNative}}.tv_sec = 0;
			o->{{.NameNative}}.tv_nsec = 0;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
			o->{{.NameNative}}[{{$arrayIndex}}].tv_sec = 0;
			o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec = 0;
  {{- end}}{{end}}

 {{- else if eq .Type "text"}}
  {{- if eq .ElementCount 0}}
			o->{{.NameNative}}.len = 0;
			o->{{.NameNative}}.utf8 = 0;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
			o->{{.NameNative}}[{{$arrayIndex}}].len = 0;
			o->{{.NameNative}}[{{$arrayIndex}}].utf8 = 0;
  {{- end}}{{end}}

 {{- else}}
  {{- if eq .ElementCount 0}}
			o->{{.NameNative}} = 0;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
			o->{{.NameNative}}[{{$arrayIndex}}] = 0;
  {{- end}}{{end}}

 {{- end}}{{/* type select */}}
{{- end}}{{/* field range */}}
		}{{/* switch */}}
	}{{/* absent fields */}}

{{- if or .HasText .HasList}}{{/* has payloads */}}

	// copy payloads
	size_t offset = size;
 {{- range .FieldsReversed}}
  {{- if eq .Type "opaque8" "opaque16" "opaque32" "opaque64" "float32" "float64"}}
   {{- if .TypeList}}
	offset = satsub(offset, o->{{.NameNative}}.len * sizeof({{.TypeNative}}));
   {{- end}}

  {{- else if eq .Type "timestamp"}}
   {{- if .TypeList}}
	offset = satsub(offset, o->{{.NameNative}}.len * 8);
   {{- end}}

  {{- else if eq .Type "text" -}}
   {{- if .TypeList}}
	// TODO: unmarshal text list
   {{- else if eq .ElementCount 0}}
	offset = satsub(offset, o->{{.NameNative}}.len);
   {{- else}}
    {{- range $arrayIndex, $element := .Elements}}
	offset = satsub(offset, o->{{.NameNative}}[{{$arrayIndex}}].len);
    {{- end}}
   {{- end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* field range */}}
	uint8_t *split = (uint8_t *)start + offset;
	if (split < p) return 0;
	p = split;
 {{range .FieldsReversed}}
  {{- if eq .Type "opaque8"}}
   {{- if .TypeList}}
	if (o->{{.NameNative}}.len != 0) {
		size_t len = o->{{.NameNative}}.len;
		o->{{.NameNative}}.list = malloc(len);
		memcpy(o->{{.NameNative}}.list, p, len);
		p += len;
	}
   {{- end}}

  {{- else if eq .Type "opaque16"}}
   {{- if .TypeList}}
	if (o->{{.NameNative}}.len != 0) {
		size_t len = o->{{.NameNative}}.len;
		o->{{.NameNative}}.list = malloc(len * 2);
		memcpy(o->{{.NameNative}}.list, p, len * 2);
		p += len * 2;
	}
   {{- end}}

  {{- else if eq .Type "float32" "opaque32"}}
   {{- if .TypeList}}
	if (o->{{.NameNative}}.len != 0) {
		size_t len = o->{{.NameNative}}.len;
		o->{{.NameNative}}.list = malloc(len * 4);
		memcpy(o->{{.NameNative}}.list, p, len * 4);
		p += len * 4;
	}
   {{- end}}

  {{- else if eq .Type "float64" "opaque64"}}
   {{- if .TypeList}}
	if (o->{{.NameNative}}.len != 0) {
		size_t len = o->{{.NameNative}}.len;
		o->{{.NameNative}}.list = malloc(len * 8);
		memcpy(o->{{.NameNative}}.list, p, len * 8);
		p += len * 8;
	}
   {{- end}}

  {{- else if eq .Type "timestamp"}}
   {{- if .TypeList}}
	if (o->{{.NameNative}}.len != 0) {
		size_t len = o->{{.NameNative}}.len;
		o->{{.NameNative}}.list = malloc(len * sizeof({{.TypeNative}}));
		const uint64_t *view = (uint64_t *)p;
		p += len * 8;
		for (size_t i = o->{{.NameNative}}.len; i--; ) {
			o->{{.NameNative}}.list[i].tv_sec = view[i] >> 30;
			o->{{.NameNative}}.list[i].tv_nsec = view[i] & (1<<30) - 1;
		}
	}
   {{- end}}

  {{- else if eq .Type "text"}}
   {{- if .TypeList}}

	if (o->{{.NameNative}}.len != 0) {
		o->{{.NameNative}}.list = malloc(o->{{.NameNative}}.len);

		// TODO: parse text sizes

		for (int i = 0; i < o->{{.NameNative}}.len; i++) {
			char *s = malloc(o->{{.NameNative}}.list[i].len + 1);
			memcpy(s, p, o->{{.NameNative}}.len);
			s[o->{{.NameNative}}.list[i].len] = 0; // null terminator
			o->{{.NameNative}}.list[i].utf8 = s;
		}
	}
   {{- else if eq .ElementCount 0}}

	{
		size_t len = o->{{.NameNative}}.len;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->{{.NameNative}}.utf8 = s;
		p += len;
	}
   {{- else}}{{/* is array */}}
    {{range $arrayIndex, $element := .Elements}}
	{
		size_t len = o->{{.NameNative}}[{{$arrayIndex}}].len ;
		char *s = malloc(len + 1);
		memcpy(s, p, len);
		s[len] = 0; // null terminator
		o->{{.NameNative}}[{{$arrayIndex}}].utf8 = s;
		p += len;
	}
    {{- end}}
   {{- end}}{{/* is array */}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

	return size;
}

{{- end}}{{/* struct range */}}
{{- end}}{{/* package range */}}
