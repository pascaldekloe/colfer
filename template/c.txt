// Code generated by colf(1); DO NOT EDIT.
{{- range .}}
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{- end}}

#include "Colfer.h"
#include <stdint.h> // types with defined width
#include <string.h> // size_t & memcpy(3)

typedef unsigned long long word_t;

{{- if .HasFloat}}

// floating-point byte mapping
union f32m {
	float f;
	uint32_t u;
};
union f64m {
	double f;
	uint64_t u;
};

{{- end}}

const word_t COLFER_MASKS[9] = {
	0,
	0xff,
	0xffff,
	0xffffff,
	0xffffffff,
	0xffffffffff,
	0xffffffffffff,
	0xffffffffffffff,
	0xffffffffffffffff,
};

// Saturating subtract prevents overflows branchless.
static inline size_t
satsub(size_t minuend, size_t subtrahend) {
	// TODO: utilize ARM instructions
	return (minuend - subtrahend) * (minuend >= subtrahend);
}

{{- range .}}{{/* packages */}}
{{- range .Structs}}

size_t
{{.NameNative}}_marshal(const struct {{.NameNative}}* o, void* start) {
	word_t word0 = {{.FixedSize}} << 15;

	// write cursor at variable section
	uint8_t *p = (uint8_t *)start + {{.FixedSize}};
{{- range .Fields}}

	// pack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
	word_t v{{.Index}} = o->{{.NameNative}}.len;
{{template "marshal-integer" .}}
 {{- else}}{{/* not list */}}
  {{- if eq .Type "bool"}}
   {{- if .FirstInBitField}}
    {{- if eq .WordShift 0}}
	word_t word{{.WordIndex}} = (word_t)o->_flags>>{{.BoolIndex}} & 0xff;
    {{- else if le .BoolIndex .WordShift}}
	word{{.WordIndex}} |= (word_t)o->_flags<<({{.WordShift}}-{{.BoolIndex}}) & (word_t)0xff<<{{.WordShift}};
    {{- else}}
	word{{.WordIndex}} |= (word_t)o->_flags>>({{.BoolIndex}}-{{.WordShift}}) & (word_t)0xff<<{{.WordShift}};
    {{- end}}
   {{- end}}

  {{- else if eq .Type "int8" "uint8" "opaque8"}}
   {{- if eq .ElementCount 0}}
    {{- if eq .WordShift 0}}
	word_t word{{.WordIndex}} = {{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}};
    {{- else}}
	word{{.WordIndex}} |= (word_t){{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}} << {{.WordShift}};
    {{- end}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
    {{- if eq .WordShift 0}}
	word_t word{{.WordIndex}} = {{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}}[{{$arrayIndex}}];
    {{- else}}
	word{{.WordIndex}} |= (word_t){{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}}[{{$arrayIndex}}] << {{.WordShift}};
    {{- end}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque16"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal16" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal16" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque32"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal32" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal32" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque64"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int16"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = (uint16_t)(o->{{.NameNative}} >> 15) ^ (uint16_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = (uint16_t)(o->{{.NameNative}}[{{$arrayIndex}}] >> 15) ^ (uint16_t)(o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int32"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = (uint32_t)(o->{{.NameNative}} >> 31) ^ (uint32_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = (uint32_t)(o->{{.NameNative}}[{{$arrayIndex}}] >> 31) ^ (uint32_t)(o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int64"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = (o->{{.NameNative}} >> 63) ^ (o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = (o->{{.NameNative}}[{{$arrayIndex}}] >> 63) ^ (o->{{.NameNative}}[{{$arrayIndex}}] << 1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal-integer" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float32"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = (union f32m){.f = o->{{.NameNative}}}.u;
{{template "marshal32" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = (union f32m){.f = o->{{.NameNative}}[{{$arrayIndex}}]}.u;
{{template "marshal32" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float64"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = (union f64m){.f = o->{{.NameNative}}}.u;
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = (union f64m){.f = o->{{.NameNative}}[{{$arrayIndex}}]}.u;
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "timestamp"}}
   {{- if eq .ElementCount 0}}
	word_t v{{.Index}} = o->{{.NameNative}}.tv_sec;
	v{{.Index}} <<= 30;
	v{{.Index}} |= o->{{.NameNative}}.tv_nsec;
{{template "marshal64" .}}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	word_t v{{.Index}} = o->{{.NameNative}}[{{$arrayIndex}}].tv_sec;
	v{{.Index}} <<= 30;
	v{{.Index}} |= o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec;
{{template "marshal64" .}}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "text"}}
   {{- if not .ElementCount}}
	if (o->{{.NameNative}}.len > {{.Struct.UTF8Max}}) return 0;
    {{- if eq .WordShift 0}}
	word_t word{{.WordIndex}} = o->{{.NameNative}}.len;
    {{- else}}
	word{{.WordIndex}} |= (word_t)o->{{.NameNative}}.len << {{.WordShift}};
    {{- end}}

   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	if (o->{{.NameNative}}[{{$arrayIndex}}].len > {{.Struct.UTF8Max}}) return 0;
    {{- if eq .WordShift 0}}
	word_t word{{.WordIndex}} = o->{{.NameNative}}[{{$arrayIndex}}].len;
    {{- else}}
	word{{.WordIndex}} |= (word_t)o->{{.NameNative}}[{{$arrayIndex}}].len << {{.WordShift}};
    {{- end}}

   {{- end}}{{end}}{{end}}{{/* text array */}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* not list */}}
{{- end}}{{/* field range */}}

{{- if .HasPayloadSection}}

	// copy payloads
	const uint8_t *max = p + 0xfff;
 {{- range .FieldsReversed}}
  {{- if .TypeList}}
   {{- if eq .Type "uint8" "opaque8"}}
	{
		size_t size = o->{{.NameNative}}.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}

   {{- else if eq .Type "float32" "opaque32"}}
	{
		size_t size = o->{{.NameNative}}.len * 4;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}

   {{- else if eq .Type "float64" "opaque64"}}
	{
		size_t size = o->{{.NameNative}}.len * 8;
		if (max - p < size) return 0;
		memcpy(p, o->{{.NameNative}}.list, size);
		p += size;
	}

   {{- else if eq .Type "timestamp"}}
	{
		size_t i = o->{{.NameNative}}.len;
		if (max - p < i * 8) return 0;
		while (i--) {
			word_t v = (word_t)o->{{.NameNative}}.list[i].tv_sec << 30;
			v |= o->{{.NameNative}}.list[i].tv_nsec;
			memcpy(p, &v, 8);
			p += 8;
		}
	}

   {{- else if eq .Type "text"}}
	if (o->{{.NameNative}}.len) {
		size_t n = o->{{.NameNative}}.len;
		if (max - p < n) return 0;
		size_t sum = 0;
		for (size_t i = 0; i < n; i++) {
			size_t z = o->{{.NameNative}}.list[i].len;
			if (z > {{.Struct.UTF8Max}}) return 0;
			p[i] = z;
			sum += z;
		}
		p += n;
		if (max - p < sum) return 0;
		while (n--) {
			size_t z = o->{{.NameNative}}.list[n].len;
			memcpy(p, o->{{.NameNative}}.list[n].utf8, z);
			p += z;
		}
	}

   {{- end}}{{/* list type match */}}
  {{- else if eq .Type "text"}}
   {{- if eq .ElementCount 0}}
	{
		size_t z = o->{{.NameNative}}.len;
		if (max - p < z) return 0;
		memcpy(p, o->{{.NameNative}}.utf8, z);
		p += z;
	}
   {{- else}}{{range $arrayIndex, $element := .Elements}}
	{
		size_t z = o->{{.NameNative}}[{{$arrayIndex}}].len;
		if (max - p < z) return 0;
		memcpy(p, o->{{.NameNative}}[{{$arrayIndex}}].utf8, z);
		p += z;
	}
   {{- end}}{{end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

	const size_t size = p - (uint8_t *)start;
	word0 |= size << 3;

{{- range .FixedWordIndices}}
	memcpy((uint8_t *)start + ({{.}} * 8), &word{{.}}, 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	memcpy((uint8_t *)start + ({{$index}} * 8), &word{{$index}}, {{.FixedWordRemainderSize}});
{{- end}}

	return size;
}

size_t
{{.NameNative}}_unmarshal(struct {{.NameNative}}* o, const void* start{{if .HasPayloadSection}}, void* (*malloc)(size_t){{end}}) {
	const uint8_t* base = (const uint8_t*)start; // address octets
{{- range .FixedWordIndices}}
	word_t word{{.}};
	memcpy(&word{{.}}, &base[{{.}} * 8], 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	word_t word{{$index}};
	memcpy(&word{{$index}}, &base[{{$index}} * 8], {{.FixedWordRemainderSize}});
{{- end}}

	const size_t size = (size_t)(word0 >> 3) & 0xfff;
	const size_t fixed_size = (size_t)(word0 >> 15) & 0x1ff;
	if (__builtin_expect(size < fixed_size, 0)) {
		*o = (const struct {{.NameNative}}){ 0 };
		return 0;
	}

	// read cursor at variable section
	const uint8_t *p = &base[fixed_size];
	// payload cursor travels backwards
	size_t end = size;

{{- range .Fields}}

	// unpack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
  {{- if eq .Type "opaque8" "opaque16" "opaque32" "opaque64" "float32" "float64"}}
	{
		size_t n = (size_t)(word{{.WordIndex}} >> {{.WordShift}}) & 0xff;
		size_t offset = satsub(end, n * sizeof({{.TypeNative}}));
		n = (end - offset) / sizeof({{.TypeNative}});
		end = offset;

		typeof(o->{{.NameNative}}.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->{{.NameNative}}.list = NULL;
				o->{{.NameNative}}.len = 0;
{{template "malloc-error" .}}
			}
			memcpy(list, &base[offset], n * sizeof(*list));
		}

		o->{{.NameNative}}.list = list;
		o->{{.NameNative}}.len = n;
	}

  {{- else if eq .Type "timestamp"}}
	{
		size_t n = (size_t)(word{{.WordIndex}} >> {{.WordShift}}) & 0xff;
		size_t offset = satsub(end, n * 8);
		n = (end - offset) / 8;
		end = offset;

		typeof(o->{{.NameNative}}.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->{{.NameNative}}.list = NULL;
				o->{{.NameNative}}.len = 0;
{{template "malloc-error" .}}
			}
			const uint64_t *view = (const uint64_t *)&base[offset];
			for (size_t i = 0; i < n; i++) {
				list[i].tv_sec = view[i] >> 30;
				list[i].tv_nsec = view[i] & (1<<30) - 1;
			}
		}

		o->{{.NameNative}}.list = list;
		o->{{.NameNative}}.len = n;
	}

  {{- else if eq .Type "text"}}
	{
		size_t n = (size_t)(word{{.WordIndex}} >> {{.WordShift}}) & 0xff;
		size_t size_table_offset = satsub(end, n);
		n = end - size_table_offset;
		end = size_table_offset;

		typeof(o->{{.NameNative}}.list) list = NULL;
		if (n) {
			list = malloc(n * sizeof(*list));
			if (__builtin_expect(list == NULL, 0)) {
				o->{{.NameNative}}.list = NULL;
				o->{{.NameNative}}.len = 0;
{{template "malloc-error" .}}
			}

			for (size_t i = 0; i < n; i++) {
				size_t offset = satsub(end, base[size_table_offset + n]);
				size_t len = end - offset;
				end = offset;

				if (!len) {
					list[i].utf8 = NULL;
					list[i].len = 0;
					continue;
				}

				{{.TypeNative}} utf8 = malloc(len);
				if (__builtin_expect(utf8 != NULL, 1)) {
					memcpy(utf8, &base[offset], len);
					list[i].utf8 = utf8;
					list[i].len = len;
					continue;
				}

				// malloc failed
				do {
					list[i].utf8 = NULL;
					list[i].len = 0;
				} while (++i > n);
{{template "malloc-error" .}}
			}
		}

		o->{{.NameNative}}.list = list;
		o->{{.NameNative}}.len = n;
	}

  {{- end}}{{/* list type match */}}

 {{- else}}{{/* not list */}}

  {{- if eq .Type "opaque8" "uint8" "int8"}}
   {{- if not .ElementCount}}
	o->{{.NameNative}} = word{{.WordIndex}} >> {{.WordShift}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	o->{{.NameNative}}[{{$arrayIndex}}] = word{{.WordIndex}} >> {{.WordShift}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque16"}}
   {{- if not .ElementCount}}
{{template "unmarshal16" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal16" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque32"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "opaque64"}}
   {{- if not .ElementCount}}
{{template "unmarshal64" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int16"}}
   {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int16_t)(v{{.Index}} >> 1) ^ -(int16_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int16_t)(v{{.Index}} >> 1) ^ -(int16_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int32"}}
   {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int32_t)(v{{.Index}} >> 1) ^ -(int32_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int32_t)(v{{.Index}} >> 1) ^ -(int32_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "int64"}}
   {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int64_t)(v{{.Index}} >> 1) ^ -(int64_t)(v{{.Index}} & 1);
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (int64_t)(v{{.Index}} >> 1) ^ -(int64_t)(v{{.Index}} & 1);
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float32"}}
   {{- if not .ElementCount}}
{{template "unmarshal32" .}}
	o->{{.NameNative}} = (union f32m){.u = v{{.Index}}}.f;
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (union f32m){.u = v{{.Index}}}.f;
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "float64"}}
   {{- if not .ElementCount}}
{{template "unmarshal64" .}}
	o->{{.NameNative}} = (union f64m){.u = v{{.Index}}}.f;
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}[{{$arrayIndex}}] = (union f64m){.u = v{{.Index}}}.f;
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "timestamp"}}
   {{- if not .ElementCount}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}.tv_sec = v{{.Index}} >> 30;
	o->{{.NameNative}}.tv_nsec = (1<<30) - 1 & v{{.Index}};
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}[{{$arrayIndex}}].tv_sec = v{{.Index}} >> 30;
	o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec = (1<<30) - 1 & v{{.Index}};
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "text"}}
   {{- if not .ElementCount}}
	{
		size_t n = (size_t)(word{{.WordIndex}} >> {{.WordShift}}) & 0xff;
		size_t offset = satsub(end, n);
		n = end - offset;
		end = offset;

		{{.TypeNative}} utf8 = NULL;
		if (n && fixed_size > {{.FixedIndex}}) {
			utf8 = malloc(n);
			if (__builtin_expect(utf8 == NULL, 0)) {
				o->{{.NameNative}}.utf8 = NULL;
				o->{{.NameNative}}.len = 0;
{{template "malloc-error" .}}
			}
			memcpy(utf8, &base[offset], n);
		}

		o->{{.NameNative}}.utf8 = utf8;
		o->{{.NameNative}}.len = n;
	}
   {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	{
		size_t n = (size_t)(word{{.WordIndex}} >> {{.WordShift}}) & 0xff;
		size_t offset = satsub(end, n);
		n = end - offset;
		end = offset;

		{{.TypeNative}} utf8 = NULL;
		if (n && fixed_size > {{.FixedIndex}}) {
			utf8 = malloc(n);
			if (__builtin_expect(utf8 == NULL, 0)) {
				for (int i = {{$arrayIndex}}; i < {{.ElementCount}}; i++) {
					o->{{.NameNative}}[{{$arrayIndex}}].utf8 = NULL;
					o->{{.NameNative}}[{{$arrayIndex}}].len = 0;
				}
{{template "malloc-error" .}}
			}
			memcpy(utf8, &base[offset], n);
		}

		o->{{.NameNative}}[{{$arrayIndex}}].utf8 = utf8;
		o->{{.NameNative}}[{{$arrayIndex}}].len = n;
	}
   {{- end}}{{end}}{{end}}

  {{- else if eq .Type "bool"}}
   {{- if not .FirstInBitField}}
	// travels for free
   {{- else if eq .BoolIndex 0}}
	o->_flags = word{{.WordIndex}} >> {{.WordShift}} & 0xff;
   {{- else if le .BoolIndex .WordShift}}
	o->_flags = word{{.WordIndex}} >> ({{.WordShift}}-{{.BoolIndex}}) & (0xff<<{{.BoolIndex}});
   {{- else}}
	o->_flags = word{{.WordIndex}} << ({{.BoolIndex}}-{{.WordShift}}) & (0xff<<{{.BoolIndex}});
   {{- end}}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* not list */}}
{{- end}}{{/* field range */}}

	// clear/undo absent fields
	if (__builtin_expect(fixed_size < {{.FixedSize}}, 0)) switch (fixed_size) {
	default:
		*o = (const struct {{.NameNative}}){ 0 };
		return 0;
{{- range .Fields}}
 {{- if eq .Type "bool"}}{{- if not .FirstInBitField}}
  {{- continue}}{{/* packed per eight */}}
 {{- end}}{{end}}
	case {{.FixedIndex}}:

 {{- if .TypeList}}
		// checked inline allready

 {{- else if eq .Type "bool"}}
		o->_flags &= (1 << {{.BoolIndex}}) - 1;

 {{- else if eq .Type "timestamp"}}
  {{- if not .ElementCount}}
		o->{{.NameNative}}.tv_sec = 0;
		o->{{.NameNative}}.tv_nsec = 0;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
		o->{{.NameNative}}[{{$arrayIndex}}].tv_sec = 0;
		o->{{.NameNative}}[{{$arrayIndex}}].tv_nsec = 0;
  {{- end}}{{end}}

 {{- else if eq .Type "text"}}
		// checked inline allready

 {{- else if not .ElementCount}}
		o->{{.NameNative}} = 0;
 {{- else}}{{range $arrayIndex, $element := .Elements}}
		o->{{.NameNative}}[{{$arrayIndex}}] = 0;
 {{- end}}{{end}}

{{- end}}{{/* field range */}}
	}{{/* absent fields switch if */}}

	return size;
}

{{- end}}{{/* struct range */}}
{{- end}}{{/* package range */}}
