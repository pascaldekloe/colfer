// Code generated by colf(1); DO NOT EDIT.
{{- range .}}
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{- end}}

#include "Colfer.h"
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
{{- if .HasTimestamp}}
#include <time.h>
{{- end}}

{{- if .HasFloat}}

// floating-point byte mapping
union f32m {
	float f;
	uint32_t u;
};

union f64m {
	double f;
	uint64_t u;
};
{{- end}}

const uint64_t COLFER_MASKS[9] = {
	0,
	0xff,
	0xffff,
	0xffffff,
	0xffffffff,
	0xffffffffff,
	0xffffffffffff,
	0xffffffffffffff,
	0xffffffffffffffff,
};

{{- range .}}{{/* packages */}}
{{- range .Structs}}

size_t
{{.NameNative}}_marshal(const struct {{.NameNative}}* o, void* start) {
	// fixed section as 64-bit words
	uint64_t word0 = {{.FixedSize}} - 4; // 16-bit size declaration

	// write cursor at variable section
	uint8_t *p = (uint8_t*)start + {{.FixedSize}};
{{- range .Fields}}

	// pack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if not .TypeList}}
  {{- if eq .Type "bool"}}
   {{- if .FirstInBitField}}
    {{- if eq .WordShift 0}}
	uint64_t word{{.WordIndex}} = (uint64_t)o->bools>>{{.BoolIndex}} & 0xff;
    {{- else if le .BoolIndex .WordShift}}
	word{{.WordIndex}} |= (uint64_t)o->bools<<({{.WordShift}}-{{.BoolIndex}}) & (uint64_t)0xff<<{{.WordShift}};
    {{- else}}
	word{{.WordIndex}} |= (uint64_t)o->bools>>({{.BoolIndex}}-{{.WordShift}}) & (uint64_t)0xff<<{{.WordShift}};
    {{- end}}
   {{- end}}

  {{- else if eq .Type "int8" "uint8" "opaque8"}}
   {{- if eq .WordShift 0}}
	uint64_t word{{.WordIndex}} = {{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}};
   {{- else}}
	word{{.WordIndex}} |= (uint64_t){{if eq .Type "int8"}}(uint8_t){{end}}o->{{.NameNative}} << {{.WordShift}};
   {{- end}}

  {{- else if eq .Type "int16"}}
	uint64_t v{{.Index}} = (uint16_t)(o->{{.NameNative}} >> 15) ^ (uint16_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}

  {{- else if eq .Type "int32"}}
	uint64_t v{{.Index}} = (uint32_t)(o->{{.NameNative}} >> 31) ^ (uint32_t)(o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}

  {{- else if eq .Type "int64"}}
	uint64_t v{{.Index}} = (o->{{.NameNative}} >> 63) ^ (o->{{.NameNative}} << 1);
{{template "marshal-integer" .}}

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal-integer" .}}

  {{- else if eq .Type "float32"}}
   {{- if eq .ElementCount 0}}
	union f32m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}};
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal32" .}}
   {{- else}}
    {{- range $arrayIndex, $element := .Elements}}
     {{- with $element}}
	union f32m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}}[{{$arrayIndex}}];
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal32" .}}
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "float64"}}
   {{- if eq .ElementCount 0}}
	union f64m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}};
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal64" .}}
   {{- else}}
    {{- range $arrayIndex, $element := .Elements}}
     {{- with $element}}
	union f64m m{{.Index}};
	m{{.Index}}.f = o->{{.NameNative}}[{{$arrayIndex}}];
	uint64_t v{{.Index}} = m{{.Index}}.u;
{{template "marshal64" .}}
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "timestamp"}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.tv_sec;
	v{{.Index}} <<= 30;
	v{{.Index}} |= o->{{.NameNative}}.tv_nsec;
{{template "marshal64" .}}

  {{- else if eq .Type "opaque16"}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal16" .}}

  {{- else if eq .Type "opaque32"}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal32" .}}

  {{- else if eq .Type "opaque64"}}
	uint64_t v{{.Index}} = o->{{.NameNative}};
{{template "marshal64" .}}

  {{- else if eq .Type "text" "opaque"}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.len;
{{template "marshal-integer" .}}

  {{- end}}{{/* type match */}}
 {{- else}}{{/* is list */}}
	uint64_t v{{.Index}} = o->{{.NameNative}}.len;
{{template "marshal-integer" .}}

 {{- end}}{{/* is list */}}
{{- end}}{{/* field range */}}

{{- if or .HasText .HasOpaque}}

	// copy payloads
 {{- range .FieldsReversed}}
  {{- if eq .Type "text" "opaque"}}
   {{- if .TypeList}}
   {{- else}}
	if (o->{{.NameNative}}.len > COLFER_MAX - (p - (uint8_t*)start))
		return 0;
	memcpy(p, o->{{.NameNative}}.{{if eq .Type "text"}}utf8{{else}}octets{{end}}, o->{{.NameNative}}.len);
	p += o->{{.NameNative}}.len;
   {{- end}}
  {{- end}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

	size_t size = p - (uint8_t*)start;

	// finish header
	word0 |= (uint64_t)(size - {{.FixedSize}}) << 17 | (1 << 16);
{{- range .FixedWordIndices}}
	memcpy((uint8_t*)start + ({{.}} * 8), &word{{.}}, 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	memcpy((uint8_t*)start + ({{$index}} * 8), &word{{$index}}, {{.FixedWordRemainderSize}});
{{- end}}

	return size;
}

size_t
{{.NameNative}}_unmarshal(struct {{.NameNative}}* o, const void* start) {
	// words of fixed section
{{- range .FixedWordIndices}}
	uint64_t word{{.}};
	memcpy(&word{{.}}, (uint8_t *)start + ({{.}} * 8), 8);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
	uint64_t word{{$index}};
	memcpy(&word{{$index}}, (uint8_t *)start + ({{$index}} * 8), {{.FixedWordRemainderSize}});
{{- end}}

	// read cursor at variable section
	uint8_t* p = (uint8_t*)start + (word0 & 0xffff) + 4;

	uint64_t v = word0 >> 17 & 0x7f;
	if (((uint64_t)1 << 16 & word0) == 0) {
		uint64_t tz = __builtin_ctz(v | 0x80) + 1;
		v <<= (tz << 3) - tz;
		v &= ~COLFER_MASKS[tz];
		uint64_t tail;
		memcpy(&tail, p, 8);
		v |= tail & COLFER_MASKS[tz];
		p += tz;
	}
	if (v > COLFER_MAX) return 0;
	size_t size = v + (word0 & 0xffff) + 4;

{{- range .Fields}}

	// unpack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if not .TypeList}}
  {{- if eq .Type "bool"}}

   {{- if .FirstInBitField}}
    {{- if eq .BoolIndex 0}}
	o->bools = word{{.WordIndex}} >> {{.WordShift}} & 0xff;
    {{- else}}
     {{- if le .BoolIndex .WordShift}}
	o->bools = word{{.WordIndex}} >> {{.WordShift}}-{{.BoolIndex}} & 0xff<<{{.BoolIndex}};
     {{- else}}
	o->bools = word{{.WordIndex}} << {{.BoolIndex}}-{{.WordShift}} & 0xff<<{{.BoolIndex}};
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "int8" "uint8" "opaque8"}}
	o->{{.NameNative}} = word{{.WordIndex}} >> {{.WordShift}};

  {{- else if eq .Type "int16"}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int16_t)(v{{.Index}} >> 1) ^ -(int16_t)(v{{.Index}} & 1);

  {{- else if eq .Type "int32"}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int32_t)(v{{.Index}} >> 1) ^ -(int32_t)(v{{.Index}} & 1);

  {{- else if eq .Type "int64"}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = (int64_t)(v{{.Index}} >> 1) ^ -(int64_t)(v{{.Index}} & 1);

  {{- else if eq .Type "uint16" "uint32" "uint64"}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}} = v{{.Index}};

  {{- else if eq .Type "float32"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
	union f32m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}} = m{{.Index}}.f;
   {{- else}}
    {{- range $arrayIndex, $element := .Elements}}
     {{- with $element}}
{{template "unmarshal32" .}}
	union f32m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}}[{{$arrayIndex}}] = m{{.Index}}.f;
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "float64"}}
   {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
	union f64m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}} = m{{.Index}}.f;
   {{- else}}
    {{- range $arrayIndex, $element := .Elements}}
     {{- with $element}}
{{template "unmarshal64" .}}
	union f64m m{{.Index}};
	m{{.Index}}.u = v{{.Index}};
	o->{{.NameNative}}[{{$arrayIndex}}] = m{{.Index}}.f;
     {{- end}}
    {{- end}}
   {{- end}}

  {{- else if eq .Type "timestamp"}}
{{template "unmarshal64" .}}
	o->{{.NameNative}}.tv_sec = v{{.Index}} >> 30;
	o->{{.NameNative}}.tv_nsec = (1<<30) - 1 & v{{.Index}};

  {{- else if eq .Type "opaque16"}}
{{template "unmarshal16" .}}
	o->{{.NameNative}} = v{{.Index}};

  {{- else if eq .Type "opaque32"}}
{{template "unmarshal32" .}}
	o->{{.NameNative}} = v{{.Index}};

  {{- else if eq .Type "opaque64"}}
{{template "unmarshal64" .}}
	o->{{.NameNative}} = v{{.Index}};

  {{- else if eq .Type "text" "opaque"}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}.len = v{{.Index}};

  {{- end}}{{/* type match */}}

 {{- else}}{{/* is list */}}
{{template "unmarshal-integer" .}}
	o->{{.NameNative}}.len = v{{.Index}};

 {{- end}}{{/* is list */}}
{{- end}}{{/* field range */}}

	// clear/undo absent fields
	if ((word0 & 0xffff) < {{.FixedSize}} - 4) {
		switch (word0 & 0xffff) {
		default:
			return 0;
{{- range .Fields}}
 {{- if eq .Index 0}}{{/* first field required */}}{{continue}}{{end}}
 {{- if eq .Type "bool"}}{{- if not .FirstInBitField}}{{continue}}{{end}}{{end}}
		case {{.FixedIndex}} - 4:
 {{- if eq .Type "bool"}}
			o->bools &= (1 << {{.BoolIndex}}) - 1;
 {{- else if eq .Type "timestamp"}}
			o->{{.NameNative}}.tv_sec = 0;
			o->{{.NameNative}}.tv_nsec = 0;
 {{- else if eq .Type "text" "opaque"}}
			o->{{.NameNative}}.len = 0;
 {{- else if .TypeList}}
			o->{{.NameNative}}.len = 0;
 {{- else}}
  {{- if eq .ElementCount 0}}
			o->{{.NameNative}} = 0;
  {{- else}}
   {{- range $arrayIndex, $element := .Elements}}
			o->{{.NameNative}}[{{$arrayIndex}}] = 0;
   {{- end}}
  {{- end}}
 {{- end}}
{{- end}}
		}
	}

{{- if or .HasText .HasOpaque}}
	// copy payloads
	uint8_t *end = (uint8_t *)start + size;
	uint8_t *offset = end;
	{{range .FieldsReversed}}{{if eq .Type "text" "opaque" -}}
	offset -= o->{{.NameNative}}.len;
	{{- end}}{{end}};
	if (offset < p) return 0;
 {{- range .FieldsReversed}}
  {{if eq .Type "text"}}
   {{- if not .TypeList}}
	{
		char *s = malloc(o->{{.NameNative}}.len + 1);
		memcpy(s, offset, o->{{.NameNative}}.len);
		s[o->{{.NameNative}}.len] = 0; // null terminator
		o->{{.NameNative}}.utf8 = s;
		offset += o->{{.NameNative}}.len;
	}

   {{- else}}
	if (o->{{.NameNative}}.len != 0) {
		o->{{.NameNative}}.list = malloc(o->{{.NameNative}}.len);

		// TODO: parse text sizes

		for (int i = 0; i < o->{{.NameNative}}.len; i++) {
			char *s = malloc(o->{{.NameNative}}.list[i].len + 1);
			memcpy(s, offset, o->{{.NameNative}}.len);
			s[o->{{.NameNative}}.list[i].len] = 0; // null terminator
			o->{{.NameNative}}.list[i].utf8 = s;
		}
	}

   {{- end}}
  {{- else if eq .Type "opaque"}}
   {{- if not .TypeList}}
	if (o->{{.NameNative}}.len) {
		o->{{.NameNative}}.octets = malloc(o->{{.NameNative}}.len);
		memcpy(o->{{.NameNative}}.octets, offset, o->{{.NameNative}}.len);
		offset += o->{{.NameNative}}.len;
	} else o->{{.NameNative}}.octets = NULL;

   {{- else}}
	{
		// TODO
	}

   {{- end}}
  {{- end}}{{/* type match */}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

	return size;
}

{{- end}}{{/* struct range */}}
{{- end}}{{/* package range */}}
