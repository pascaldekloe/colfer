// Code generated by colf(1); DO NOT EDIT.
{{- range .}}
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{- end}}

#ifndef COLFER_H
#define COLFER_H

#include <limits.h>
#include <stdint.h>
#include <string.h>
{{- if .HasTimestamp}}
#include <time.h>
{{end}}

#if CHAR_BIT != 8
#error "octet byte size"
#endif

#ifdef __cplusplus
extern "C" {
#endif


// colfer_size_max is the upper limit for serial octet sizes.
extern size_t colfer_size_max;

// colfer_list_max is the upper limit for the number of elements in a list.
extern size_t colfer_list_max;


// colfer_text is a UTF-8 CLOB.
typedef struct {
	const char*  utf8;
	size_t       len;
} colfer_text;

// colfer_binary is a BLOB.
typedef struct {
	uint8_t* octets;
	size_t   len;
} colfer_binary;

{{range .}}{{range .Structs}}
typedef struct {{.NameNative}} {{.NameNative}};
{{end}}{{end}}
{{range .}}{{range .Structs}}
{{.DocText "// "}}
struct {{.NameNative}} {
{{- range .Fields}}
{{.DocText "\t// "}}{{- if .TypeList}}
 {{- if eq .Type "float32"}}
	struct {
		float* list;
		size_t len;
	}
 {{- else if eq .Type "float64"}}
	struct {
		double* list;
		size_t len;
	}
 {{- else if eq .Type "binary" "text"}}
	struct {
		colfer_{{.Type}}* list;
		size_t len;
	}
 {{- else}}
	struct {
		struct {{.TypeRef.NameNative}}* list;
		size_t len;
	}
 {{- end}}
{{- else}}
 {{- if eq .Type "timestamp"}}
	struct {{.TypeNative}}
 {{- else if .TypeRef}}
	{{.TypeRef.NameNative}}*
 {{- else}}
	{{.TypeNative}}
 {{- end}}
{{- end}} {{.NameNative}};
{{- end}}
};

// {{.NameNative}}_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t {{.NameNative}}_marshal_len(const {{.NameNative}}* o);

// {{.NameNative}}_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t {{.NameNative}}_marshal(const {{.NameNative}}* o, void* buf);

// {{.NameNative}}_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t {{.NameNative}}_unmarshal({{.NameNative}}* o, const void* data, size_t datalen);
{{end}}{{end}}

#ifdef __cplusplus
} // extern "C"
#endif

#endif
