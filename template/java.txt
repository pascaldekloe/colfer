package {{.Pkg.NameNative}};

// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file {{.Pkg.SchemaFileList}}.

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.StreamCorruptedException;
import java.io.WriteAbortedException;
import java.lang.reflect.Field;
{{- if .HasText}}
import static java.nio.charset.StandardCharsets.UTF_8;
{{- end}}
{{- if .HasTimestamp}}
import java.time.Instant;
{{- end}}
{{- if .HasList}}
import java.util.Arrays;
{{- end}}

/**
{{- if .Docs}}
{{.DocText " * "}}
{{- end}}
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
{{- range .TagAdd}}
{{.}}
{{- end}}
{{$class := .NameNative}}public class {{$class}}
{{- if .Pkg.SuperClass}}
extends {{.Pkg.SuperClass}}
{{- end}}
implements Serializable{{range .Pkg.Interfaces}}, {{.}}{{end}} {

{{- if .HasBool}}
 {{- range .Fields}}
  {{- if eq .Type "bool"}}
{{/* new line */}}
   {{- if .Docs}}
	/**
{{.DocText "\t * "}}
	 */
   {{- end}}{{/* has docs */}}
	public static final int {{upperSnake .NameNative}}_FLAG = 1 << {{.BoolIndex}};
  {{- end}}{{/* is boolean */}}
 {{- end}}{{/* field range */}}

	/**
	 * Bit field for the booleans defined as *{@code _FLAG} constants above.
	 */
	public int _flags;
{{- end}}{{/* has boolean */}}


{{- range .Fields}}
 {{- if eq .Type "bool"}}{{continue}}{{end}}
{{/* new line */}}
 {{- if .Docs}}
	/**
{{.DocText "\t * "}}
	 */
 {{- end}}{{/* has docs */}}
 {{- range .TagAdd}}
	{{.}}
 {{- end}}{{/* tag range */}}
	public {{if .ElementCount}}final {{end}}{{.TypeNative}}{{if or .TypeList .ElementCount}}[]{{end}} {{.NameNative}}
 {{- if .ElementCount}} = new {{.TypeNative}}[{{.ElementCount}}]
 {{- else if .TypeList}} = zero_{{.NameNative}}
 {{- else if eq .Type "timestamp"}} = Instant.EPOCH
 {{- else if eq .Type "text"}} = ""
 {{- end}};
{{- end}}{{/* field range */}}

{{- if .HasList}}
 {{- range .Fields}}
  {{- if .TypeList}}
	private static final {{.TypeNative}}[] zero_{{.NameNative}} = new {{.TypeNative}}[0];
  {{- end}}{{/* is list */}}
 {{- end}}{{/* field range */}}
{{- end}}{{/* has list */}}

	// Colfer internals
	private static final int FIXED_SIZE = {{.FixedSize}};
	private static final int OVERFLOW_MAX = {{.OverflowMax}};
	private static final long[] COLFER_MASKS = {
		0,
		0xffL,
		0xffffL,
		0xffffffL,
		0xffffffffL,
		0xffffffffffL,
		0xffffffffffffL,
		0xffffffffffffffL,
		0xffffffffffffffffL,
	};
	private static final sun.misc.Unsafe java_unsafe;
	static {
		try {
			Field f = Class.class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
			f.setAccessible(true);
			java_unsafe = (sun.misc.Unsafe) f.get(null);
		} catch (Exception e) {
			throw new Error("Java unsafe API required", e);
		}
	}

	/**
	 * Encodings of this data structure have {{.HeaderSize}} bytes of overhead.
	 * @see "Colfer's “{{.SizeProfile}} profile” header"
	 * @see #COLFER_MAX
	 */
	public static final int COLFER_MIN = {{.HeaderSize}};

	/**
	 * Encodings of this data structure are limited to {{.SizeMaxSI}} in size.
	 * The actual limit for this specific version (as defined by {@link
	 * #MARSHAL_MAX}) could be less.
	 * @see "Colfer's “{{.SizeProfile}} profile” limits"
	 * @see #COLFER_MIN
	 */
	public static final int COLFER_MAX = {{.SizeMax}};

	/**
	 * Encodings of this specific version of the data structure consist of
	 * {{if .HasVariableSection}}at most{{else}}exactly{{end}} {@code MARSHAL_MAX} bytes.
	 * @see #MARSHAL_BUF_MAX
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_MAX = {{if .HasPayloadSection}}COLFER_MAX{{else}}FIXED_SIZE + OVERFLOW_MAX{{end}};

	/**
	 * Output buffers must have a capacity of at least this byte count.
	 * The threshold can be higher than {@link #MARSHAL_MAX} in some cases.
	 * @see #MARSHAL_BUF_MAX
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_BUF_MIN = (FIXED_SIZE + OVERFLOW_MAX + 7) & ~7;

	/**
	 * Output buffer capacity beyound this byte count won't affect encoding.
	 * {@link #MARSHAL_BUF_MIN} ≤ {@code MARSHAL_BUF_MAX}
	 * @see #MARSHAL_MAX
	 * @see #MARSHAL_BUF_MIN
	 * @see #marshal(byte[],int)
	 */
	public static final int MARSHAL_BUF_MAX = java.lang.Math.max(MARSHAL_MAX, MARSHAL_BUF_MIN);

	/**
	 * Unmarshal buffers must have a capacity of at least this byte count.
	 * {@link #COLFER_MIN} ≤ {@code UNMARSHAL_BUF_MIN} ≤ {@link #COLFER_MAX}
	 * @see #unmarshal(byte[],int,int)
	 */
	public static final int UNMARSHAL_BUF_MIN = ({{.FixedMax}} + OVERFLOW_MAX + 7) & ~7;

	/** Default constructor. */
	public {{.NameNative}}() { }

{{- if .Pkg.CodeSnippet}}

	// BEGIN Code Snippet Injection

{{.Pkg.CodeSnippet}}

	// END Code Snippet Injection
{{- end}}

	/** {@link java.io.InputStream} reader. */
	public static class Unmarshaller {

		/** The data source. */
		private final InputStream in;

		/** The read buffer. */
		private final byte[] buf;

		/** The start index in {@link #buf}. */
		private int off;

		/** The number of bytes in {@link #buf} (since {@link #off}). */
		private int len;


		/**
		 * Deserializes the following object.
		 * @param in the data source.
		 * @param bufn the buffer size in bytes.
		 */
		public Unmarshaller(InputStream in, int bufn) {
			this.in = in;
			this.buf = new byte[bufn < COLFER_MAX ? COLFER_MAX : bufn];
		}

		/**
		 * Unmarshals next in line.
		 * @return the result or {@code null} when EOF.
		 * @throws java.io.IOException from the {@code java.io.InputStream}.
		 * @throws java.io.EOFException on a partial record.
		 * @throws java.io.StreamCorruptedException when the data does not match this object's schema.
		 */
		public {{$class}} nextOrNull() throws IOException {
			if (len == 0) {
				off = 0;
				if (!read()) return null; // EOF
			} else if (buf.length - off < COLFER_MIN) {
				System.arraycopy(buf, off, buf, 0, len);
				off = 0;
			}

			{{$class}} o = new {{$class}}();
			while (true) {
				int size = o.unmarshal(buf, off, len);
				if (size > 3) {
					off += size;
					len -= size;
					return o;
				}
				if (size != 0)
					throw new StreamCorruptedException("illegal Colfer encoding");
				if (off != 0) {
					System.arraycopy(buf, off, buf, 0, len);
					off = 0;
				}
				if (!read())
					throw new EOFException("partial Colfer encoding");
			}
		}

		/** Buffer more data. The return is {@code false} on EOF. */
		private boolean read() throws IOException {
			int pos = this.off + this.len;
			int n = in.read(buf, pos, buf.length - pos);
			if (n < 0) return false;
			this.len += n;
			return true;
		}

	}

	/**
	 * Writes the Colfer encoding of {@code this} data structure to a buffer
	 * at an offset. Marshalling requires at least {@link #MARSHAL_BUF_MIN}
	 * of space since the offset, as in {@code buf.length} − {@code off} ≥
	 * {@code {{.NameNative}}.MARSHAL_BUF_MIN}.
	 * Preferably, use {@link #MARSHAL_BUF_MAX}—not {@link #MARSHAL_MAX}—to
	 * prevent any buffer overflows from happening.
	 *
{{- if not .HasVariableSection}}
	 * Encoding of this specific version of the data structure always
	 * succeeds with a return of exactly {@link #MARSHAL_MAX}. However,
	 * future revisions may return zero ({@code 0) on any the following.
{{- else}}
	 * The return is zero ({@code 0}) on any of the following, exclusively.
{{- end}}
	 * <ul>
	 * <li>buffer overflow—only possible below {@link #MARSHAL_BUF_MAX}
	 * <li>{@link #COLFER_MAX} exceeded{{if not .HasVariableSection}}—not possible yet{{end}}
	 * <li>a text exceeds {{.UTF8Max}} bytes of UTF-8{{if not .HasText}}—none present yet{{end}}
	 * <li>a list exceeds {{.ListMax}} entries{{if not .HasList}}—none present yet{{end}}
	 * </ul>
	 *
	 * @param buf the output buffer.
	 * @param off the start index [offset] in the buffer.
	 * @return either the encoding size or {@code 0}.
	 * @throws IllegalArgumentException on {@link #MARSHAL_BUF_MIN} breach.
	 */
	public int marshal(byte[] buf, int off) {
		if (off < 0 || buf.length - off < MARSHAL_BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");

		// write index at variable section
		int w = off + FIXED_SIZE;
		long word0 = FIXED_SIZE << 15;

{{- range .Fields}}

		// pack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
  {{- if not .TypeRef}}
		if (this.{{.NameNative}}.length > {{.Struct.ListMax}})
			return 0;
   {{- if not .WordShift}}
		long word{{.WordIndex}} = (long)this.{{.NameNative}}.length;
   {{- else}}
		word{{.WordIndex}} |= (long)this.{{.NameNative}}.length << {{.WordShift}};
   {{- end}}
  {{- end}}{{/* not struct list */}}

 {{- else if eq .Type "opaque8" "uint8" "int8"}}
  {{- if not .ElementCount}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = Byte.toUnsignedLong(this.{{.NameNative}});
   {{- else}}
		word{{.WordIndex}} |= Byte.toUnsignedLong(this.{{.NameNative}}) << {{.WordShift}};
   {{- end}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = Byte.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
   {{- else}}
		word{{.WordIndex}} |= Byte.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]) << {{.WordShift}};
   {{- end}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}});
{{template "marshal16" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal16" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}});
{{template "marshal32" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal32" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}};
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}});
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}});
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}};
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}>>15 ^ this.{{.NameNative}}<<1);
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]>>15 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}>>31 ^ this.{{.NameNative}}<<1);
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]>>31 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}}>>63 ^ this.{{.NameNative}}<<1;
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}]>>63 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1;
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "float32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(Float.floatToRawIntBits(this.{{.NameNative}}));
{{template "marshal32" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(Float.floatToRawIntBits(this.{{.NameNative}}[{{$arrayIndex}}]));
{{template "marshal32" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "float64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Double.doubleToRawLongBits(this.{{.NameNative}});
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Double.doubleToRawLongBits(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "timestamp"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}}.getEpochSecond() << 30 | Integer.toUnsignedLong(this.{{.NameNative}}.getNano());
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}].getEpochSecond() << 30 | Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}].getNano());
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}


 {{- else if eq .Type "text"}}
  {{- if .ElementCount}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = 0;
   {{- end}}
  {{- else}}{{range .Elements}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = 0;
   {{- end}}
  {{end}}{{end}}{{/* is array */}}
  {{- /* payload plus size declaration done below */}}

 {{- else if eq .Type "bool"}}
  {{- if not .FirstInBitField}}
		// travels for free
  {{- else if not .WordShift}}
		long word{{.WordIndex}} = this._flags>>>{{.BoolIndex}} & 0xff;
  {{- else if le .BoolIndex .WordShift}}
		word{{.WordIndex}} |= (long)this._flags << {{.WordShift}}-{{.BoolIndex}} & 0xffl<<{{.WordShift}};
  {{- else}}
		word{{.WordIndex}} |= (long)this._flags >>> {{.BoolIndex}}-{{.WordShift}} & 0xffl<<{{.WordShift}};
  {{- end}}

 {{- else if .TypeRef}}
		// TODO: embedded structures

 {{- end}}{{/* type match */}}
{{- end}}{{/* field range */}}

{{- if .HasPayloadSection}}

		// write payloads
 {{- range .FieldsReversed}}
  {{- if .TypeList}}
   {{- if eq .Type "opaque8" "uint8" "int8"}}
		if (buf.length - w < this.{{.NameNative}}.length)
			return 0;
		java_unsafe.copyMemory(this.{{.NameNative}}, java_unsafe.ARRAY_BYTE_BASE_OFFSET,
			buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, this.{{.NameNative}}.length);
		w += this.{{.NameNative}}.length;

   {{- else if eq .Type "opaque16"}}
		if (buf.length - w < this.{{.NameNative}}.length << 1)
			return 0;
		for (short b : this.{{.NameNative}}) {
			java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 2;
		}

   {{- else if eq .Type "opaque32"}}
		if (buf.length - w < this.{{.NameNative}}.length << 2)
			return 0;
		for (int b : this.{{.NameNative}}) {
			java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 4;
		}

   {{- else if eq .Type "opaque64"}}
		if (buf.length - w < this.{{.NameNative}}.length << 3)
			return 0;
		for (long b : this.{{.NameNative}}) {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, b);
			w += 8;
		}

   {{- else if eq .Type "float32"}}
		if (buf.length - w < this.{{.NameNative}}.length << 2)
			return 0;
		for (float f : this.{{.NameNative}}) {
			java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
				Float.floatToRawIntBits(f));
			w += 4;
		}

   {{- else if eq .Type "float64"}}
		if (buf.length - w < this.{{.NameNative}}.length << 3)
			return 0;
		for (double d : this.{{.NameNative}}) {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
				Double.doubleToRawLongBits(d));
			w += 8;
		}

   {{- else if eq .Type "timestamp"}}
		if (buf.length - w < this.{{.NameNative}}.length << 3)
			return 0;
		for (Instant t : this.{{.NameNative}}) {
			java_unsafe.putLong(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
				t.getEpochSecond() << 30 | Integer.toUnsignedLong(t.getNano()));
			w += 8;
		}

   {{- else if eq .Type "text"}}
		int field{{.Index}}_size_index = w; // size table pointer
		w += this.{{.NameNative}}.length; // jump to payloads
		for (String s : this.{{.NameNative}}) {
			final int utf8_off = w;
			final int utf16_len = s.length();
			if (buf.length - w < utf16_len)
				return 0;
			// size check is lazily redone on multi-byte encodings
			for (int i = 0; i < utf16_len; i++) {
				char c = s.charAt(i);
				if (c < '\u0080') {
					java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)c);
				} else if (c < '\u0800') {
					if (buf.length - w < (utf16_len - i) + 1)
						return 0;
					java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
						(short)(0x80c0 | c >> 6 | (c & 0x3f) << 8));
					w += 2;
				} else if (! Character.isHighSurrogate(c)) {
					if (buf.length - w < (utf16_len - i) + 2)
						return 0;
					java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, 0x8080e0 |
						(int)c >>> 12 | ((int)c << 2) & 0x3f00 | ((int)c << 16) & 0x3f0000);
					w += 3;
				} else {
					char low = 0;
					if (i + 1 < utf16_len) low = s.charAt(++i);
					if (!Character.isLowSurrogate(low)) { // broken pair
						java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)'?');
						i--; // unread
					} else {
						if (buf.length - w < (utf16_len - i) + 3)
							return 0;
						int cp = Character.toCodePoint(c, low);
						java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
							0x808080f0 | cp>>>18 | (cp>>>4 & 0x3f00) |
							(cp<<10 & 0x3f0000) | (cp<<24 & 0x3f000000));
						w += 4;
					}
				}
			}

			// write size declaration
			int utf8_len = w - utf8_off;
			if (utf8_len > {{.Struct.UTF8Max}})
				 return 0;
			{{- /* TODO(pascaldekloe): write per word—8 at a time */}}
			java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET +
				field{{.Index}}_size_index++, (byte)utf8_len);
		}

   {{- else if .TypeRef}}
		if (this.{{.NameNative}}.length > {{.Struct.ListMax}})
			return 0;
		long v{{.Index}} = w;
		for ({{.TypeNative}} o : this.{{.NameNative}}) {
			int n = o.marshal(buf, w);
			if (n < 4)
				return 0;
			w += n;
		}
		v{{.Index}} = (w - v{{.Index}}) << 8 | this.{{.NameNative}}.length | {{.TypeRef.FixedSize}} << 20;
{{template "marshal32" .}}

   {{- end}}{{/* type select */}}
  {{- else}}{{/* not list */}}
   {{- if eq .Type "text"}}
    {{- if not .ElementCount}}
		{
			final int utf8_off = w;
			final int utf16_len = this.{{.NameNative}}.length();
			if (buf.length - w < utf16_len)
				return 0;
			// size check is lazily redone on multi-byte encodings
			for (int i = 0; i < utf16_len; i++) {
				char c = this.{{.NameNative}}.charAt(i);
				if (c < '\u0080') {
					java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)c);
				} else if (c < '\u0800') {
					if (buf.length - w < (utf16_len - i) + 1)
						return 0;
					java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
						(short)(0x80c0 | c >> 6 | (c & 0x3f) << 8));
					w += 2;
				} else if (! Character.isHighSurrogate(c)) {
					if (buf.length - w < (utf16_len - i) + 2)
						return 0;
					java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, 0x8080e0 |
						(int)c >>> 12 | ((int)c << 2) & 0x3f00 | ((int)c << 16) & 0x3f0000);
					w += 3;
				} else {
					char low = 0;
					if (i + 1 < utf16_len) low = this.{{.NameNative}}.charAt(++i);
					if (!Character.isLowSurrogate(low)) { // broken pair
						java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)'?');
						i--; // unread
					} else {
						if (buf.length - w < (utf16_len - i) + 3)
							return 0;
						int cp = Character.toCodePoint(c, low);
						java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
							0x808080f0 | cp>>>18 | (cp>>>4 & 0x3f00) |
							(cp<<10 & 0x3f0000) | (cp<<24 & 0x3f000000));
						w += 4;
					}
				}
			}

			// write size declaration
			int utf8_len = w - utf8_off;
			if (utf8_len > {{.Struct.UTF8Max}})
				return 0;
			word{{.WordIndex}} |= (long)utf8_len << {{.WordShift}};
		}

    {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		{
			final int utf8_off = w;
			final int utf16_len = this.{{.NameNative}}[{{$arrayIndex}}].length();
			// size check is lazily redone on multi-byte encodings
			if (buf.length - w < utf16_len)
				return 0;
			for (int i = 0; i < utf16_len; i++) {
				char c = this.{{.NameNative}}[{{$arrayIndex}}].charAt(i);
				if (c < '\u0080') {
					java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)c);
				} else if (c < '\u0800') {
					if (buf.length - w < (utf16_len - i) + 1)
						return 0;
					java_unsafe.putShort(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
						(short)(0x80c0 | c >> 6 | (c & 0x3f) << 8));
					w += 2;
				} else if (! Character.isHighSurrogate(c)) {
					if (buf.length - w < (utf16_len - i) + 2)
						return 0;
					java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w, 0x8080e0 |
						(int)c >>> 12 | ((int)c << 2) & 0x3f00 | ((int)c << 16) & 0x3f0000);
					w += 3;
				} else {
					char low = 0;
					if (i + 1 < utf16_len) low = this.{{.NameNative}}[{{$arrayIndex}}].charAt(++i);
					if (!Character.isLowSurrogate(low)) { // broken pair
						java_unsafe.putByte(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w++, (byte)'?');
						i--; // unread
					} else {
						if (buf.length - w < (utf16_len - i) + 3)
							return 0;
						int cp = Character.toCodePoint(c, low);
						java_unsafe.putInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + w,
							0x808080f0 | cp>>>18 | (cp>>>4 & 0x3f00) |
							(cp<<10 & 0x3f0000) | (cp<<24 & 0x3f000000));
						w += 4;
					}
				}
			}

			// write size declaration
			int utf8_len = w - utf8_off;
			if (utf8_len > {{.Struct.UTF8Max}})
				return 0;
			word{{.WordIndex}} |= (long)utf8_len << {{.WordShift}};
		}

    {{- end}}{{end}}{{end}}{{/* is array */}}

   {{- end}}{{/* type select */}}
  {{- end}}{{/* not list */}}
 {{- end}}{{/* field range */}}
{{- end}}{{/* has payload section */}}

		// write fixed positions
		int size = w - off;
{{- if .HasPayloadSection}}
		if (size > COLFER_MAX)
			return 0;
{{- end}}{{/* has payload section */}}
		word0 |= size << 3;
{{- range .FixedWordIndices}}
		java_unsafe.putLong(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + ({{.}} * 8), word{{.}});
{{- end}}
{{- if .FixedWordRemainderSize}}
 {{- $wordIndex := len .FixedWordIndices}}
 {{- range .FixedWordRemainderByteIndices}}
		java_unsafe.putByte(buf, off + java_unsafe.ARRAY_BYTE_BASE_OFFSET + ({{$wordIndex}} * 8) + {{.}},
			(byte)(word{{$wordIndex}} >>> ({{.}} * 8)));
 {{- end}}
{{- end}}
		return size;
	}

	/**
	 * Reads a Colfer encoding of {@code this} data strucure from a buffer
	 * range. All fields are updated, regardless of their value beforehand.
	 * Unmarshalling requires at least {@link #UNMARSHAL_BUF_MIN} of space
	 * since the offset, as in {@code buf.length} − {@code off} ≥ {@code
	 * {{.NameNative}}.UNMARSHAL_BUF_MIN}.
	 * Preferably, use {@link #COLFER_MAX}—not {@link #MARSHAL_MAX}—to
	 * prevent any buffer underflows from happening.
	 *
	 * The return is zero ({@code 0}) on incomplete data, one ({@code 1}) on
	 * malformed data, or in range {@link #COLFER_MIN}..{@link #COLFER_MAX}
	 * on valid data. Note that the return may be less than {@code len}.
	 * Data selection within the buffer, including its exceptions, matches
	 * Java's standard {@link java.io.InputStream#read(byte[],int,int) read}
	 * and {@link java.io.OutputStream#write(byte[],int,int) write}.
	 *
	 * @param buf the input buffer.
	 * @param off the start index [offset] in the buffer.
	 * @param len the number of bytes available since the offset.
	 * @return either the encoding size, or {@code 0}, or {code 1}.
	 * @throws IllegalArgumentException when the buffer capacity minus its
	 *         offset is less than {@link #UNMARSHAL_BUF_MIN}.
	 * @throws IndexOutOfBoundsException when the buffer capacity does not
	 *         match the offset–length combination.
	 */
	public int unmarshal(byte[] buf, int off, int len) {
		if ((off | len) < 0 || buf.length - off < len)
			throw new IndexOutOfBoundsException("range beyond buffer dimensions");
		if (buf.length - off < UNMARSHAL_BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");

{{- range .FixedWordIndices}}
		final long word{{.}} = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + ({{.}}L * 8L));
{{- end}}
{{- if .FixedWordRemainderSize}}
 {{- $wordIndex := len .FixedWordIndices}}
		final long word{{$wordIndex}} = java_unsafe.getLong(buf, (long)off + java_unsafe.ARRAY_LONG_BASE_OFFSET + ({{$wordIndex}}L * 8L));
{{- end}}

		final int size = (int)word0>>>3 & 0xfff;
		final int fixed_size = (int)word0>>>15 & 0x1ff;
		if (len < COLFER_MIN || size > len) return 0;

		// read index at variable section
		int r = off + fixed_size;
{{- if .HasPayloadSection}}
		int payload_offset = off + size; // packed in reverse order
{{- end}}
{{- range .Fields}}
		// unpack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
		if (fixed_size <= {{.FixedIndex}}) {
			this.{{.NameNative}} = this.zero_{{.NameNative}};
		} else {
			this.{{.NameNative}} = new {{.TypeNative}}[(int)(word{{.WordIndex}} >> {{.WordShift}}) & {{.Struct.ListMax}}];

  {{- if eq .Type "opaque8" "uint8" "int8"}}
			payload_offset -= this.{{.NameNative}}.length;
			if (payload_offset < r) return 1;
			java_unsafe.copyMemory(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset,
				this.{{.NameNative}}, java_unsafe.ARRAY_BYTE_BASE_OFFSET,
				this.{{.NameNative}}.length);

  {{- else if eq .Type "opaque16"}}
			payload_offset -= this.{{.NameNative}}.length << 1;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++)
				this.{{.NameNative}}[i] = java_unsafe.getShort(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<2);

  {{- else if eq .Type "opaque32"}}
			payload_offset -= this.{{.NameNative}}.length << 2;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++)
				this.{{.NameNative}}[i] = java_unsafe.getInt(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<2);

  {{- else if eq .Type "opaque64"}}
			payload_offset -= this.{{.NameNative}}.length << 3;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++)
				this.{{.NameNative}}[i] = java_unsafe.getLong(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<3);

  {{- else if eq .Type "float32"}}
			payload_offset -= this.{{.NameNative}}.length << 2;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++)
				this.{{.NameNative}}[i] = Float.intBitsToFloat(java_unsafe.getInt(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<2));

  {{- else if eq .Type "float64"}}
			payload_offset -= this.{{.NameNative}}.length << 3;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++)
				this.{{.NameNative}}[i] = Double.longBitsToDouble(java_unsafe.getLong(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<3));

  {{- else if eq .Type "timestamp"}}
			payload_offset -= this.{{.NameNative}}.length << 3;
			if (payload_offset < r) return 1;
			for (int i = 0; i < this.{{.NameNative}}.length; i++) {
				long v = java_unsafe.getLong(buf,
					java_unsafe.ARRAY_BYTE_BASE_OFFSET + payload_offset + i<<3);
				this.{{.NameNative}}[i] = Instant.ofEpochSecond(v >>> 30, (int)v & (1 << 30) - 1);
			}

  {{- end}}{{/* list type selection */}}
		}

 {{- else if eq .Type "opaque8" "uint8" "int8"}}
  {{- if eq .ElementCount 0}}
		this.{{.NameNative}} = (byte)(word{{.WordIndex}} >> {{.WordShift}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (byte)(word{{.WordIndex}} >> {{.WordShift}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque16"}}
  {{- if not .ElementCount}}
{{template "unmarshal16" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal16" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque32"}}
  {{- if not .ElementCount}}
{{template "unmarshal32" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque64"}}
  {{- if not .ElementCount}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint16"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (short)v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (short)v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint32"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (int)v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (int)v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint64"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int16"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (short)((short)(v{{.Index}} >>> 1) ^ -(short)(v{{.Index}} & 1L));
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (short)((short)(v{{.Index}} >>> 1) ^ -(short)(v{{.Index}} & 1L));
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int32"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (int)(v{{.Index}} >>> 1) ^ -(int)(v{{.Index}} & 1L);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (int)(v{{.Index}} >>> 1) ^ -(int)(v{{.Index}} & 1L);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int64"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = v{{.Index}} >>> 1 ^ -(v{{.Index}} & 1L);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}} >>> 1 ^ -(v{{.Index}} & 1L);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "float32"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
		this.{{.NameNative}} = Float.intBitsToFloat(v{{.Index}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = Float.intBitsToFloat(v{{.Index}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "float64"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = Double.longBitsToDouble(v{{.Index}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = Double.longBitsToDouble(v{{.Index}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "timestamp"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = Instant.ofEpochSecond(v{{.Index}} >>> 30, (int)v{{.Index}} & (1 << 30) - 1);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = Instant.ofEpochSecond(v{{.Index}} >>> 30, (int) v{{.Index}} & (1 << 30) - 1);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "text"}}
		if (fixed_size <= {{.FixedIndex}}) {
  {{- if not .ElementCount}}
			this.{{.NameNative}} = "";
  {{- else}}{{range $arrayIndex, $element := .Elements}}
			this.{{.NameNative}}[{{$arrayIndex}}] = "";
  {{- end}}{{end}}{{/* is text array */}}
		} else {
  {{- if not .ElementCount}}
			int utf8_length = (int)(word{{.WordIndex}} >>> {{.WordShift}}) & {{.Struct.UTF8Max}};
			payload_offset -= utf8_length;
			if (payload_offset < r) return 1;
			this.{{.NameNative}} = new String(buf, payload_offset, utf8_length, UTF_8);

  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
			int utf8_length{{$arrayIndex}} = (int)(word{{.WordIndex}} >>> {{.WordShift}}) & {{.Struct.UTF8Max}};
			payload_offset -= utf8_length{{$arrayIndex}};
			if (payload_offset < r) return 1;
			this.{{.NameNative}}[{{$arrayIndex}}] = new String(buf, payload_offset, utf8_length{{$arrayIndex}}, UTF_8);
  {{- end}}{{end}}{{end}}{{/* is text array */}}
		}

 {{- else if eq .Type "bool"}}
  {{- if not .FirstInBitField}}
		// travels for free
  {{- else if eq .BoolIndex 0}}
		this._flags = (int)(word{{.WordIndex}} >>> {{.WordShift}}) & 0xff;
  {{- else if le .BoolIndex .WordShift}}
		this._flags |= (int)(word{{.WordIndex}} >>> {{.WordShift}}-{{.BoolIndex}}) & 0xff<<{{.BoolIndex}};
  {{- else}}
		this._flags |= (int)(word{{.WordIndex}} << {{.BoolIndex}}-{{.WordShift}}) & 0xff<<{{.BoolIndex}};
  {{- end}}

 {{- end}}{{/* type select */}}
{{- end}}{{/* field range */}}

{{/* line break */}}

		// clear/undo absent fields
		if (fixed_size < FIXED_SIZE) switch (fixed_size) {
			default:
				return 1;
{{- range .FieldsReversed}}
 {{- if eq .Index 0}}{{continue}}{{/* one field required */}}{{end}}
 {{- if eq .Type "bool"}}{{- if not .FirstInBitField}}{{continue}}{{/* packed per eight */}}{{end}}{{end}}
			case {{.FixedIndex}}:
 {{- if .TypeList}}
  {{- /* checked during parse */}}

 {{- else if eq .Type "text"}}
  {{- /* checked during parse */}}

 {{- else if eq .Type "timestamp"}}
  {{- if not .ElementCount}}
				this.{{.NameNative}} = Instant.EPOCH;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
				this.{{.NameNative}}[{{$arrayIndex}}] = Instant.EPOCH;
  {{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "bool"}}
				this._flags &= (1 << {{.BoolIndex}}) - 1;

 {{- else}}
  {{- if not .ElementCount}}
				this.{{.NameNative}} = 0;
  {{- else}}{{range $arrayIndex, $element := .Elements}}
				this.{{.NameNative}}[{{$arrayIndex}}] = 0;
  {{end}}{{end}}{{/* is array */}}

 {{- end}}{{/* type match */}}
{{- end}}{{/* reverse field range */}}
		}

		return size;
	}

	/**
	 * {@link java.io.Serializable} version number reflects the fields present.
	 * Values in range [0, 127] belong to Colfer version 1.
	 */
	private static final long serialVersionUID = {{len .Fields}}L << 7;

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param out serial destination.
	 * @throws java.io.IOException a {@link java.io.WriteAbortedException}{{if .HasPayloadSection}}
	 *         or an {@link java.io.InvalidObjectException} when encoding
	 *         would exceed {@link #MARSHAL_MAX}.{{end}}
	 */
	private void writeObject(ObjectOutputStream out) throws IOException {
		byte[] buf = new byte[MARSHAL_BUF_MAX];
		int n = marshal(buf, 0);
{{- if .HasPayloadSection}}
		if (n == 0) throw new InvalidObjectException("Colfer's {{.SizeProfile}} profile exceeded");
{{- end}}
		try {
			out.write(buf, 0, n);
		} catch (IOException e) {
			throw new WriteAbortedException("halt on Colfer payload", e);
		}
	}

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param in serial source.
	 * @throws ClassNotFoundException never.
	 * @throws java.io.IOException either from {@code in} or a
	 *  {@link java.io.StreamCorruptedException}.
	 */
	private void readObject(ObjectInputStream in)
	throws ClassNotFoundException, IOException {
		byte[] buf = new byte[COLFER_MAX];
		in.readFully(buf, 0, COLFER_MIN);
		int head = java_unsafe.getInt(buf, java_unsafe.ARRAY_BYTE_BASE_OFFSET);
		int size = head>>>3 & 0xfff;
		in.readFully(buf, COLFER_MIN, size - COLFER_MIN);
		if (unmarshal(buf, 0, size) != size)
			throw new StreamCorruptedException("not a Colfer encoding of {{.Name}}");
	}

{{- range .Fields}}
 {{- if ne .Type "bool"}}

	/**
	 * Gets {{.String}}.
	 * @return the value.
	 */
	public {{.TypeNative}}{{if or .TypeList .ElementCount}}[]{{end}} get{{title .NameNative}}() {
		return this.{{.NameNative}};
	}

  {{- if not .ElementCount}}
	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 */
	public void set{{title .NameNative}}({{.TypeNative}}{{if .TypeList}}[]{{end}} value) {
		this.{{.NameNative}} = value;
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public {{$class}} with{{title .NameNative}}({{.TypeNative}}{{if .TypeList}}[]{{end}} value) {
		set{{title .NameNative}}(value);
		return this;
	}
  {{- end}}{{/* not array */}}
 {{- else}}{{/* is boolean */}}

	/**
	 * Gets {{.String}}.
	 * @return the value.
	 */
	public boolean get{{title .NameNative}}() {
		return (this._flags & {{upperSnake .NameNative}}_FLAG) != 0;
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 */
	public void set{{title .NameNative}}(boolean value) {
		if (value) {
			this._flags |= {{upperSnake .NameNative}}_FLAG;
		} else {
			this._flags &= ~{{upperSnake .NameNative}}_FLAG;
		}
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public {{$class}} with{{title .NameNative}}(boolean value) {
		set{{title .NameNative}}(value);
		return this;
	}

 {{- end}}{{/* is boolean */}}
{{- end}}{{/* field range */}}

	/**
	 * Deep hash is consistent with {@link #equals(Object)}.
	 * @return the standard Java digest.
	 */
	@Override
	public final int hashCode() {
		int h = {{if .Pkg.SuperClass}}super.hashCode(){{else}}1{{end}};
{{- range .Fields}}
 {{- if .BoolIndex}}{{continue}}{{end}}

 {{- if .TypeList}}
		h = h * 31 + Arrays.hashCode(this.{{.NameNative}});
 {{- else if not .ElementCount}}
  {{- if eq .Type "bool"}}{{continue}}{{end}}
		h = h * 31 +
  {{- if eq .Type "opaque8" "uint8" "int8"}} (int)this.{{.NameNative}};
  {{- else if eq .Type "opaque16" "uint16" "int16"}} (int)this.{{.NameNative}};
  {{- else if eq .Type "opaque64" "uint64" "int64"}} Long.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "float32"}} Float.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "float64"}} Double.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}.hashCode();
  {{- else}} this.{{.NameNative}};
  {{- end}}{{/* type select */}}

 {{- else}}{{/* is array */}}

   {{- range $arrayIndex, $element := .Elements}}
		h = h * 31 +
    {{- if eq .Type "opaque8" "uint8" "int8"}} (int)this.{{.NameNative}}[{{$arrayIndex}}];
    {{- else if eq .Type "opaque16" "uint16" "int16"}} (int)this.{{.NameNative}}[{{$arrayIndex}}];
    {{- else if eq .Type "opaque64" "uint64" "int64"}} Long.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "float32"}} Float.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "float64"}} Double.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}[{{$arrayIndex}}].hashCode();
    {{- else}} this.{{.NameNative}}[{{$arrayIndex}}];
    {{- end}}{{/* type select */}}
   {{- end}}{{/* array range */}}

 {{- end}}{{/* is array */}}
{{- end}}{{/* field range */}}
  {{- if .HasBool}}
		h = h * 31 + this._flags;
  {{- end}}
		return h;
	}

	/**
	 * Deep comparison is consistent with {@link #hashCode}.
{{- if .HasFloat}}
	 * Two not-a-number values compare equal.
{{- end}}
	 * @param o anything, including {@code null}.
	 * @return the type and content match.
	 */
	@Override
	public final boolean equals(Object o) {
		return o instanceof {{$class}} && equals(({{$class}})o);
	}

	/**
	 * Typed alternative to {@link #equals(Object)}.
	 * @param o same class or {@code null}.
	 * @return the content match.
	 */
	public final boolean equals({{$class}} o) {
		if (o == null) return false;
		if (o == this) return true;

		return
{{- range .Fields}}
 {{- if eq .Index 0}}
  {{- if .Struct.Pkg.SuperClass}} super.equals(o)
			&&
  {{- end}}
 {{- else if not .BoolIndex}}{{/* is followup */}}
			&&
 {{- end}}

 {{- if .TypeList}} Arrays.equals(this.{{.NameNative}}, o.{{.NameNative}})
 {{- else if eq .Type "bool"}}{{if eq .BoolIndex 0}} this._flags == o._flags{{end}}
 {{- else if not .ElementCount}}

  {{- if eq .Type "float32" "float64"}} (this.{{.NameNative}} == o.{{.NameNative}} || (this.{{.NameNative}} != this.{{.NameNative}} && o.{{.NameNative}} != o.{{.NameNative}}))
  {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}.equals(o.{{.NameNative}})
  {{- else}} this.{{.NameNative}} == o.{{.NameNative}}
  {{- end}}{{/* type select */}}

 {{- else}}{{/* is array */}}

   {{- range $arrayIndex, $element := .Elements}}
    {{- if gt $arrayIndex 0}}
			&&{{end}}
    {{- if eq .Type "float32" "float64"}} (this.{{.NameNative}}[{{$arrayIndex}}] == o.{{.NameNative}}[{{$arrayIndex}}] || (this.{{.NameNative}}[{{$arrayIndex}}] != this.{{.NameNative}}[{{$arrayIndex}}] && o.{{.NameNative}}[{{$arrayIndex}}] != o.{{.NameNative}}[{{$arrayIndex}}]))
    {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}[{{$arrayIndex}}].equals(o.{{.NameNative}}[{{$arrayIndex}}])
    {{- else}} this.{{.NameNative}}[{{$arrayIndex}}] == o.{{.NameNative}}[{{$arrayIndex}}]
    {{- end}}{{/* type select */}}
   {{- end}}{{/* array range */}}

 {{- end}}{{/* is array */}}
{{- end}}{{/* field range */ -}}
;
	}
}
