package {{.Pkg.NameNative}};


// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file {{.Pkg.SchemaFileList}}.


/**
{{.DocText " * "}}
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
{{- range .TagAdd}}
{{.}}
{{- end}}
{{$class := .NameNative}}public class {{$class}}
{{- if .Pkg.SuperClass}}
extends {{.Pkg.SuperClassNative}}
{{- end}}
implements java.io.Serializable{{range .Pkg.InterfaceNatives}}, {{.}}{{end}} {

	/** The lower boundary on output bytes. */
	public static int MARSHAL_MIN = {{.FixedSize}};
	/** The upper boundary on output bytes. */
	public static int MARSHAL_MAX = {{if .HasPayloadSection}}4096{{else}}{{.FixedSize}} + {{.OverflowMax}}{{end}};
	/** The lower boundary on input bytes. */
	public static int UNMARSHAL_MIN = {{.SizeMin}};
	/** The upper boundary on input bytes. */
	public static int UNMARSHAL_MAX = 4096;
	/** The lower boundary for byte capacity on in and output buffers. */
	public static int BUF_MIN = {{.FixedSize}} + {{.OverflowMax}};

{{- if .HasBool}}
 {{- range .Fields}}
  {{- if eq .Type "bool"}}
   {{- if .Docs}}

	/**
{{.DocText "\t * "}}
	 */
   {{- end}}{{/* has docs */}}
	public static int {{upperSnake .NameNative}}_FLAG = 1 << {{.BoolIndex}};
  {{- end}}{{/* is boolean */}}
 {{- end}}{{/* field range */}}

	/**
	 * Bit field for boolean flags.
	 * <ul>
 {{- range .Fields}}
  {{- if eq .Type "bool"}}
	 * <li>{@link #{{upperSnake .NameNative}}_FLAG}
  {{- end}}{{/* is boolean */}}
 {{- end}}{{/* field range */}}
	 * </ul>
	 */
	public int bools;
{{- end}}{{/* has boolean */}}


{{- range .Fields}}
 {{- if eq .Type "bool"}}{{continue}}{{end}}
{{/* new line */}}
 {{- if .Docs}}
	/**
{{.DocText "\t * "}}
	 */
 {{- end}}{{/* has docs */}}
 {{- range .TagAdd}}
	{{.}}
 {{- end}}{{/* tag range */}}
	public {{if .ElementCount}}final {{end}}{{.TypeNative}}{{if or .TypeList .ElementCount}}[]{{end}} {{.NameNative}}
 {{- if .ElementCount}} = new {{.TypeNative}}[{{.ElementCount}}]
 {{- else if .TypeList}} = zero_{{.NameNative}}
 {{- else if eq .Type "timestamp"}} = java.time.Instant.EPOCH
 {{- else if eq .Type "text"}} = ""
 {{- end}};
{{- end}}{{/* field range */}}

{{- if .HasList}}
 {{- range .Fields}}
  {{- if .TypeList}}
	private static final {{.TypeNative}}[] zero_{{.NameNative}} = new {{.TypeNative}}[0];
  {{- end}}{{/* is list */}}
 {{- end}}{{/* field range */}}
{{- end}}{{/* has list */}}

	private static final long[] COLFER_MASKS = {
		0,
		0xffL,
		0xffffL,
		0xffffffL,
		0xffffffffL,
		0xffffffffffL,
		0xffffffffffffL,
		0xffffffffffffffL,
		0xffffffffffffffffL,
	};

	/** Default constructor. */
	public {{.NameNative}}() { }

{{- if .Pkg.CodeSnippet}}

	// BEGIN Code Snippet Injection

{{.Pkg.CodeSnippet}}

	// END Code Snippet Injection
{{- end}}

	/** {@link java.io.InputStream} reader. */
	public static class Unmarshaller {

		/** The data source. */
		private final java.io.InputStream in;

		/** The read buffer. */
		private final byte[] buf;

		/** The start index in {@link #buf}. */
		private int off;

		/** The number of bytes in {@link #buf} (since {@link #off}). */
		private int len;


		/**
		 * Deserializes the following object.
		 * @param in the data source.
		 * @param bufn the buffer size in bytes.
		 */
		public Unmarshaller(java.io.InputStream in, int bufn) {
			this.in = in;
			this.buf = new byte[bufn < UNMARSHAL_MAX ? UNMARSHAL_MAX : bufn];
		}

		/**
		 * Unmarshals next in line.
		 * @return the result or {@code null} when EOF.
		 * @throws java.io.IOException from the {@code java.io.InputStream}.
		 * @throws java.io.EOFException on a partial record.
		 * @throws java.io.StreamCorruptedException when the data does not match this object's schema.
		 */
		public {{$class}} nextOrNull() throws java.io.IOException {
			if (len == 0) {
				off = 0;
				if (!read()) return null; // EOF
			} else if (buf.length - off < BUF_MIN) {
				System.arraycopy(buf, off, buf, 0, len);
				off = 0;
			}

			{{$class}} o = new {{$class}}();
			while (true) {
				int size = o.unmarshal(buf, off, len);
				if (size > 3) {
					off += size;
					len -= size;
					return o;
				}
				if (size != 0)
					throw new java.io.StreamCorruptedException("illegal Colfer encoding");
				if (off != 0) {
					System.arraycopy(buf, off, buf, 0, len);
					off = 0;
				}
				if (!read())
					throw new java.io.EOFException("partial Colfer encoding");
			}
		}

		/** Buffer more data. The return is {@code false} on EOF. */
		private boolean read() throws java.io.IOException {
			int pos = this.off + this.len;
			int n = in.read(buf, pos, buf.length - pos);
			if (n < 0) return false;
			this.len += n;
			return true;
		}

	}

	/**
	 * Writes a Colfer encoding to the buffer. The output size is guaranteed
	 * with {@link #MARSHAL_MIN} and {@link #MARSHAL_MAX}.{{if .HasPayloadSection}} Return 0 signals
	 * that encoding would exceed {@link #MARSHAL_MAX}.{{end}}
	 *
	 * @param buf the output buffer.
	 * @param off the start index [offset] in the buffer.
	 * @return the encoding size{{if .HasPayloadSection}} or 0{{end}}.
	 * @throws IllegalArgumentException when the buffer capacity since the
	 *         offset is less than {@link BUF_MIN}.
	 * @throws java.nio.BufferOverflowException is prevented with a buffer
	 *         capacity since the offset of at least {@link #MARSHAL_MAX}.
	 */
	public int marshal{{if .HasPayloadSection}}WithBounds{{end}}(byte[] buf, int off) {
		if (off < 0 || buf.length - off < BUF_MIN)
			throw new IllegalArgumentException("output buffer space less than BUF_MIN");

		int w = off + {{.FixedSize}}; // write index
		long word0 = {{.FixedSize}} << 12;

{{- if .HasText}}
		long variableSize = 0;
{{- end}}

{{- range .Fields}}

		// pack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}.length);
{{template "marshal-integer" .}}

 {{- else if eq .Type "bool"}}
  {{- if eq .WordShift 0}}
		long word{{.WordIndex}} = this.bools>>{{.BoolIndex}} & 255L;
  {{- else if le .BoolIndex .WordShift}}
		word{{.WordIndex}} |= (long)this.bools<<({{.WordShift}}-{{.BoolIndex}}) & 255L<<{{.WordShift}};
  {{- else}}
		word{{.WordIndex}} |= (long)this.bools>>({{.BoolIndex}}-{{.WordShift}}) & 255L<<{{.WordShift}};
  {{- end}}

 {{- else if eq .Type "opaque8" "uint8" "int8"}}
  {{- if not .ElementCount}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = Byte.toUnsignedLong(this.{{.NameNative}});
   {{- else}}
		word{{.WordIndex}} |= Byte.toUnsignedLong(this.{{.NameNative}}) << {{.WordShift}};
   {{- end}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
   {{- if not .WordShift}}
		long word{{.WordIndex}} = Byte.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
   {{- else}}
		word{{.WordIndex}} |= Byte.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]) << {{.WordShift}};
   {{- end}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}});
{{template "marshal16" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal16" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}});
{{template "marshal32" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal32" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "opaque64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}};
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}});
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Short.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}});
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "uint64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}};
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}];
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int16"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}>>15 ^ this.{{.NameNative}}<<1);
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]>>15 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}>>31 ^ this.{{.NameNative}}<<1);
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}]>>31 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1);
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "int64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}}>>63 ^ this.{{.NameNative}}<<1;
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}]>>63 ^ this.{{.NameNative}}[{{$arrayIndex}}]<<1;
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "float32"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Integer.toUnsignedLong(Float.floatToRawIntBits(this.{{.NameNative}}));
{{template "marshal32" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Integer.toUnsignedLong(Float.floatToRawIntBits(this.{{.NameNative}}[{{$arrayIndex}}]));
{{template "marshal32" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "float64"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = Double.doubleToRawLongBits(this.{{.NameNative}});
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = Double.doubleToRawLongBits(this.{{.NameNative}}[{{$arrayIndex}}]);
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "timestamp"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}}.getEpochSecond() << 30 | Integer.toUnsignedLong(this.{{.NameNative}}.getNano());
{{template "marshal64" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}].getEpochSecond() << 30 | Integer.toUnsignedLong(this.{{.NameNative}}[{{$arrayIndex}}].getNano());
{{template "marshal64" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- else if eq .Type "text"}}
  {{- if not .ElementCount}}
		long v{{.Index}} = this.{{.NameNative}}.length();
		for (int i = 0, end = (int) v{{.Index}}; i < end; i++) {
			char c = this.{{.NameNative}}.charAt(i);
			if (c < '\u0080') continue; // 1 char to 1 UTF-8 byte
			if (c < '\u0800') v{{.Index}}++; // 1 char to 2 UTF-8 bytes
			else if (! Character.isHighSurrogate(c)) v{{.Index}} += 2; // 1 char to 3 UTF-8 bytes
			else if (i + 1 < end && Character.isLowSurrogate(this.{{.NameNative}}.charAt(i + 1))) {
				v{{.Index}} += 2; // 2 chars to 4 UTF-8 bytes
				i++;
			} // else broken surrogate replaced with '?'
		}
		variableSize += v{{.Index}};
{{template "marshal-integer" .}}
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		long v{{.Index}} = this.{{.NameNative}}[{{$arrayIndex}}].length();
		for (int i = 0, end = (int) v{{.Index}}; i < end; i++) {
			char c = this.{{.NameNative}}[{{$arrayIndex}}].charAt(i);
			if (c < '\u0080') continue; // 1 char to 1 UTF-8 byte
			if (c < '\u0800') v{{.Index}}++; // 1 char to 2 UTF-8 bytes
			else if (! Character.isHighSurrogate(c)) v{{.Index}} += 2; // 1 char to 3 UTF-8 bytes
			else if (i + 1 < end && Character.isLowSurrogate(this.{{.NameNative}}[{{$arrayIndex}}].charAt(i + 1))) {
				v{{.Index}} += 2; // 2 chars to 4 UTF-8 bytes
				i++;
			} // else broken surrogate replaced with '?'
		}
		variableSize += v{{.Index}};
{{template "marshal-integer" .}}
  {{- end}}{{end}}{{end}}{{/* is array */}}

 {{- end}}{{/* type match */}}
{{- end}}{{/* field range */}}

{{- if .HasPayloadSection}}
 {{- if not .HasText}}
		long variableSize = 0;
 {{- end}}
 {{- range .Fields}}
  {{- if .TypeList}}
   {{- if eq .Type "opaque8" "uint8" "int8"}}
		variableSize += this.{{.NameNative}}.length;
   {{- else if eq .Type "opaque16"}}
		variableSize += this.{{.NameNative}}.length << 1;
   {{- else if eq .Type "opaque32" "float32"}}
		variableSize += this.{{.NameNative}}.length << 2;
   {{- else if eq .Type "opaque64" "float64" "timestamp"}}
		variableSize += this.{{.NameNative}}.length << 3;
   {{- /* text counted already */}}
   {{- end}}{{/* type match */}}
  {{- end}}{{/* is list */}}
 {{- end}}{{/* field range */}}

		// boundary checks
		if ((long)w + variableSize > (long)off + (long)MARSHAL_MAX)
			return 0;
		if (buf.length - w < (int)variableSize)
			throw new java.nio.BufferOverflowException();

		// write payloads
 {{- range .FieldsReversed}}
  {{- if .TypeList}}
   {{- if eq .Type "opaque8" "uint8" "int8"}}
		System.arraycopy(this.{{.NameNative}}, 0, buf, w, this.{{.NameNative}}.length);
		w += this.{{.NameNative}}.length;

   {{- else if eq .Type "opaque16"}}
		for (short b : this.{{.NameNative}}) {
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
		}

   {{- else if eq .Type "opaque32"}}
		for (int b : this.{{.NameNative}}) {
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
			buf[w++] = (byte) (b >>> 16);
			buf[w++] = (byte) (b >>> 24);
		}

   {{- else if eq .Type "opaque64"}}
		for (long b : this.{{.NameNative}}) {
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
			buf[w++] = (byte) (b >>> 16);
			buf[w++] = (byte) (b >>> 24);
			buf[w++] = (byte) (b >>> 32);
			buf[w++] = (byte) (b >>> 40);
			buf[w++] = (byte) (b >>> 48);
			buf[w++] = (byte) (b >>> 56);
		}

   {{- else if eq .Type "float32"}}
		for (float f : this.{{.NameNative}}) {
			int b = Float.floatToRawIntBits(f);
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
			buf[w++] = (byte) (b >>> 16);
			buf[w++] = (byte) (b >>> 24);
		}

   {{- else if eq .Type "float64"}}
		for (double d : this.{{.NameNative}}) {
			long b = Double.doubleToRawLongBits(d);
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
			buf[w++] = (byte) (b >>> 16);
			buf[w++] = (byte) (b >>> 24);
			buf[w++] = (byte) (b >>> 32);
			buf[w++] = (byte) (b >>> 40);
			buf[w++] = (byte) (b >>> 48);
			buf[w++] = (byte) (b >>> 56);
		}

   {{- else if eq .Type "timestamp"}}
		for (java.time.Instant t : this.{{.NameNative}}) {
			long b = t.getEpochSecond() << 30 | Integer.toUnsignedLong(t.getNano());
			buf[w++] = (byte) b;
			buf[w++] = (byte) (b >>> 8);
			buf[w++] = (byte) (b >>> 16);
			buf[w++] = (byte) (b >>> 24);
			buf[w++] = (byte) (b >>> 32);
			buf[w++] = (byte) (b >>> 40);
			buf[w++] = (byte) (b >>> 48);
			buf[w++] = (byte) (b >>> 56);
		}

   {{- else if eq .Type "text"}}
		// TODO: implement text list

   {{- end}}{{/* type select */}}

  {{- else}}{{/* not list */}}
   {{- if eq .Type "text"}}
    {{- if not .ElementCount}}
		for (int i = 0, end = this.{{.NameNative}}.length(); i < end; i++) {
			char c = this.{{.NameNative}}.charAt(i);
			if (c < '\u0080') {
				buf[w++] = (byte) c;
			} else if (c < '\u0800') {
				buf[w++] = (byte) (c >> 6 | 0xc0);
				buf[w++] = (byte) (c & 0x3f | 0x80);
			} else if (! Character.isHighSurrogate(c)) {
				buf[w++] = (byte) (c >> 12 | 0xe0);
				buf[w++] = (byte) (c >> 6 & 0x3f | 0xc0);
				buf[w++] = (byte) (c & 0x3f | 0xc0);
			} else if (i + 1 >= end) {
				buf[w++] = '?'; // incomplete pair
			} else {
				char low = this.{{.NameNative}}.charAt(++i);
				if (!Character.isLowSurrogate(low)) {
					buf[w++] = '?'; // broken pair
					i--;
				} else {
					int cp = Character.toCodePoint(c, low);
					buf[w++] = (byte) (cp >> 18 | 0xf0);
					buf[w++] = (byte) (c >> 12 & 0x3f | 0xc0);
					buf[w++] = (byte) (c >> 6 & 0x3f | 0xc0);
					buf[w++] = (byte) (c & 0x3f | 0xc0);
				}
			}
		}

    {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		for (int i = 0, end = this.{{.NameNative}}[{{$arrayIndex}}].length(); i < end; i++) {
			char c = this.{{.NameNative}}[{{$arrayIndex}}].charAt(i);
			if (c < '\u0080') {
				buf[w++] = (byte) c;
			} else if (c < '\u0800') {
				buf[w++] = (byte) (c >> 6 | 0xc0);
				buf[w++] = (byte) (c & 0x3f | 0x80);
			} else if (! Character.isHighSurrogate(c)) {
				buf[w++] = (byte) (c >> 12 | 0xe0);
				buf[w++] = (byte) (c >> 6 & 0x3f | 0xc0);
				buf[w++] = (byte) (c & 0x3f | 0xc0);
			} else if (i + 1 >= end) {
				buf[w++] = '?'; // incomplete pair
			} else {
				char low = this.{{.NameNative}}[{{$arrayIndex}}].charAt(++i);
				if (!Character.isLowSurrogate(low)) {
					buf[w++] = '?'; // broken pair
					i--;
				} else {
					int cp = Character.toCodePoint(c, low);
					buf[w++] = (byte) (cp >> 18 | 0xf0);
					buf[w++] = (byte) (c >> 12 & 0x3f | 0xc0);
					buf[w++] = (byte) (c >> 6 & 0x3f | 0xc0);
					buf[w++] = (byte) (c & 0x3f | 0xc0);
				}
			}
		}

    {{- end}}{{end}}{{end}}{{/* is array */}}

   {{- end}}{{/* type select */}}
  {{- end}}{{/* not list */}}
 {{- end}}{{/* field range */}}

{{- end}}{{/* has payloads */}}

		int size = w - off;
		word0 |= (long) size;

		// write fixed section
		w = off;
{{- range .FixedWordIndices}}
		buf[w++] = (byte)word{{.}};
		buf[w++] = (byte)(word{{.}} >> 8);
		buf[w++] = (byte)(word{{.}} >> 16);
		buf[w++] = (byte)(word{{.}} >> 24);
		buf[w++] = (byte)(word{{.}} >> 32);
		buf[w++] = (byte)(word{{.}} >> 40);
		buf[w++] = (byte)(word{{.}} >> 48);
		buf[w++] = (byte)(word{{.}} >> 56);
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
		for (int i = 0; i < {{.FixedWordRemainderSize}}; i++)
			buf[w++] = (byte)(word{{$index}} << (i << 3));
{{- end}}

		return size;
	}

	/**
	 * Reads a Colfer encoding from the buffer. Objects can be reused. All
	 * fields are initialized regardless of their value beforehand.
	 *
	 * The number of bytes read is guaranteed to lie within in the range of
	 * [{@link #UNMARSHAL_MIN}..{@link #UNMARSHAL_MAX}]. Return {@code 1}
	 * signals malformed data. Return {@code 0} signals incomplete data,
	 * a.k.a. end-of-file.
	 *
	 * Data selection within the buffer, including its exceptions, matches
	 * Java's standard {@link java.io.InputStream#read(byte[],int,int) read}
	 * and {@link java.io.OutputStream#write(byte[],int,int) write}.
	 *
	 * @param buf the input buffer.
	 * @param off the start index [offset] in the buffer.
	 * @param len the number of bytes available since the offset.
	 * @return either the encoding size, or 0 for EOF, or 1 for malformed.
	 * @throws IllegalArgumentException when the buffer capacity minus its
	 *         offset is less than {@link #BUF_MIN}.
	 * @throws IndexOutOfBoundsException when the buffer capacity does not
	 *         match the offsetâ€“length combination.
	 */
	public int unmarshal(byte[] buf, int off, int len) {
		java.util.Objects.checkFromIndexSize(off, len, buf.length);
		if (buf.length - off < BUF_MIN)
			throw new IllegalArgumentException("insufficient buffer capacity");
		if (len < 3) return 0;

		int r = off; // read index
{{- range .FixedWordIndices}}
		final long word{{.}} = (buf[r] & 255L) | (buf[r+1] & 255L) << 8
			| (buf[r+2] & 255L) << 16 | (buf[r+3] & 255L) << 24
			| (buf[r+4] & 255L) << 32 | (buf[r+5] & 255L) << 40
			| (buf[r+6] & 255L) << 48 | (buf[r+7] & 255L) << 56;
		r += 8;
{{- end}}
{{- if ne .FixedWordRemainderSize 0}}
 {{- $index := len .FixedWordIndices}}
		final long word{{$index}} = (buf[r] & 255L) | (buf[r+1] & 255L) << 8
			| (buf[r+2] & 255L) << 16 | (buf[r+3] & 255L) << 24
			| (buf[r+4] & 255L) << 32 | (buf[r+5] & 255L) << 40
			| (buf[r+6] & 255L) << 48 | (buf[r+7] & 255L) << 56;
{{- end}}

		final int size = (int)word0 & 0xfff;
		final int fixedSize = (int)(word0 >> 12) & 0xfff;
		if (size < fixedSize || fixedSize < 4) return 1;
		if (size > len) return 0;

		r = off + fixedSize;
{{- range .Fields}}
		// unpack .{{.Name}} {{if .TypeList}}[]{{end}}{{.Type}}
 {{- if .TypeList}}
{{template "unmarshal-integer" .}}
		// TODO: size check
		this.{{.NameNative}} = new {{.TypeNative}}[(int) v{{.Index}}];

 {{- else if eq .Type "opaque8" "uint8" "int8"}}
  {{- if eq .ElementCount 0}}
		this.{{.NameNative}} = (byte)(word{{.WordIndex}} >> {{.WordShift}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (byte)(word{{.WordIndex}} >> {{.WordShift}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque16"}}
  {{- if not .ElementCount}}
{{template "unmarshal16" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal16" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque32"}}
  {{- if not .ElementCount}}
{{template "unmarshal32" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "opaque64"}}
  {{- if not .ElementCount}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint16"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (short)v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (short)v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint32"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (int)v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (int)v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "uint64"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = v{{.Index}};
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}};
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int16"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (short)((short)(v{{.Index}} >>> 1) ^ -(short)(v{{.Index}} & 1L));
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (short)((short)(v{{.Index}} >>> 1) ^ -(short)(v{{.Index}} & 1L));
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int32"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = (int)(v{{.Index}} >>> 1) ^ -(int)(v{{.Index}} & 1L);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = (int)(v{{.Index}} >>> 1) ^ -(int)(v{{.Index}} & 1L);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "int64"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}} = v{{.Index}} >>> 1 ^ -(v{{.Index}} & 1L);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = v{{.Index}} >>> 1 ^ -(v{{.Index}} & 1L);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "float32"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal32" .}}
		this.{{.NameNative}} = Float.intBitsToFloat(v{{.Index}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal32" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = Float.intBitsToFloat(v{{.Index}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "float64"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = Double.longBitsToDouble(v{{.Index}});
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = Double.longBitsToDouble(v{{.Index}});
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "timestamp"}}
  {{- if eq .ElementCount 0}}
{{template "unmarshal64" .}}
		this.{{.NameNative}} = java.time.Instant.ofEpochSecond(v{{.Index}} >>> 30, (int) v{{.Index}} & (1 << 30) - 1);
  {{- else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal64" .}}
		this.{{.NameNative}}[{{$arrayIndex}}] = java.time.Instant.ofEpochSecond(v{{.Index}} >>> 30, (int) v{{.Index}} & (1 << 30) - 1);
  {{- end}}{{end}}{{end}}

 {{- else if eq .Type "text"}}
  {{- if not .ElementCount}}
{{template "unmarshal-integer" .}}
		int {{.NameNative}}_size = (int)v{{.Index}};
  {{- else}}
		int[] {{.NameNative}}_sizes = new int[{{.ElementCount}}];
   {{range $arrayIndex, $element := .Elements}}{{with $element}}
{{template "unmarshal-integer" .}}
		{{.NameNative}}_sizes[{{$arrayIndex}}] = (int)v{{.Index}};
   {{- end}}{{end}}{{/* array range */}}
  {{- end}}

 {{- else if eq .Type "bool"}}
  {{- if eq .BoolIndex 0}}
		this.bools = (int)(word{{.WordIndex}} >>> {{.WordShift}} & 0xff);
  {{- else if .FirstInBitField}}
		this.bools |= (int)(word{{.WordIndex}} >>> {{.WordShift}} & 0xff) << {{.BoolIndex}};
  {{- end}}

 {{- end}}{{/* type select */}}
{{- end}}{{/* field range */}}

	// TODO clear/reset on older versions
	// variable section reads backwords

{{if .HasPayloadSection}}
	int start = off + fixedSize;
	int end = off + size;

	// read payloads
 {{range .FieldsReversed}}
  {{- if .TypeList}}
   {{- if eq .Type "opaque8"}}

   {{- else if eq .Type "opaque16"}}

   {{- else if eq .Type "float32" "opaque32"}}

   {{- else if eq .Type "float64" "opaque64"}}

   {{- else if eq .Type "timestamp"}}

   {{- else if eq .Type "text"}}

   {{- end}}{{/* type match */}}
  {{- else}}{{/* not list */}}

   {{- if eq .Type "text"}}
    {{if not .ElementCount}}
	if (end - {{.NameNative}}_size < start)
		return 0;
	this.{{.NameNative}} = new String(buf, end - {{.NameNative}}_size, {{.NameNative}}_size, java.nio.charset.StandardCharsets.UTF_8);
	end -= {{.NameNative}}_size;
    {{else}}{{range $arrayIndex, $element := .Elements}}{{with $element}}
	if (end - {{.NameNative}}_sizes[{{$arrayIndex}}] < start)
		return 0;
	this.{{.NameNative}}[{{$arrayIndex}}] = new String(buf, end - {{.NameNative}}_sizes[{{$arrayIndex}}], {{.NameNative}}_sizes[{{$arrayIndex}}], java.nio.charset.StandardCharsets.UTF_8);
	end -= {{.NameNative}}_sizes[{{$arrayIndex}}];
    {{- end}}{{end}}{{end}}{{/* is array */}}

   {{- end}}{{/* type match */}}
  {{- end}}{{/* not list */}}
 {{- end}}{{/* reverse field range */}}
{{- end}}{{/* has payloads */}}

		return size;
	}

	/**
	 * {@link java.io.Serializable} version number reflects the fields present.
	 * Values in range [0, 127] belong to Colfer version 1.
	 */
	private static final long serialVersionUID = {{.FixedSize}}L << 7;

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param out serial destination.
	 * @throws java.io.IOException a {@link java.io.WriteAbortedException}{{if .HasPayloadSection}}
	 *         or an {@link java.io.InvalidObjectException} when encoding
	 *         would exceed {@link #MARSHAL_MAX}.{{end}}
	 * @throws java.io.IOException either an 
	 */
	private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		byte[] buf = new byte[MARSHAL_MAX];
		int n = marshal{{if .HasPayloadSection}}WithBounds{{end}}(buf, 0);
{{- if .HasPayloadSection}}
		if (n == 0) throw new java.io.InvalidObjectException("MARSHAL_MAX reached");
{{- end}}
		try {
			out.write(buf, 0, n);
		} catch (java.io.IOException e) {
			throw new java.io.WriteAbortedException("halt on Colfer payload", e);
		}
	}

	/**
	 * {@link java.io.Serializable} as Colfer.
	 * @param in serial source.
	 * @throws ClassNotFoundException never.
	 * @throws java.io.IOException either from {@code in} or a
	 *  {@link java.io.StreamCorruptedException}.
	 */
	private void readObject(java.io.ObjectInputStream in)
	throws ClassNotFoundException, java.io.IOException {
		byte[] buf = new byte[UNMARSHAL_MAX];
		in.readNBytes(buf, 0, UNMARSHAL_MIN);
		var size = (buf[0] & 0xff) | (buf[1] & 0xf) << 8;
		in.readNBytes(buf, UNMARSHAL_MIN, size - UNMARSHAL_MIN);
		if (unmarshal(buf, 0, size) != size)
			throw new java.io.StreamCorruptedException("not a {{.Name}} Colfer encoding");
	}

{{- if .HasBool}}

	/**
	 * Gets the boolean flags.
	 * @return the value.
	 */
	public int getBools() {
		return this.bools;
	}

	/**
	 * Sets the boolean flags.
	 * @param value the replacement.
	 */
	public void setBools(int value) {
		this.bools = value;
	}

	/**
	 * Sets the boolean flags.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public {{$class}} withBools(int value) {
		this.bools = value;
		return this;
	}

{{- end}}{{/* has boolean */}}

{{- range .Fields}}
 {{- if ne .Type "bool"}}

	/**
	 * Gets {{.String}}.
	 * @return the value.
	 */
	public {{.TypeNative}}{{if or .TypeList .ElementCount}}[]{{end}} get{{title .NameNative}}() {
		return this.{{.NameNative}};
	}

  {{- if not .ElementCount}}
	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 */
	public void set{{title .NameNative}}({{.TypeNative}}{{if .TypeList}}[]{{end}} value) {
		this.{{.NameNative}} = value;
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public {{$class}} with{{title .NameNative}}({{.TypeNative}}{{if .TypeList}}[]{{end}} value) {
		set{{title .NameNative}}(value);
		return this;
	}
  {{- end}}{{/* not array */}}
 {{- else}}{{/* is boolean */}}

	/**
	 * Gets {{.String}}.
	 * @return the value.
	 */
	public boolean get{{title .NameNative}}() {
		return (this.bools & {{upperSnake .NameNative}}_FLAG) != 0;
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 */
	public void set{{title .NameNative}}(boolean value) {
		if (value) {
			this.bools |= {{upperSnake .NameNative}}_FLAG;
		} else {
			this.bools &= ~{{upperSnake .NameNative}}_FLAG;
		}
	}

	/**
	 * Sets {{.String}}.
	 * @param value the replacement.
	 * @return {@code this}.
	 */
	public {{$class}} with{{title .NameNative}}(boolean value) {
		set{{title .NameNative}}(value);
		return this;
	}

 {{- end}}{{/* is boolean */}}
{{- end}}{{/* field range */}}

	/**
	 * Deep hash is consistent with {@link #equals(Object)}.
	 * @return the standard Java digest.
	 */
	@Override
	public final int hashCode() {
		int h = {{if .Pkg.SuperClass}}super.hashCode(){{else}}1{{end}};
{{- range .Fields}}
 {{- if .BoolIndex}}{{continue}}{{end}}

 {{- if .TypeList}}
		h = h * 31 + java.util.Arrays.hashCode(this.{{.NameNative}});
 {{- else if not .ElementCount}}
  {{- if eq .Type "bool"}}{{continue}}{{end}}
		h = h * 31 +
  {{- if eq .Type "opaque8" "uint8" "int8"}} (int)this.{{.NameNative}};
  {{- else if eq .Type "opaque16" "uint16" "int16"}} (int)this.{{.NameNative}};
  {{- else if eq .Type "opaque64" "uint64" "int64"}} Long.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "float32"}} Float.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "float64"}} Double.hashCode(this.{{.NameNative}});
  {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}.hashCode();
  {{- else}} this.{{.NameNative}};
  {{- end}}{{/* type select */}}

 {{- else}}{{/* is array */}}

   {{- range $arrayIndex, $element := .Elements}}
		h = h * 31 +
    {{- if eq .Type "opaque8" "uint8" "int8"}} (int)this.{{.NameNative}}[{{$arrayIndex}}];
    {{- else if eq .Type "opaque16" "uint16" "int16"}} (int)this.{{.NameNative}}[{{$arrayIndex}}];
    {{- else if eq .Type "opaque64" "uint64" "int64"}} Long.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "float32"}} Float.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "float64"}} Double.hashCode(this.{{.NameNative}}[{{$arrayIndex}}]);
    {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}[{{$arrayIndex}}].hashCode();
    {{- else}} this.{{.NameNative}}[{{$arrayIndex}}];
    {{- end}}{{/* type select */}}
   {{- end}}{{/* array range */}}

 {{- end}}{{/* is array */}}
{{- end}}{{/* field range */}}
  {{- if .HasBool}}
		h = h * 31 + this.bools;
  {{- end}}
		return h;
	}

	/**
	 * Deep comparison is consistent with {@link #hashCode}.
{{- if .HasFloat}}
	 * Two not-a-number values compare equal.
{{- end}}
	 * @param o anything, including {@code null}.
	 * @return the type and content match.
	 */
	@Override
	public final boolean equals(Object o) {
		return o instanceof {{$class}} && equals(({{$class}})o);
	}

	/**
	 * Typed alternative to {@link #equals(Object)}.
	 * @param o same class or {@code null}.
	 * @return the content match.
	 */
	public final boolean equals({{$class}} o) {
		if (o == null) return false;
		if (o == this) return true;

		return
{{- range .Fields}}
 {{- if eq .Index 0}}
  {{- if .Struct.Pkg.SuperClass}} super.equals(o)
			&&
  {{- end}}
 {{- else if not .BoolIndex}}{{/* is followup */}}
			&&
 {{- end}}

 {{- if .TypeList}} java.util.Arrays.equals(this.{{.NameNative}}, o.{{.NameNative}})
 {{- else if eq .Type "bool"}}{{if eq .BoolIndex 0}} this.bools == o.bools{{end}}
 {{- else if not .ElementCount}}

  {{- if eq .Type "float32" "float64"}} (this.{{.NameNative}} == o.{{.NameNative}} || (this.{{.NameNative}} != this.{{.NameNative}} && o.{{.NameNative}} != o.{{.NameNative}}))
  {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}.equals(o.{{.NameNative}})
  {{- else}} this.{{.NameNative}} == o.{{.NameNative}}
  {{- end}}{{/* type select */}}

 {{- else}}{{/* is array */}}

   {{- range $arrayIndex, $element := .Elements}}
    {{- if gt $arrayIndex 0}}
			&&{{end}}
    {{- if eq .Type "float32" "float64"}} (this.{{.NameNative}}[{{$arrayIndex}}] == o.{{.NameNative}}[{{$arrayIndex}}] || (this.{{.NameNative}}[{{$arrayIndex}}] != this.{{.NameNative}}[{{$arrayIndex}}] && o.{{.NameNative}}[{{$arrayIndex}}] != o.{{.NameNative}}[{{$arrayIndex}}]))
    {{- else if eq .Type "timestamp" "text"}} this.{{.NameNative}}[{{$arrayIndex}}].equals(o.{{.NameNative}}[{{$arrayIndex}}])
    {{- else}} this.{{.NameNative}}[{{$arrayIndex}}] == o.{{.NameNative}}[{{$arrayIndex}}]
    {{- end}}{{/* type select */}}
   {{- end}}{{/* array range */}}

 {{- end}}{{/* is array */}}
{{- end}}{{/* field range */ -}}
;
	}
}
