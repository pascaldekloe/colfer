// Code generated by colf(1); DO NOT EDIT.
{{- range .}}{{/* package range */}}
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{- end}}

#include <stdint.h>
#include <stdlib.h>
{{- if .HasTimestamp}}
#include <time.h>
{{- end }}

#ifdef __cplusplus
extern "C" {
#endif
{{- range .}}{{/* package range */}}
{{- range .Structs}}

// Encodings with the {{.SizeProfile}} profile are limited to {{.SizeMaxSI}} in size.
#define {{upperSnake .NameNative}}_FRAME_CAP {{.SizeMax}}
{{- if .HasText}}
// Encodings with the {{.SizeProfile}} profile limit each text in byte size.
#define {{upperSnake .NameNative}}_UTF8_CAP {{.UTF8Max}}
{{- end}}
{{- if .HasList}}
// Encodings with the {{.SizeProfile}} profile limit each lists in element count.
#define {{upperSnake .NameNative}}_LIST_CAP {{.ListMax}}
{{- end}}

// Encodings from this version of the data structure
{{- if not .HasVariableSection}} have a fixed size.
#define {{upperSnake .NameNative}}_MARSHAL_MAX {{.FixedSize}}
{{- else if not .HasPayloadSection}} have a natural size limit.
#define {{upperSnake .NameNative}}_MARSHAL_MAX ({{.FixedSize}} + {{.OverflowMax}})
{{- else}} are limited in size by the
// profile capacity.
#define {{upperSnake .NameNative}}_MARSHAL_MAX {{upperSnake .NameNative}}_FRAME_CAP
{{- end}}

// Output buffers with a capacity of fewer bytes may overflow. ☠️
#define {{upperSnake .NameNative}}_MARSHAL_BUF ({{upperSnake .NameNative}}_MARSHAL_MAX+7 & ~7)

{{.DocText "// "}}
struct {{.NameNative}} {

{{- range .Fields}}
 {{- if eq .Type "bool"}}{{if ne .BoolIndex 0}}{{continue}}{{end}}{{end}}

 {{- if ne .Index 0}}
{{end}}{{/* new line separtes fields */}}

 {{- if eq .Type "bool"}}{{/* first in struct due .BoolIndex check above */}}
	// Bit field for booleans defined as {{upperSnake .NameNative}}_*_FLAG.
	unsigned int _flags;
  {{- continue}}
 {{- end}}

 {{- if .Docs}}
{{.DocText "\t// "}}
 {{- end}}
 {{- if not .TypeList}}
  {{- if eq .Type "text"}}
	struct {
		const {{.TypeNative}} utf8;
		size_t len; // octet count
	}

  {{- else if .TypeRef}}
	struct {{.TypeRef.NameNative}}

  {{- else}}
	{{.TypeNative}}

  {{- end}}{{/* type match */}}
 {{- else}}{{/* is list */}}
  {{- if eq .Type "text"}}
	struct {
		struct {
			const {{.TypeNative}} utf8;
			size_t len; // octet count
		}* list;
		size_t len; // element count
	}

  {{- else if .TypeRef}}
	struct {
		struct {{.TypeRef.NameNative}}* list;
		size_t len; // element count
	}

  {{- else}}
	struct {
		{{.TypeNative}}* list;
		size_t len; // element count
	}

  {{- end}}{{/* type match */}}
 {{- end}}{{/* is list */}} {{.NameNative}}{{if ne .ElementCount 0}}[{{.ElementCount}}]{{end}};
{{- end}}{{/* field range */}}
};

{{- if .HasBool}}

{{- range .Fields}}{{if eq .Type "bool"}}
{{if .Docs}}
{{.DocText "// "}}{{end}}
#define {{.NameNative}} (1 << {{.BoolIndex}})
{{- end}}{{end}}{{/* boolean range */}}

{{- end}}{{/* has boolean */}}

// Encode the data structure as Colfer into a buffer. Marshal may overflow
// buffers with a capacity of less than {{upperSnake .NameNative}}_MARSHAL_BUF.
{{- if not .HasPayloadSection}}
// This specific version of the data structure always succeeds with a return of
// {{if not .HasVariableSection}}exactly{{else}}up to{{end}} {{upperSnake .NameNative}}_MARSHAL_MAX.
// However, future revisions may return zero (0) on any the following.
{{- else}}
// The return is zero (0) on any of the following, exclusively.
{{- end}}
//
//  • encoding exceeds {{upperSnake .NameNative}}_FRAME_CAP
//  • a text exceeds {{upperSnake .NameNative}}_TEXT_CAP
//  • a list exceeds {{upperSnake .NameNative}}_LIST_CAP
//
size_t
{{.NameNative}}_marshal(const struct {{.NameNative}}* o, void* buf);

// Decode the data structure as Colfer from a data pointer. Unmarshal may over
// read buffers with a capacity of less than {{upperSnake .NameNative}}_FRAME_CAP.
// The return equals the encoding size when successful, and it is zero (0) on
// error encounters.
//
// All struct fields are updated, regardless of their initial value. The struct
// is fully zeroed on error encounters.{{if .HasPayloadSection}} Malloc is not used on decoding errors.
// ENOMEM may leave fields unintialized
{{- if .HasText}}
// Texts are allocated including null ('\0') terminator, even when empty.
{{- end}}
{{- if .HasList}}
// Lists are allocated including <stddef.h> nullptr sentinel, even when empty.
{{- end}}
// Caller owns the memory.
{{- end}}
size_t
{{.NameNative}}_unmarshal(struct {{.NameNative}}* o, const void* start{{if .HasPayloadSection}}, void* (*malloc)(size_t){{end}});

{{- end}}{{/* struct range */}}

{{- end}}{{/* package range */}}
#ifdef __cplusplus
} // extern "C"
#endif
