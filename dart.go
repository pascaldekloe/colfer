package colfer

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/pascaldekloe/name"
)

// dartKeywords are the reserved tokens for Dart code.
// Some entries are redundant due to the use of a Go parser.
var dartKeywords = map[string]struct{}{
	"abstract": {}, "as": {}, "assert": {}, "async": {}, "await": {},
	"break": {}, "case": {}, "catch": {}, "class": {}, "const": {},
	"continue": {}, "covariant": {}, "default": {}, "deferred": {},
	"do": {}, "dynamic": {}, "else": {}, "enum": {}, "export": {},
	"extends": {}, "extension": {}, "external": {}, "factory": {},
	"false": {}, "final": {}, "finally": {}, "for": {}, "Function": {},
	"get": {}, "hide": {}, "if": {}, "implements": {}, "import": {},
	"in": {}, "interface": {}, "is": {}, "library": {}, "mixin": {},
	"new": {}, "null": {}, "on": {}, "operator": {}, "part": {},
	"rethrow": {}, "return": {}, "set": {}, "show": {}, "static": {},
	"super": {}, "switch": {}, "sync": {}, "this": {}, "throw": {},
	"true": {}, "try": {}, "typedef": {}, "var": {}, "void": {},
	"while": {}, "with": {}, "yield": {},
	// and some more not to interfere with properties
	"a": {}, "buf": {}, "header": {}, "i": {}, "marshal": {}, "nextData": {},
	"nextHeader": {}, "ns": {}, "readVarint": {}, "s": {}, "size": {},
	"unmarshal": {}, "us": {}, "v": {}, "vi": {}, "view": {},
}

// GenerateDart writes the code into file "Colfer.dart".
func GenerateDart(basedir string, packages Packages) error {
	if err := os.MkdirAll(basedir, os.ModeDir|os.ModePerm); err != nil {
		return err
	}

	t := template.New("dart-code")
	template.Must(t.Parse(dartCode))
	template.Must(t.New("marshal").Parse(dartMarshal))
	template.Must(t.New("unmarshal").Parse(dartUnmarshal))

	nativeTypes := map[string]string{
		"text":      "String",
		"binary":    "Uint8List",
		"timestamp": "DateTime?",
		"uint8":     "int",
		"uint16":    "int",
		"uint32":    "int",
		"uint64":    "int",
		"int32":     "int",
		"int64":     "int",
		"float32":   "double",
		"float64":   "double",
	}
	nativeListTypes := map[string]string{
		"uint8":   "Uint8List",
		"uint16":  "Uint16List",
		"uint32":  "Uint32List",
		"uint64":  "Uint64List",
		"int32":   "Int32List",
		"int64":   "Int64List",
		"float32": "Float32List",
		"float64": "Float64List",
	}

	for _, p := range packages {
		p.NameNative = p.Name
		if _, ok := dartKeywords[p.NameNative]; ok {
			p.NameNative += "_"
		}
		for _, t := range p.Structs {
			t.NameNative = name.CamelCase(t.Name, true)
			if _, ok := dartKeywords[t.NameNative]; ok {
				t.NameNative += "_"
			}
			for _, f := range t.Fields {
				f.NameNative = name.CamelCase(f.Name, false)
				if _, ok := dartKeywords[f.NameNative]; ok {
					f.NameNative += "_"
				}
			}
		}
	}

	for _, p := range packages {
		for _, t := range p.Structs {
			for _, f := range t.Fields {
				if f.TypeRef != nil {
					f.TypeNative = f.TypeRef.NameNative
					if f.TypeRef.Pkg != p {
						f.TypeNative = f.TypeRef.Pkg.NameNative + "." + f.TypeNative
					}
					continue
				}
				if f.TypeList {
					if nativeType, ok := nativeListTypes[f.Type]; ok {
						f.TypeNative = nativeType
					} else {
						f.TypeNative = nativeTypes[f.Type]
					}
				} else {
					if nativeType, ok := nativeTypes[f.Type]; ok {
						f.TypeNative = nativeType
					} else {
						f.TypeNative = f.Type
					}
				}
			}
		}
		f, err := os.Create(filepath.Join(basedir, fmt.Sprintf("colfer_%s.dart", p.Name)))
		if err != nil {
			return err
		}
		defer f.Close()
		if err = t.Execute(f, p); err != nil {
			return err
		}
		if err = f.Sync(); err != nil {
			return err
		}
	}

	res, err := exec.Command("dart", "format", basedir, "--fix", "-l", "100").Output()
	fmt.Printf("%s", res)
	return err
}

const dartCode = `// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file {{.SchemaFileList}} for package {{.Name}}.
{{.DocText "// "}}

import 'dart:typed_data';
import 'package:collection/collection.dart';
{{- $quiverSet := false}}
{{- range .Structs}}
{{- if and (not $quiverSet) (gt (len .Fields) 1)}}{{$quiverSet = true}}import 'package:quiver/core.dart';{{end}}
{{- end}}
{{- if .HasText }}
import 'dart:convert';
{{- end}}
{{- range .Refs}}
import './colfer_{{.Name}}.dart' as {{.NameNative}};
{{- end}}

/// The upper limit for serial byte sizes.
final colferSizeMax = {{.SizeMax}};
{{- if .HasList}}
/// The upper limit for the number of elements in a list.
final colferListMax = {{.ListMax}};
{{- end}}

void encodeVarint(BytesBuilder buf, int x) {
  while (x > 127) {
    buf.addByte((x & 127) | 128);
    x >>= 7;
  }
  buf.addByte(x);
}
{{if .HasTimestamp}}
int decodeInt64(Uint8List data, int i) {
  int v = 0, j = i + 7, m = 1;
  if (data[i] & 128 != 0) {
    // two's complement
    for (int carry = 1; j >= i; j--, m *= 256) {
      int b = (data[j] ^ 255) + carry;
      carry = b >> 8;
      v += (b & 255) * m;
    }
    v = -v;
  } else {
    for (; j >= i; j--, m *= 256)
      v += (data[j] * m).toInt();
  }
  return v;
}{{end}}
{{range .Structs}}
{{.DocText "// "}}
class {{.NameNative}} {
{{- range .Fields}}
{{.DocText "  // "}}
{{if and .TypeList (or (eq .Type "text") (eq .Type "binary") (eq .Type "bool") (eq .Type "timestamp") .TypeRef)}}  List<{{.TypeNative}}>
{{- else}}  {{.TypeNative}}
{{- if .TypeRef }}?
{{- end}}
{{- end}} {{.NameNative}};{{end}}

  @override
  bool operator ==(other) {
    if (!(other is {{.NameNative}})) {
      print('compare type doesn\'t match $this != $other');
      return false;
    }
{{- range .Fields}}
{{- if or .TypeList (eq .Type "binary")}}
{{- if and .TypeList (eq .Type "binary")}}
    if (other.{{.NameNative}}.length != {{.NameNative}}.length) {
      print('compare prop length of {{.NameNative}} doesn\'t match ${ {{.NameNative}}.length} != ${other.{{.NameNative}}.length}');
      return false;
    }
    for (int vi = 0; vi < {{.NameNative}}.length; vi++) {
      if (!(IterableEquality().equals(other.{{.NameNative}}[vi], {{.NameNative}}[vi]))) {
        print('compare prop {{.NameNative}}[$vi] doesn\'t match ${ {{.NameNative}}[vi]} != ${other.{{.NameNative}}[vi]}');
        return false;
      }
    }
{{- else}}
    if (!(IterableEquality().equals(other.{{.NameNative}}, {{.NameNative}}))) {
      print('compare prop {{.NameNative}} doesn\'t match ${{.NameNative}} != ${other.{{.NameNative}} }');
      return false;
    }
{{- end}}
{{- else}}
    if (other.{{.NameNative}} != {{.NameNative}}) {
      print('compare prop {{.NameNative}} doesn\'t match ${{.NameNative}} != ${other.{{.NameNative}} }');
      return false;
    }
{{- end}}
{{- end}}
    return true;
  }

  @override
  int get hashCode =>
{{- if eq (len .Fields) 1}} {{- (index .Fields 0).NameNative}}.hashCode
{{- else}} hashObjects([
{{- $first := true}}
{{- range .Fields}}
{{- if $first}}{{$first = false}}
{{- else}}, 
{{- end}}{{.NameNative}}
{{- end}}])
{{- end}};

  {{.NameNative}}({
{{- range .Fields -}}
{{- if and .TypeList (or (eq .Type "text") (eq .Type "binary") (eq .Type "bool") (eq .Type "timestamp") .TypeRef)}}List<{{.TypeNative }}>? {{.NameNative}}
{{- else if or .TypeList (and (not .TypeList) (eq .Type "binary"))}}{{.TypeNative}}? {{.NameNative}}
{{- else if eq .Type "bool"}}this.{{.NameNative}} = false
{{- else if eq .Type "text"}}this.{{.NameNative}} = ''
{{- else if eq .TypeNative "int"}}this.{{.NameNative}} = 0
{{- else if eq .TypeNative "double"}}this.{{.NameNative}} = 0.0
{{- else if or .TypeRef (eq .Type "timestamp")}}this.{{.NameNative}}
{{- end}},
{{- end}}
})
{{- if or .HasList .HasBinary}}: 
{{- $first := true}}
{{- range .Fields -}}
{{- if .TypeList}}
{{- if $first}}{{$first = false}}
{{- else}},
{{- end}}
{{.NameNative}} = {{.NameNative}} ??
{{- if or .TypeRef (eq .Type "text") (eq .Type "binary")}}[]
{{- else}}{{.TypeNative}}(0)
{{- end}}
{{- else if eq .Type "binary"}}
{{- if $first}}{{$first = false}}
{{- else}},
{{- end}}
{{.NameNative}} = {{.NameNative}} ?? {{.TypeNative}}(0)
{{- end}}
{{- end}}
{{- end}};

{{template "marshal" .}}
{{template "unmarshal" .}}
}
{{- end}}
`

const dartMarshal = `
  /// Encodes as Colfer into buf and returns the number of bytes written.
  /// It May throw RangeError or colfer related Exception.
  int marshal(BytesBuilder buf) {
    int i = buf.length;
{{range .Fields}}{{if eq .Type "bool"}}
    if ({{.NameNative}}) {
      buf.addByte({{.Index}});
    }
{{else if eq .Type "uint8"}}
    if ({{.NameNative}} != 0) {
      if ({{.NameNative}} > 255 || {{.NameNative}} < 0) {
        throw Exception('colfer: ${{.NameNative}} out of reach: {{.NameNative}}');
      }
      buf.addByte({{.Index}});
      buf.addByte({{.NameNative}});
    }
{{else if eq .Type "uint16"}}
    if ({{.NameNative}} != 0) {
      if ({{.NameNative}} > 65535 || {{.NameNative}} < 0) {
        throw Exception('colfer: ${{.NameNative}} out of reach: {{.NameNative}}');
      }
      if ({{.NameNative}} < 256) {
        buf.addByte({{.Index}} | 128);
        buf.addByte({{.NameNative}});
      } else {
        buf.addByte({{.Index}});
        buf.addByte({{.NameNative}} >> 8);
        buf.addByte({{.NameNative}} & 255);
      }
    }
{{else if eq .Type "uint32"}}
    if ({{.NameNative}} != 0) {
      if ({{.NameNative}} > 4294967295 || {{.NameNative}} < 0) {
        throw Exception('colfer: ${{.NameNative}} out of reach: {{.NameNative}}');
      }
      if ({{.NameNative}} < 0x200000) {
        buf.addByte({{.Index}});
        encodeVarint(buf, {{.NameNative}});
      } else {
        buf.addByte({{.Index}} | 128);
        buf.add(Uint8List(4)
          ..buffer.asByteData().setInt32(0, {{.NameNative}}));
      }
    }
{{else if eq .Type "uint64"}}
    if ({{.NameNative}} != 0) {
      if (0 < {{.NameNative}} && {{.NameNative}} < 0x2000000000000) {
        buf.addByte({{.Index}});
        encodeVarint(buf, {{.NameNative}});
      } else {
        buf.addByte({{.Index}} | 128);
        buf.add(Uint8List(8)
          ..buffer.asByteData().setInt64(0, {{.NameNative}}));
      }
    }
{{else if eq .Type "int32"}}
    if ({{.NameNative}} != 0) {
      if ({{.NameNative}} < 0) {
        buf.addByte({{.Index}} | 128);
        if ({{.NameNative}} < -2147483648) {
          throw Exception('colfer: ${{.NameNative}} out of reach: {{.NameNative}}');
        }
        encodeVarint(buf, -{{.NameNative}});
      } else {
        buf.addByte({{.Index}}); 
        if ({{.NameNative}} > 2147483647) {
          throw Exception('colfer: ${{.NameNative}} out of reach: {{.NameNative}}');
        }
        encodeVarint(buf, {{.NameNative}});
      }
    }
{{else if eq .Type "int64"}}
    if ({{.NameNative}} != 0) {
      int a = {{.NameNative}};
      if (a < 0) {
        buf.addByte({{.Index}} | 128);
        a = -a;
        if ({{.NameNative}} == a) {
          buf.add(List.filled(9, 128));
        } else {
          encodeVarint(buf, a);
        }
      } else {
        buf.addByte({{.Index}});
        encodeVarint(buf, a);
      }
    }
{{else if eq .Type "float32"}}
 {{- if .TypeList}}
    if ({{.NameNative}}.isNotEmpty) {
      if ({{.NameNative}}.length > colferListMax) {
        throw Exception('colfer: {{.String}} size ${ {{.NameNative}}.length} exceeds $colferListMax bytes');
      }
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);
      for (final vi in {{.NameNative}}) {
        if (vi.isNaN) {
          buf.add([0x7f, 0xc0, 0, 0]);
        } else {
          buf.add(Uint8List(4)
            ..buffer.asByteData().setFloat32(0, vi));
        }
      }
    }
 {{- else}}
    if ({{.NameNative}} != 0) {
      buf.addByte({{.Index}});
      if ({{.NameNative}}.isNaN) {
        buf.add([0x7f, 0xc0, 0, 0]);
      } else {
        buf.add(Uint8List(4)
          ..buffer.asByteData().setFloat32(0, {{.NameNative}}));
      }
    }
 {{- end}}
{{else if eq .Type "float64"}}
 {{- if .TypeList}}
    if ({{.NameNative}}.isNotEmpty) {
      if ({{.NameNative}}.length > colferListMax) {
        throw Exception('colfer: {{.String}} size ${ {{.NameNative}}.length} exceeds $colferListMax bytes');
      }
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);
      for (final vi in {{.NameNative}}) {
        if (vi.isNaN) {
          buf.add([0x7f, 0xf8, 0, 0, 0, 0, 0, 1]);
        } else {
          buf.add(Uint8List(8)
            ..buffer.asByteData().setFloat64(0, vi));
        }
      }
    }
 {{- else}}
    if ({{.NameNative}} != 0) {
      buf.addByte({{.Index}});
      if ({{.NameNative}}.isNaN) {
        buf.add([0x7f, 0xf8, 0, 0, 0, 0, 0, 1]);
      } else {
        buf.add(Uint8List(8)
          ..buffer.asByteData().setFloat64(0, {{.NameNative}}));
      }
    }
 {{- end}}
{{else if eq .Type "timestamp"}}
    if ({{.NameNative}} != null) {
      int us = {{.NameNative}}!.microsecondsSinceEpoch;
      int res = us % 1000000;
      us -= res;
      int s = us ~/ 1E6;
      int ns = res * 1000;

      if (s >= 1 << 33 || us < 0) {
        buf.addByte({{.Index}} | 128);
        buf.add(Uint8List(8)
          ..buffer.asByteData().setInt64(0, s));
      } else {
        buf.addByte({{.Index}});
        buf.add(Uint8List(4)
          ..buffer.asByteData().setInt32(0, s));
      }
      buf.add(Uint8List(4)
        ..buffer.asByteData().setInt32(0, ns));
    }
{{else if eq .Type "text"}}
 {{- if .TypeList}}
    if ({{.NameNative}}.isNotEmpty) {
      if ({{.NameNative}}.length > colferListMax) {
        throw Exception('colfer: {{.String}} size ${ {{.NameNative}}.length} exceeds $colferListMax bytes');
      }
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);

      for (final vi in {{.NameNative}}) {
        var v = utf8.encode(vi);
        encodeVarint(buf, v.length);
        buf.add(v);
      }
    }
 {{- else}}
    if ({{.NameNative}}.isNotEmpty) {
      buf.addByte({{.Index}});
      var v = utf8.encode({{.NameNative}});
      encodeVarint(buf, v.length);
      buf.add(v);
    }
 {{- end}}
{{else if eq .Type "binary"}}
 {{- if .TypeList}}
    if ({{.NameNative}}.isNotEmpty) {
      if ({{.NameNative}}.length > colferListMax) {
        throw Exception('colfer: {{.String}} size ${ {{.NameNative}}.length} exceeds $colferListMax bytes');
      }
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);
      for (final vi in {{.NameNative}}) {
        encodeVarint(buf, vi.length);
        buf.add(vi);
      }
    }
 {{- else}}
    if ({{.NameNative}}.isNotEmpty) {
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);
      buf.add({{.NameNative}});
    }
 {{- end}}
{{else if .TypeList}}
    if ({{.NameNative}}.isNotEmpty) {
      if ({{.NameNative}}.length > colferListMax) {
        throw Exception('colfer: {{.String}} size ${ {{.NameNative}}.length} exceeds $colferListMax bytes');
      }
      buf.addByte({{.Index}});
      encodeVarint(buf, {{.NameNative}}.length);
      for (var vi in {{.NameNative}}) {
        vi.marshal(buf);
      }
    }
{{else}}
    if ({{.NameNative}} != null) {
      buf.addByte({{.Index}});
      {{.NameNative}}?.marshal(buf);
    }
{{end}}
{{end}}

    buf.addByte(127);
    i = buf.length - i;
    if (i >= colferSizeMax) {
      throw Exception('colfer: {{.String}} size $i exceeds $colferSizeMax bytes');
    }
    return i;
  }`

const dartUnmarshal = `
  /// Decodes data as Colfer and returns the number of bytes read.
  /// It May throw RangeError or colfer related Exception.
  int unmarshal(Uint8List data) {
    int header = 0, i = 0;
{{- if or .HasTimestamp .HasFloat .HasUint32 -}}
    var view = ByteData.view(data.buffer);
{{- end -}}

    int nextData() {
      int dataI = data[i];
      i++;
      return dataI;
    }

    void nextHeader() {
      header = nextData();
    }
    nextHeader();
{{- if or .HasText .HasBinary .HasFloat .HasUint32 .HasInt32 .HasRefList}}

    int readVarint() {
      int c = data[i];
      i++;
      if (c >= 0x80) {
        c &= 0x7f;
        for (int shift = 7; ; shift += 7) {
          int b = data[i];
          i++;
          if (b < 0x80 || shift == 56) {
            c |= b << shift;
            break;
          }
          c |= (b & 0x7f) << shift;
        }
      }
      return c;
    }
{{- end -}}
{{range .Fields}}{{if eq .Type "bool"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = true;
      nextHeader();
    }
{{else if eq .Type "uint8"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = nextData();
      nextHeader();
    }
{{else if eq .Type "uint16"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = (nextData() << 8) | nextData();
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      {{.NameNative}} = nextData();
      nextHeader();
    }
{{else if eq .Type "uint32"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = readVarint();
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      {{.NameNative}} = view.getUint32(i);
      i += 4;
      nextHeader();
    }
{{else if eq .Type "uint64"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = readVarint();
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      int v = view.getUint32(i) * 0x100000000;
      v += view.getUint32(i + 4);
      {{.NameNative}} = v;
      i += 8;
      nextHeader();
    }
{{else if eq .Type "int32"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = readVarint();
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      {{.NameNative}} = -1 * readVarint();
      nextHeader();
    }
{{else if eq .Type "int64"}}
    if (header == {{.Index}}) {
      {{.NameNative}} = readVarint();
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      {{.NameNative}} = -1 * readVarint();
      nextHeader();
    }
{{else if eq .Type "float32"}}
    if (header == {{.Index}}) {
 {{- if .TypeList}}
      int v = readVarint();
      if (v < 0 || v > colferListMax) {
        throw Exception('colfer: {{.String}} size $v exceeds $colferListMax bytes');
      }

      if ({{.NameNative}}.length != v) {
        {{.NameNative}} = Float32List(v);
      }
      for (int vi = 0; vi < v; vi++) {
        {{.NameNative}}[vi] = view.getFloat32(i);
        i += 4;
      }
 {{- else}}
      {{.NameNative}} = view.getFloat32(i);
      i += 4;
 {{- end}}
      nextHeader();
    }
{{else if eq .Type "float64"}}
    if (header == {{.Index}}) {
 {{- if .TypeList}}
      int v = readVarint();
      if (v < 0 || v > colferListMax) {
        throw Exception('colfer: {{.String}} size $v exceeds $colferListMax bytes');
      }

      if ({{.NameNative}}.length != v) {
        {{.NameNative}} = Float64List(v);
      }
      for (int vi = 0; vi < v; vi++) {
        {{.NameNative}}[vi] = view.getFloat64(i);
        i += 8;
      }
 {{- else}}
      {{.NameNative}} = view.getFloat64(i);
      i += 8;
 {{- end}}
      nextHeader();
    }
{{else if eq .Type "timestamp"}}
    if (header == {{.Index}}) {
      int s = view.getUint32(i);
      int us = view.getUint32(i + 4) ~/ 1000;
      {{.NameNative}} = DateTime.fromMicrosecondsSinceEpoch(s * 1000000 + us);
      i += 8;
      nextHeader();
    } else if (header == ({{.Index}} | 128)) {
      int s = decodeInt64(data, i);
      int us = view.getUint32(i + 8) ~/ 1000;
      {{.NameNative}} = DateTime.fromMicrosecondsSinceEpoch(s * 1000000 + us);
      i += 12;
      nextHeader();
    }
{{else if eq .Type "text"}}
    if (header == {{.Index}}) {
 {{- if .TypeList}}
      int v = readVarint();
      if (v < 0 || v > colferListMax) {
        throw Exception('colfer: {{.String}} size $v exceeds $colferListMax bytes');
      }

      if ({{.NameNative}}.length != v) {
        {{.NameNative}} = List<String>.filled(v, '');
      }
      for (int vi = 0; vi < v; vi++) {
        int size = readVarint();
        if (size < 0 || size > colferSizeMax) {
          throw Exception('colfer: {{.String}} size $size exceeds $colferSizeMax bytes');
        }

        int s = i;
        i += size;
        {{.NameNative}}[vi] = utf8.decode(data.sublist(s, i));
      }
 {{- else}}
      int size = readVarint();
      if (size < 0 || size > colferSizeMax) {
        throw Exception('colfer: {{.String}} size $size exceeds $colferSizeMax bytes');
      }

      int s = i;
      i += size;
      {{.NameNative}} = utf8.decode(data.sublist(s, i));
 {{- end}}
      nextHeader();
    }
{{else if eq .Type "binary"}}
    if (header == {{.Index}}) {
 {{- if .TypeList}}
      int v = readVarint();
      if (v < 0 || v > colferListMax) {
        throw Exception('colfer: {{.String}} size $v exceeds $colferListMax bytes');
      }

      if ({{.NameNative}}.length != v) {
        {{.NameNative}} = List<Uint8List>.filled(v, Uint8List(0));
      }
      for (int vi = 0; vi < v; vi++) {
        int size = readVarint();
        if (size < 0 || size > colferSizeMax) {
          throw Exception('colfer: {{.String}} size $size exceeds $colferSizeMax bytes');
        }

        int s = i;
        i += size;
        {{.NameNative}}[vi] = data.sublist(s, i);
      }
 {{- else}}
      int size = readVarint();
      if (size < 0 || size > colferSizeMax) {
        throw Exception('colfer: {{.String}} size $size exceeds $colferSizeMax bytes');
      }

      int start = i;
      i += size;
      {{.NameNative}} = data.sublist(start, i);
 {{- end}}
      nextHeader();
    }
{{else if .TypeList}}
    if (header == {{.Index}}) {
      int v = readVarint();
      if (v < 0 || v > colferListMax) {
        throw Exception('colfer: {{.String}} size $v exceeds $colferListMax bytes');
      }

      if ({{.NameNative}}.length != v) {
        {{.NameNative}} = List<{{.TypeNative}}>.filled(v, {{.TypeNative}}());
      }
      for (int vi = 0; vi < v; vi++) {
        i += {{.NameNative}}[vi].unmarshal(data.sublist(i));
      }
      nextHeader();
    }
{{else}}
    if (header == {{.Index}}) {
      var s = {{.TypeNative}}();
      i += s.unmarshal(data.sublist(i));
      {{.NameNative}} = s;
      nextHeader();
    }
{{end}}{{end}}
    if (header != 127) {
      throw Exception('colfer: unknown header $header at byte ${i - 1}');
    }
    if (i > colferSizeMax) {
      throw Exception('colfer: {{.String}} size $i exceeds $colferSizeMax bytes');
    }
    return i;
  }
`
